schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """refresh the cache entry"""
  refresh: Boolean! = false

  """measured in seconds"""
  ttl: Int! = 60
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Float". All fields are combined with logical 'AND'.
"""
input Float_comparison_exp {
  _eq: Float
  _gt: Float
  _gte: Float
  _in: [Float!]
  _is_null: Boolean
  _lt: Float
  _lte: Float
  _neq: Float
  _nin: [Float!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
Table containing coordinators of programs, tracks, or courses. Each row corresponds to exactly one of these three types of responsibility.
"""
type coordinator {
  """
  Additional information (optional, e.g., to specify year for program or track coordination).
  """
  comment: String

  """An object relationship"""
  course: course

  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  course_id: Int

  """Unique identifier for the coordinator entry."""
  id: Int!

  """An object relationship"""
  program: program

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  program_id: Int

  """An object relationship"""
  teacher: teacher!

  """An object relationship"""
  track: track

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  track_id: Int

  """Teacher's identifier."""
  uid: String!
}

"""
aggregated selection of "coordinator"
"""
type coordinator_aggregate {
  aggregate: coordinator_aggregate_fields
  nodes: [coordinator!]!
}

input coordinator_aggregate_bool_exp {
  count: coordinator_aggregate_bool_exp_count
}

input coordinator_aggregate_bool_exp_count {
  arguments: [coordinator_select_column!]
  distinct: Boolean
  filter: coordinator_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "coordinator"
"""
type coordinator_aggregate_fields {
  avg: coordinator_avg_fields
  count(columns: [coordinator_select_column!], distinct: Boolean): Int!
  max: coordinator_max_fields
  min: coordinator_min_fields
  stddev: coordinator_stddev_fields
  stddev_pop: coordinator_stddev_pop_fields
  stddev_samp: coordinator_stddev_samp_fields
  sum: coordinator_sum_fields
  var_pop: coordinator_var_pop_fields
  var_samp: coordinator_var_samp_fields
  variance: coordinator_variance_fields
}

"""
order by aggregate values of table "coordinator"
"""
input coordinator_aggregate_order_by {
  avg: coordinator_avg_order_by
  count: order_by
  max: coordinator_max_order_by
  min: coordinator_min_order_by
  stddev: coordinator_stddev_order_by
  stddev_pop: coordinator_stddev_pop_order_by
  stddev_samp: coordinator_stddev_samp_order_by
  sum: coordinator_sum_order_by
  var_pop: coordinator_var_pop_order_by
  var_samp: coordinator_var_samp_order_by
  variance: coordinator_variance_order_by
}

"""
input type for inserting array relation for remote table "coordinator"
"""
input coordinator_arr_rel_insert_input {
  data: [coordinator_insert_input!]!

  """upsert condition"""
  on_conflict: coordinator_on_conflict
}

"""aggregate avg on columns"""
type coordinator_avg_fields {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  course_id: Float

  """Unique identifier for the coordinator entry."""
  id: Float

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  program_id: Float

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  track_id: Float
}

"""
order by avg() on columns of table "coordinator"
"""
input coordinator_avg_order_by {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  course_id: order_by

  """Unique identifier for the coordinator entry."""
  id: order_by

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  program_id: order_by

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  track_id: order_by
}

"""
Boolean expression to filter rows from the table "coordinator". All fields are combined with a logical 'AND'.
"""
input coordinator_bool_exp {
  _and: [coordinator_bool_exp!]
  _not: coordinator_bool_exp
  _or: [coordinator_bool_exp!]
  comment: String_comparison_exp
  course: course_bool_exp
  course_id: Int_comparison_exp
  id: Int_comparison_exp
  program: program_bool_exp
  program_id: Int_comparison_exp
  teacher: teacher_bool_exp
  track: track_bool_exp
  track_id: Int_comparison_exp
  uid: String_comparison_exp
}

"""
unique or primary key constraints on table "coordinator"
"""
enum coordinator_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  responsable_pkey

  """
  unique or primary key constraint on columns "track_id", "uid", "course_id", "program_id"
  """
  responsable_uid_ens_id_parcours_id_mention_id_key
}

"""
input type for incrementing numeric columns in table "coordinator"
"""
input coordinator_inc_input {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  course_id: Int

  """Unique identifier for the coordinator entry."""
  id: Int

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  program_id: Int

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  track_id: Int
}

"""
input type for inserting data into table "coordinator"
"""
input coordinator_insert_input {
  """
  Additional information (optional, e.g., to specify year for program or track coordination).
  """
  comment: String
  course: course_obj_rel_insert_input

  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  course_id: Int

  """Unique identifier for the coordinator entry."""
  id: Int
  program: program_obj_rel_insert_input

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  program_id: Int
  teacher: teacher_obj_rel_insert_input
  track: track_obj_rel_insert_input

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  track_id: Int

  """Teacher's identifier."""
  uid: String
}

"""aggregate max on columns"""
type coordinator_max_fields {
  """
  Additional information (optional, e.g., to specify year for program or track coordination).
  """
  comment: String

  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  course_id: Int

  """Unique identifier for the coordinator entry."""
  id: Int

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  program_id: Int

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  track_id: Int

  """Teacher's identifier."""
  uid: String
}

"""
order by max() on columns of table "coordinator"
"""
input coordinator_max_order_by {
  """
  Additional information (optional, e.g., to specify year for program or track coordination).
  """
  comment: order_by

  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  course_id: order_by

  """Unique identifier for the coordinator entry."""
  id: order_by

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  program_id: order_by

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  track_id: order_by

  """Teacher's identifier."""
  uid: order_by
}

"""aggregate min on columns"""
type coordinator_min_fields {
  """
  Additional information (optional, e.g., to specify year for program or track coordination).
  """
  comment: String

  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  course_id: Int

  """Unique identifier for the coordinator entry."""
  id: Int

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  program_id: Int

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  track_id: Int

  """Teacher's identifier."""
  uid: String
}

"""
order by min() on columns of table "coordinator"
"""
input coordinator_min_order_by {
  """
  Additional information (optional, e.g., to specify year for program or track coordination).
  """
  comment: order_by

  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  course_id: order_by

  """Unique identifier for the coordinator entry."""
  id: order_by

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  program_id: order_by

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  track_id: order_by

  """Teacher's identifier."""
  uid: order_by
}

"""
response of any mutation on the table "coordinator"
"""
type coordinator_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [coordinator!]!
}

"""
on_conflict condition type for table "coordinator"
"""
input coordinator_on_conflict {
  constraint: coordinator_constraint!
  update_columns: [coordinator_update_column!]! = []
  where: coordinator_bool_exp
}

"""Ordering options when selecting data from "coordinator"."""
input coordinator_order_by {
  comment: order_by
  course: course_order_by
  course_id: order_by
  id: order_by
  program: program_order_by
  program_id: order_by
  teacher: teacher_order_by
  track: track_order_by
  track_id: order_by
  uid: order_by
}

"""primary key columns input for table: coordinator"""
input coordinator_pk_columns_input {
  """Unique identifier for the coordinator entry."""
  id: Int!
}

"""
select columns of table "coordinator"
"""
enum coordinator_select_column {
  """column name"""
  comment

  """column name"""
  course_id

  """column name"""
  id

  """column name"""
  program_id

  """column name"""
  track_id

  """column name"""
  uid
}

"""
input type for updating data in table "coordinator"
"""
input coordinator_set_input {
  """
  Additional information (optional, e.g., to specify year for program or track coordination).
  """
  comment: String

  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  course_id: Int

  """Unique identifier for the coordinator entry."""
  id: Int

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  program_id: Int

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  track_id: Int

  """Teacher's identifier."""
  uid: String
}

"""aggregate stddev on columns"""
type coordinator_stddev_fields {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  course_id: Float

  """Unique identifier for the coordinator entry."""
  id: Float

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  program_id: Float

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  track_id: Float
}

"""
order by stddev() on columns of table "coordinator"
"""
input coordinator_stddev_order_by {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  course_id: order_by

  """Unique identifier for the coordinator entry."""
  id: order_by

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  program_id: order_by

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  track_id: order_by
}

"""aggregate stddev_pop on columns"""
type coordinator_stddev_pop_fields {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  course_id: Float

  """Unique identifier for the coordinator entry."""
  id: Float

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  program_id: Float

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  track_id: Float
}

"""
order by stddev_pop() on columns of table "coordinator"
"""
input coordinator_stddev_pop_order_by {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  course_id: order_by

  """Unique identifier for the coordinator entry."""
  id: order_by

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  program_id: order_by

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  track_id: order_by
}

"""aggregate stddev_samp on columns"""
type coordinator_stddev_samp_fields {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  course_id: Float

  """Unique identifier for the coordinator entry."""
  id: Float

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  program_id: Float

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  track_id: Float
}

"""
order by stddev_samp() on columns of table "coordinator"
"""
input coordinator_stddev_samp_order_by {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  course_id: order_by

  """Unique identifier for the coordinator entry."""
  id: order_by

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  program_id: order_by

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  track_id: order_by
}

"""
Streaming cursor of the table "coordinator"
"""
input coordinator_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: coordinator_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input coordinator_stream_cursor_value_input {
  """
  Additional information (optional, e.g., to specify year for program or track coordination).
  """
  comment: String

  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  course_id: Int

  """Unique identifier for the coordinator entry."""
  id: Int

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  program_id: Int

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  track_id: Int

  """Teacher's identifier."""
  uid: String
}

"""aggregate sum on columns"""
type coordinator_sum_fields {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  course_id: Int

  """Unique identifier for the coordinator entry."""
  id: Int

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  program_id: Int

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  track_id: Int
}

"""
order by sum() on columns of table "coordinator"
"""
input coordinator_sum_order_by {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  course_id: order_by

  """Unique identifier for the coordinator entry."""
  id: order_by

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  program_id: order_by

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  track_id: order_by
}

"""
update columns of table "coordinator"
"""
enum coordinator_update_column {
  """column name"""
  comment

  """column name"""
  course_id

  """column name"""
  id

  """column name"""
  program_id

  """column name"""
  track_id

  """column name"""
  uid
}

input coordinator_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: coordinator_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: coordinator_set_input

  """filter the rows which have to be updated"""
  where: coordinator_bool_exp!
}

"""aggregate var_pop on columns"""
type coordinator_var_pop_fields {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  course_id: Float

  """Unique identifier for the coordinator entry."""
  id: Float

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  program_id: Float

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  track_id: Float
}

"""
order by var_pop() on columns of table "coordinator"
"""
input coordinator_var_pop_order_by {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  course_id: order_by

  """Unique identifier for the coordinator entry."""
  id: order_by

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  program_id: order_by

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  track_id: order_by
}

"""aggregate var_samp on columns"""
type coordinator_var_samp_fields {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  course_id: Float

  """Unique identifier for the coordinator entry."""
  id: Float

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  program_id: Float

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  track_id: Float
}

"""
order by var_samp() on columns of table "coordinator"
"""
input coordinator_var_samp_order_by {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  course_id: order_by

  """Unique identifier for the coordinator entry."""
  id: order_by

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  program_id: order_by

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  track_id: order_by
}

"""aggregate variance on columns"""
type coordinator_variance_fields {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  course_id: Float

  """Unique identifier for the coordinator entry."""
  id: Float

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  program_id: Float

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  track_id: Float
}

"""
order by variance() on columns of table "coordinator"
"""
input coordinator_variance_order_by {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  course_id: order_by

  """Unique identifier for the coordinator entry."""
  id: order_by

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  program_id: order_by

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  track_id: order_by
}

"""Table contenant les enseignements."""
type course {
  """An array relationship"""
  coordinators(
    """distinct select on columns"""
    distinct_on: [coordinator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coordinator_order_by!]

    """filter the rows returned"""
    where: coordinator_bool_exp
  ): [coordinator!]!

  """An aggregate relationship"""
  coordinators_aggregate(
    """distinct select on columns"""
    distinct_on: [coordinator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coordinator_order_by!]

    """filter the rows returned"""
    where: coordinator_bool_exp
  ): coordinator_aggregate!

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycle_year: Int!

  """Une description de l'enseignement."""
  description: String

  """An array relationship"""
  enfants(
    """distinct select on columns"""
    distinct_on: [course_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_order_by!]

    """filter the rows returned"""
    where: course_bool_exp
  ): [course!]!

  """An aggregate relationship"""
  enfants_aggregate(
    """distinct select on columns"""
    distinct_on: [course_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_order_by!]

    """filter the rows returned"""
    where: course_bool_exp
  ): course_aggregate!
  ens_id_import: String
  formation_id_import: String

  """Le nombre de groupes."""
  groups: Int!

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groups_adjusted: Int
  groups_effective: Int

  """Le nombre d'heures d'enseignement par groupe."""
  hours: Float!

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hours_adjusted: Float
  hours_effective: Int

  """L'identifiant unique de l'enseignement."""
  id: Int!

  """Le nom de l'enseignement."""
  name: String!

  """Le nom abrégé (optionnel)"""
  name_short: String
  nom_import: String

  """An object relationship"""
  parent: course

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Int

  """An array relationship"""
  priorities(
    """distinct select on columns"""
    distinct_on: [priority_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [priority_order_by!]

    """filter the rows returned"""
    where: priority_bool_exp
  ): [priority!]!

  """An aggregate relationship"""
  priorities_aggregate(
    """distinct select on columns"""
    distinct_on: [priority_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [priority_order_by!]

    """filter the rows returned"""
    where: priority_bool_exp
  ): priority_aggregate!

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priority_rule: Int

  """An object relationship"""
  program: program!

  """L'identifiant de la mention de l'enseignement."""
  program_id: Int!

  """An array relationship"""
  requests(
    """distinct select on columns"""
    distinct_on: [request_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [request_order_by!]

    """filter the rows returned"""
    where: request_bool_exp
  ): [request!]!

  """An aggregate relationship"""
  requests_aggregate(
    """distinct select on columns"""
    distinct_on: [request_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [request_order_by!]

    """filter the rows returned"""
    where: request_bool_exp
  ): request_aggregate!

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: Int!

  """
  Le namebre d'hours d'course ouvertes par groupe multiplié par le namebre de groups ouverts.
  """
  total_hours_effective: Float

  """An object relationship"""
  track: track

  """L'identifiant du parcours de l'enseignement."""
  track_id: Int

  """Le type d'enseignement."""
  type: String!

  """An object relationship"""
  typeByType: course_type!

  """
  Indique si l'enseignement correspondant est visible par les utilisateurs.
  """
  visible: Boolean!

  """L'année de l'enseignement."""
  year: Int!

  """An object relationship"""
  yearByYear: year!
}

"""
aggregated selection of "course"
"""
type course_aggregate {
  aggregate: course_aggregate_fields
  nodes: [course!]!
}

input course_aggregate_bool_exp {
  bool_and: course_aggregate_bool_exp_bool_and
  bool_or: course_aggregate_bool_exp_bool_or
  count: course_aggregate_bool_exp_count
}

input course_aggregate_bool_exp_bool_and {
  arguments: course_select_column_course_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: course_bool_exp
  predicate: Boolean_comparison_exp!
}

input course_aggregate_bool_exp_bool_or {
  arguments: course_select_column_course_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: course_bool_exp
  predicate: Boolean_comparison_exp!
}

input course_aggregate_bool_exp_count {
  arguments: [course_select_column!]
  distinct: Boolean
  filter: course_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "course"
"""
type course_aggregate_fields {
  avg: course_avg_fields
  count(columns: [course_select_column!], distinct: Boolean): Int!
  max: course_max_fields
  min: course_min_fields
  stddev: course_stddev_fields
  stddev_pop: course_stddev_pop_fields
  stddev_samp: course_stddev_samp_fields
  sum: course_sum_fields
  var_pop: course_var_pop_fields
  var_samp: course_var_samp_fields
  variance: course_variance_fields
}

"""
order by aggregate values of table "course"
"""
input course_aggregate_order_by {
  avg: course_avg_order_by
  count: order_by
  max: course_max_order_by
  min: course_min_order_by
  stddev: course_stddev_order_by
  stddev_pop: course_stddev_pop_order_by
  stddev_samp: course_stddev_samp_order_by
  sum: course_sum_order_by
  var_pop: course_var_pop_order_by
  var_samp: course_var_samp_order_by
  variance: course_variance_order_by
}

"""
input type for inserting array relation for remote table "course"
"""
input course_arr_rel_insert_input {
  data: [course_insert_input!]!

  """upsert condition"""
  on_conflict: course_on_conflict
}

"""aggregate avg on columns"""
type course_avg_fields {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycle_year: Float

  """Le nombre de groupes."""
  groups: Float

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groups_adjusted: Float
  groups_effective: Float

  """Le nombre d'heures d'enseignement par groupe."""
  hours: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hours_adjusted: Float
  hours_effective: Float

  """L'identifiant unique de l'enseignement."""
  id: Float

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Float

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priority_rule: Float

  """L'identifiant de la mention de l'enseignement."""
  program_id: Float

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: Float

  """
  Le namebre d'hours d'course ouvertes par groupe multiplié par le namebre de groups ouverts.
  """
  total_hours_effective: Float

  """L'identifiant du parcours de l'enseignement."""
  track_id: Float

  """L'année de l'enseignement."""
  year: Float
}

"""
order by avg() on columns of table "course"
"""
input course_avg_order_by {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycle_year: order_by

  """Le nombre de groupes."""
  groups: order_by

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groups_adjusted: order_by
  groups_effective: order_by

  """Le nombre d'heures d'enseignement par groupe."""
  hours: order_by

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hours_adjusted: order_by
  hours_effective: order_by

  """L'identifiant unique de l'enseignement."""
  id: order_by

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: order_by

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priority_rule: order_by

  """L'identifiant de la mention de l'enseignement."""
  program_id: order_by

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: order_by

  """L'identifiant du parcours de l'enseignement."""
  track_id: order_by

  """L'année de l'enseignement."""
  year: order_by
}

"""
Boolean expression to filter rows from the table "course". All fields are combined with a logical 'AND'.
"""
input course_bool_exp {
  _and: [course_bool_exp!]
  _not: course_bool_exp
  _or: [course_bool_exp!]
  coordinators: coordinator_bool_exp
  coordinators_aggregate: coordinator_aggregate_bool_exp
  cycle_year: Int_comparison_exp
  description: String_comparison_exp
  enfants: course_bool_exp
  enfants_aggregate: course_aggregate_bool_exp
  ens_id_import: String_comparison_exp
  formation_id_import: String_comparison_exp
  groups: Int_comparison_exp
  groups_adjusted: Int_comparison_exp
  groups_effective: Int_comparison_exp
  hours: Float_comparison_exp
  hours_adjusted: Float_comparison_exp
  hours_effective: Int_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  name_short: String_comparison_exp
  nom_import: String_comparison_exp
  parent: course_bool_exp
  parent_id: Int_comparison_exp
  priorities: priority_bool_exp
  priorities_aggregate: priority_aggregate_bool_exp
  priority_rule: Int_comparison_exp
  program: program_bool_exp
  program_id: Int_comparison_exp
  requests: request_bool_exp
  requests_aggregate: request_aggregate_bool_exp
  semester: Int_comparison_exp
  total_hours_effective: Float_comparison_exp
  track: track_bool_exp
  track_id: Int_comparison_exp
  type: String_comparison_exp
  typeByType: course_type_bool_exp
  visible: Boolean_comparison_exp
  year: Int_comparison_exp
  yearByYear: year_bool_exp
}

"""
unique or primary key constraints on table "course"
"""
enum course_constraint {
  """
  unique or primary key constraint on columns "track_id", "semester", "type", "program_id", "name", "year"
  """
  enseignement_annee_mention_id_parcours_id_nom_semestre_type_key

  """
  unique or primary key constraint on columns "ens_id_import"
  """
  enseignement_ens_id_import_key

  """
  unique or primary key constraint on columns "id"
  """
  enseignement_pkey
}

"""
input type for incrementing numeric columns in table "course"
"""
input course_inc_input {
  """Le nombre de groupes."""
  groups: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groups_adjusted: Int

  """Le nombre d'heures d'enseignement par groupe."""
  hours: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hours_adjusted: Float

  """L'identifiant unique de l'enseignement."""
  id: Int

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Int

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priority_rule: Int

  """L'identifiant de la mention de l'enseignement."""
  program_id: Int

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: Int

  """L'identifiant du parcours de l'enseignement."""
  track_id: Int

  """L'année de l'enseignement."""
  year: Int
}

"""
input type for inserting data into table "course"
"""
input course_insert_input {
  coordinators: coordinator_arr_rel_insert_input

  """Une description de l'enseignement."""
  description: String
  enfants: course_arr_rel_insert_input
  ens_id_import: String
  formation_id_import: String

  """Le nombre de groupes."""
  groups: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groups_adjusted: Int

  """Le nombre d'heures d'enseignement par groupe."""
  hours: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hours_adjusted: Float

  """L'identifiant unique de l'enseignement."""
  id: Int

  """Le nom de l'enseignement."""
  name: String

  """Le nom abrégé (optionnel)"""
  name_short: String
  nom_import: String
  parent: course_obj_rel_insert_input

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Int
  priorities: priority_arr_rel_insert_input

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priority_rule: Int
  program: program_obj_rel_insert_input

  """L'identifiant de la mention de l'enseignement."""
  program_id: Int
  requests: request_arr_rel_insert_input

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: Int
  track: track_obj_rel_insert_input

  """L'identifiant du parcours de l'enseignement."""
  track_id: Int

  """Le type d'enseignement."""
  type: String
  typeByType: course_type_obj_rel_insert_input

  """
  Indique si l'enseignement correspondant est visible par les utilisateurs.
  """
  visible: Boolean

  """L'année de l'enseignement."""
  year: Int
  yearByYear: year_obj_rel_insert_input
}

"""aggregate max on columns"""
type course_max_fields {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycle_year: Int

  """Une description de l'enseignement."""
  description: String
  ens_id_import: String
  formation_id_import: String

  """Le nombre de groupes."""
  groups: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groups_adjusted: Int
  groups_effective: Int

  """Le nombre d'heures d'enseignement par groupe."""
  hours: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hours_adjusted: Float
  hours_effective: Int

  """L'identifiant unique de l'enseignement."""
  id: Int

  """Le nom de l'enseignement."""
  name: String

  """Le nom abrégé (optionnel)"""
  name_short: String
  nom_import: String

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Int

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priority_rule: Int

  """L'identifiant de la mention de l'enseignement."""
  program_id: Int

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: Int

  """
  Le namebre d'hours d'course ouvertes par groupe multiplié par le namebre de groups ouverts.
  """
  total_hours_effective: Float

  """L'identifiant du parcours de l'enseignement."""
  track_id: Int

  """Le type d'enseignement."""
  type: String

  """L'année de l'enseignement."""
  year: Int
}

"""
order by max() on columns of table "course"
"""
input course_max_order_by {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycle_year: order_by

  """Une description de l'enseignement."""
  description: order_by
  ens_id_import: order_by
  formation_id_import: order_by

  """Le nombre de groupes."""
  groups: order_by

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groups_adjusted: order_by
  groups_effective: order_by

  """Le nombre d'heures d'enseignement par groupe."""
  hours: order_by

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hours_adjusted: order_by
  hours_effective: order_by

  """L'identifiant unique de l'enseignement."""
  id: order_by

  """Le nom de l'enseignement."""
  name: order_by

  """Le nom abrégé (optionnel)"""
  name_short: order_by
  nom_import: order_by

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: order_by

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priority_rule: order_by

  """L'identifiant de la mention de l'enseignement."""
  program_id: order_by

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: order_by

  """L'identifiant du parcours de l'enseignement."""
  track_id: order_by

  """Le type d'enseignement."""
  type: order_by

  """L'année de l'enseignement."""
  year: order_by
}

"""aggregate min on columns"""
type course_min_fields {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycle_year: Int

  """Une description de l'enseignement."""
  description: String
  ens_id_import: String
  formation_id_import: String

  """Le nombre de groupes."""
  groups: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groups_adjusted: Int
  groups_effective: Int

  """Le nombre d'heures d'enseignement par groupe."""
  hours: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hours_adjusted: Float
  hours_effective: Int

  """L'identifiant unique de l'enseignement."""
  id: Int

  """Le nom de l'enseignement."""
  name: String

  """Le nom abrégé (optionnel)"""
  name_short: String
  nom_import: String

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Int

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priority_rule: Int

  """L'identifiant de la mention de l'enseignement."""
  program_id: Int

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: Int

  """
  Le namebre d'hours d'course ouvertes par groupe multiplié par le namebre de groups ouverts.
  """
  total_hours_effective: Float

  """L'identifiant du parcours de l'enseignement."""
  track_id: Int

  """Le type d'enseignement."""
  type: String

  """L'année de l'enseignement."""
  year: Int
}

"""
order by min() on columns of table "course"
"""
input course_min_order_by {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycle_year: order_by

  """Une description de l'enseignement."""
  description: order_by
  ens_id_import: order_by
  formation_id_import: order_by

  """Le nombre de groupes."""
  groups: order_by

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groups_adjusted: order_by
  groups_effective: order_by

  """Le nombre d'heures d'enseignement par groupe."""
  hours: order_by

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hours_adjusted: order_by
  hours_effective: order_by

  """L'identifiant unique de l'enseignement."""
  id: order_by

  """Le nom de l'enseignement."""
  name: order_by

  """Le nom abrégé (optionnel)"""
  name_short: order_by
  nom_import: order_by

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: order_by

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priority_rule: order_by

  """L'identifiant de la mention de l'enseignement."""
  program_id: order_by

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: order_by

  """L'identifiant du parcours de l'enseignement."""
  track_id: order_by

  """Le type d'enseignement."""
  type: order_by

  """L'année de l'enseignement."""
  year: order_by
}

"""
response of any mutation on the table "course"
"""
type course_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [course!]!
}

"""
input type for inserting object relation for remote table "course"
"""
input course_obj_rel_insert_input {
  data: course_insert_input!

  """upsert condition"""
  on_conflict: course_on_conflict
}

"""
on_conflict condition type for table "course"
"""
input course_on_conflict {
  constraint: course_constraint!
  update_columns: [course_update_column!]! = []
  where: course_bool_exp
}

"""Ordering options when selecting data from "course"."""
input course_order_by {
  coordinators_aggregate: coordinator_aggregate_order_by
  cycle_year: order_by
  description: order_by
  enfants_aggregate: course_aggregate_order_by
  ens_id_import: order_by
  formation_id_import: order_by
  groups: order_by
  groups_adjusted: order_by
  groups_effective: order_by
  hours: order_by
  hours_adjusted: order_by
  hours_effective: order_by
  id: order_by
  name: order_by
  name_short: order_by
  nom_import: order_by
  parent: course_order_by
  parent_id: order_by
  priorities_aggregate: priority_aggregate_order_by
  priority_rule: order_by
  program: program_order_by
  program_id: order_by
  requests_aggregate: request_aggregate_order_by
  semester: order_by
  total_hours_effective: order_by
  track: track_order_by
  track_id: order_by
  type: order_by
  typeByType: course_type_order_by
  visible: order_by
  year: order_by
  yearByYear: year_order_by
}

"""primary key columns input for table: course"""
input course_pk_columns_input {
  """L'identifiant unique de l'enseignement."""
  id: Int!
}

"""
select columns of table "course"
"""
enum course_select_column {
  """column name"""
  cycle_year

  """column name"""
  description

  """column name"""
  ens_id_import

  """column name"""
  formation_id_import

  """column name"""
  groups

  """column name"""
  groups_adjusted

  """column name"""
  groups_effective

  """column name"""
  hours

  """column name"""
  hours_adjusted

  """column name"""
  hours_effective

  """column name"""
  id

  """column name"""
  name

  """column name"""
  name_short

  """column name"""
  nom_import

  """column name"""
  parent_id

  """column name"""
  priority_rule

  """column name"""
  program_id

  """column name"""
  semester

  """column name"""
  track_id

  """column name"""
  type

  """column name"""
  visible

  """column name"""
  year
}

"""
select "course_aggregate_bool_exp_bool_and_arguments_columns" columns of table "course"
"""
enum course_select_column_course_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  visible
}

"""
select "course_aggregate_bool_exp_bool_or_arguments_columns" columns of table "course"
"""
enum course_select_column_course_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  visible
}

"""
input type for updating data in table "course"
"""
input course_set_input {
  """Une description de l'enseignement."""
  description: String
  ens_id_import: String
  formation_id_import: String

  """Le nombre de groupes."""
  groups: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groups_adjusted: Int

  """Le nombre d'heures d'enseignement par groupe."""
  hours: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hours_adjusted: Float

  """L'identifiant unique de l'enseignement."""
  id: Int

  """Le nom de l'enseignement."""
  name: String

  """Le nom abrégé (optionnel)"""
  name_short: String
  nom_import: String

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Int

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priority_rule: Int

  """L'identifiant de la mention de l'enseignement."""
  program_id: Int

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: Int

  """L'identifiant du parcours de l'enseignement."""
  track_id: Int

  """Le type d'enseignement."""
  type: String

  """
  Indique si l'enseignement correspondant est visible par les utilisateurs.
  """
  visible: Boolean

  """L'année de l'enseignement."""
  year: Int
}

"""aggregate stddev on columns"""
type course_stddev_fields {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycle_year: Float

  """Le nombre de groupes."""
  groups: Float

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groups_adjusted: Float
  groups_effective: Float

  """Le nombre d'heures d'enseignement par groupe."""
  hours: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hours_adjusted: Float
  hours_effective: Float

  """L'identifiant unique de l'enseignement."""
  id: Float

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Float

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priority_rule: Float

  """L'identifiant de la mention de l'enseignement."""
  program_id: Float

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: Float

  """
  Le namebre d'hours d'course ouvertes par groupe multiplié par le namebre de groups ouverts.
  """
  total_hours_effective: Float

  """L'identifiant du parcours de l'enseignement."""
  track_id: Float

  """L'année de l'enseignement."""
  year: Float
}

"""
order by stddev() on columns of table "course"
"""
input course_stddev_order_by {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycle_year: order_by

  """Le nombre de groupes."""
  groups: order_by

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groups_adjusted: order_by
  groups_effective: order_by

  """Le nombre d'heures d'enseignement par groupe."""
  hours: order_by

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hours_adjusted: order_by
  hours_effective: order_by

  """L'identifiant unique de l'enseignement."""
  id: order_by

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: order_by

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priority_rule: order_by

  """L'identifiant de la mention de l'enseignement."""
  program_id: order_by

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: order_by

  """L'identifiant du parcours de l'enseignement."""
  track_id: order_by

  """L'année de l'enseignement."""
  year: order_by
}

"""aggregate stddev_pop on columns"""
type course_stddev_pop_fields {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycle_year: Float

  """Le nombre de groupes."""
  groups: Float

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groups_adjusted: Float
  groups_effective: Float

  """Le nombre d'heures d'enseignement par groupe."""
  hours: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hours_adjusted: Float
  hours_effective: Float

  """L'identifiant unique de l'enseignement."""
  id: Float

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Float

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priority_rule: Float

  """L'identifiant de la mention de l'enseignement."""
  program_id: Float

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: Float

  """
  Le namebre d'hours d'course ouvertes par groupe multiplié par le namebre de groups ouverts.
  """
  total_hours_effective: Float

  """L'identifiant du parcours de l'enseignement."""
  track_id: Float

  """L'année de l'enseignement."""
  year: Float
}

"""
order by stddev_pop() on columns of table "course"
"""
input course_stddev_pop_order_by {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycle_year: order_by

  """Le nombre de groupes."""
  groups: order_by

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groups_adjusted: order_by
  groups_effective: order_by

  """Le nombre d'heures d'enseignement par groupe."""
  hours: order_by

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hours_adjusted: order_by
  hours_effective: order_by

  """L'identifiant unique de l'enseignement."""
  id: order_by

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: order_by

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priority_rule: order_by

  """L'identifiant de la mention de l'enseignement."""
  program_id: order_by

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: order_by

  """L'identifiant du parcours de l'enseignement."""
  track_id: order_by

  """L'année de l'enseignement."""
  year: order_by
}

"""aggregate stddev_samp on columns"""
type course_stddev_samp_fields {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycle_year: Float

  """Le nombre de groupes."""
  groups: Float

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groups_adjusted: Float
  groups_effective: Float

  """Le nombre d'heures d'enseignement par groupe."""
  hours: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hours_adjusted: Float
  hours_effective: Float

  """L'identifiant unique de l'enseignement."""
  id: Float

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Float

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priority_rule: Float

  """L'identifiant de la mention de l'enseignement."""
  program_id: Float

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: Float

  """
  Le namebre d'hours d'course ouvertes par groupe multiplié par le namebre de groups ouverts.
  """
  total_hours_effective: Float

  """L'identifiant du parcours de l'enseignement."""
  track_id: Float

  """L'année de l'enseignement."""
  year: Float
}

"""
order by stddev_samp() on columns of table "course"
"""
input course_stddev_samp_order_by {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycle_year: order_by

  """Le nombre de groupes."""
  groups: order_by

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groups_adjusted: order_by
  groups_effective: order_by

  """Le nombre d'heures d'enseignement par groupe."""
  hours: order_by

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hours_adjusted: order_by
  hours_effective: order_by

  """L'identifiant unique de l'enseignement."""
  id: order_by

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: order_by

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priority_rule: order_by

  """L'identifiant de la mention de l'enseignement."""
  program_id: order_by

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: order_by

  """L'identifiant du parcours de l'enseignement."""
  track_id: order_by

  """L'année de l'enseignement."""
  year: order_by
}

"""
Streaming cursor of the table "course"
"""
input course_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: course_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input course_stream_cursor_value_input {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycle_year: Int

  """Une description de l'enseignement."""
  description: String
  ens_id_import: String
  formation_id_import: String

  """Le nombre de groupes."""
  groups: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groups_adjusted: Int
  groups_effective: Int

  """Le nombre d'heures d'enseignement par groupe."""
  hours: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hours_adjusted: Float
  hours_effective: Int

  """L'identifiant unique de l'enseignement."""
  id: Int

  """Le nom de l'enseignement."""
  name: String

  """Le nom abrégé (optionnel)"""
  name_short: String
  nom_import: String

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Int

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priority_rule: Int

  """L'identifiant de la mention de l'enseignement."""
  program_id: Int

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: Int

  """L'identifiant du parcours de l'enseignement."""
  track_id: Int

  """Le type d'enseignement."""
  type: String

  """
  Indique si l'enseignement correspondant est visible par les utilisateurs.
  """
  visible: Boolean

  """L'année de l'enseignement."""
  year: Int
}

"""aggregate sum on columns"""
type course_sum_fields {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycle_year: Int

  """Le nombre de groupes."""
  groups: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groups_adjusted: Int
  groups_effective: Int

  """Le nombre d'heures d'enseignement par groupe."""
  hours: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hours_adjusted: Float
  hours_effective: Int

  """L'identifiant unique de l'enseignement."""
  id: Int

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Int

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priority_rule: Int

  """L'identifiant de la mention de l'enseignement."""
  program_id: Int

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: Int

  """
  Le namebre d'hours d'course ouvertes par groupe multiplié par le namebre de groups ouverts.
  """
  total_hours_effective: Float

  """L'identifiant du parcours de l'enseignement."""
  track_id: Int

  """L'année de l'enseignement."""
  year: Int
}

"""
order by sum() on columns of table "course"
"""
input course_sum_order_by {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycle_year: order_by

  """Le nombre de groupes."""
  groups: order_by

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groups_adjusted: order_by
  groups_effective: order_by

  """Le nombre d'heures d'enseignement par groupe."""
  hours: order_by

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hours_adjusted: order_by
  hours_effective: order_by

  """L'identifiant unique de l'enseignement."""
  id: order_by

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: order_by

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priority_rule: order_by

  """L'identifiant de la mention de l'enseignement."""
  program_id: order_by

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: order_by

  """L'identifiant du parcours de l'enseignement."""
  track_id: order_by

  """L'année de l'enseignement."""
  year: order_by
}

"""Table contenant les différents types d'enseignement (CM, TD, etc.)."""
type course_type {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float!

  """An array relationship"""
  courses(
    """distinct select on columns"""
    distinct_on: [course_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_order_by!]

    """filter the rows returned"""
    where: course_bool_exp
  ): [course!]!

  """An aggregate relationship"""
  courses_aggregate(
    """distinct select on columns"""
    distinct_on: [course_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_order_by!]

    """filter the rows returned"""
    where: course_bool_exp
  ): course_aggregate!
  description: String

  """Le libellé type d'enseignement."""
  label: String!

  """La clé du type d'enseignement (unique)."""
  value: String!
}

"""
aggregated selection of "course_type"
"""
type course_type_aggregate {
  aggregate: course_type_aggregate_fields
  nodes: [course_type!]!
}

"""
aggregate fields of "course_type"
"""
type course_type_aggregate_fields {
  avg: course_type_avg_fields
  count(columns: [course_type_select_column!], distinct: Boolean): Int!
  max: course_type_max_fields
  min: course_type_min_fields
  stddev: course_type_stddev_fields
  stddev_pop: course_type_stddev_pop_fields
  stddev_samp: course_type_stddev_samp_fields
  sum: course_type_sum_fields
  var_pop: course_type_var_pop_fields
  var_samp: course_type_var_samp_fields
  variance: course_type_variance_fields
}

"""aggregate avg on columns"""
type course_type_avg_fields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""
Boolean expression to filter rows from the table "course_type". All fields are combined with a logical 'AND'.
"""
input course_type_bool_exp {
  _and: [course_type_bool_exp!]
  _not: course_type_bool_exp
  _or: [course_type_bool_exp!]
  coefficient: Float_comparison_exp
  courses: course_bool_exp
  courses_aggregate: course_aggregate_bool_exp
  description: String_comparison_exp
  label: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "course_type"
"""
enum course_type_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  type_enseignement_pkey
}

"""
input type for incrementing numeric columns in table "course_type"
"""
input course_type_inc_input {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""
input type for inserting data into table "course_type"
"""
input course_type_insert_input {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
  courses: course_arr_rel_insert_input
  description: String

  """Le libellé type d'enseignement."""
  label: String

  """La clé du type d'enseignement (unique)."""
  value: String
}

"""aggregate max on columns"""
type course_type_max_fields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
  description: String

  """Le libellé type d'enseignement."""
  label: String

  """La clé du type d'enseignement (unique)."""
  value: String
}

"""aggregate min on columns"""
type course_type_min_fields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
  description: String

  """Le libellé type d'enseignement."""
  label: String

  """La clé du type d'enseignement (unique)."""
  value: String
}

"""
response of any mutation on the table "course_type"
"""
type course_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [course_type!]!
}

"""
input type for inserting object relation for remote table "course_type"
"""
input course_type_obj_rel_insert_input {
  data: course_type_insert_input!

  """upsert condition"""
  on_conflict: course_type_on_conflict
}

"""
on_conflict condition type for table "course_type"
"""
input course_type_on_conflict {
  constraint: course_type_constraint!
  update_columns: [course_type_update_column!]! = []
  where: course_type_bool_exp
}

"""Ordering options when selecting data from "course_type"."""
input course_type_order_by {
  coefficient: order_by
  courses_aggregate: course_aggregate_order_by
  description: order_by
  label: order_by
  value: order_by
}

"""primary key columns input for table: course_type"""
input course_type_pk_columns_input {
  """La clé du type d'enseignement (unique)."""
  value: String!
}

"""
select columns of table "course_type"
"""
enum course_type_select_column {
  """column name"""
  coefficient

  """column name"""
  description

  """column name"""
  label

  """column name"""
  value
}

"""
input type for updating data in table "course_type"
"""
input course_type_set_input {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
  description: String

  """Le libellé type d'enseignement."""
  label: String

  """La clé du type d'enseignement (unique)."""
  value: String
}

"""aggregate stddev on columns"""
type course_type_stddev_fields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""aggregate stddev_pop on columns"""
type course_type_stddev_pop_fields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""aggregate stddev_samp on columns"""
type course_type_stddev_samp_fields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""
Streaming cursor of the table "course_type"
"""
input course_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: course_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input course_type_stream_cursor_value_input {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
  description: String

  """Le libellé type d'enseignement."""
  label: String

  """La clé du type d'enseignement (unique)."""
  value: String
}

"""aggregate sum on columns"""
type course_type_sum_fields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""
update columns of table "course_type"
"""
enum course_type_update_column {
  """column name"""
  coefficient

  """column name"""
  description

  """column name"""
  label

  """column name"""
  value
}

input course_type_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: course_type_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: course_type_set_input

  """filter the rows which have to be updated"""
  where: course_type_bool_exp!
}

"""aggregate var_pop on columns"""
type course_type_var_pop_fields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""aggregate var_samp on columns"""
type course_type_var_samp_fields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""aggregate variance on columns"""
type course_type_variance_fields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""
update columns of table "course"
"""
enum course_update_column {
  """column name"""
  description

  """column name"""
  ens_id_import

  """column name"""
  formation_id_import

  """column name"""
  groups

  """column name"""
  groups_adjusted

  """column name"""
  hours

  """column name"""
  hours_adjusted

  """column name"""
  id

  """column name"""
  name

  """column name"""
  name_short

  """column name"""
  nom_import

  """column name"""
  parent_id

  """column name"""
  priority_rule

  """column name"""
  program_id

  """column name"""
  semester

  """column name"""
  track_id

  """column name"""
  type

  """column name"""
  visible

  """column name"""
  year
}

input course_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: course_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: course_set_input

  """filter the rows which have to be updated"""
  where: course_bool_exp!
}

"""aggregate var_pop on columns"""
type course_var_pop_fields {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycle_year: Float

  """Le nombre de groupes."""
  groups: Float

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groups_adjusted: Float
  groups_effective: Float

  """Le nombre d'heures d'enseignement par groupe."""
  hours: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hours_adjusted: Float
  hours_effective: Float

  """L'identifiant unique de l'enseignement."""
  id: Float

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Float

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priority_rule: Float

  """L'identifiant de la mention de l'enseignement."""
  program_id: Float

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: Float

  """
  Le namebre d'hours d'course ouvertes par groupe multiplié par le namebre de groups ouverts.
  """
  total_hours_effective: Float

  """L'identifiant du parcours de l'enseignement."""
  track_id: Float

  """L'année de l'enseignement."""
  year: Float
}

"""
order by var_pop() on columns of table "course"
"""
input course_var_pop_order_by {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycle_year: order_by

  """Le nombre de groupes."""
  groups: order_by

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groups_adjusted: order_by
  groups_effective: order_by

  """Le nombre d'heures d'enseignement par groupe."""
  hours: order_by

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hours_adjusted: order_by
  hours_effective: order_by

  """L'identifiant unique de l'enseignement."""
  id: order_by

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: order_by

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priority_rule: order_by

  """L'identifiant de la mention de l'enseignement."""
  program_id: order_by

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: order_by

  """L'identifiant du parcours de l'enseignement."""
  track_id: order_by

  """L'année de l'enseignement."""
  year: order_by
}

"""aggregate var_samp on columns"""
type course_var_samp_fields {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycle_year: Float

  """Le nombre de groupes."""
  groups: Float

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groups_adjusted: Float
  groups_effective: Float

  """Le nombre d'heures d'enseignement par groupe."""
  hours: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hours_adjusted: Float
  hours_effective: Float

  """L'identifiant unique de l'enseignement."""
  id: Float

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Float

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priority_rule: Float

  """L'identifiant de la mention de l'enseignement."""
  program_id: Float

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: Float

  """
  Le namebre d'hours d'course ouvertes par groupe multiplié par le namebre de groups ouverts.
  """
  total_hours_effective: Float

  """L'identifiant du parcours de l'enseignement."""
  track_id: Float

  """L'année de l'enseignement."""
  year: Float
}

"""
order by var_samp() on columns of table "course"
"""
input course_var_samp_order_by {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycle_year: order_by

  """Le nombre de groupes."""
  groups: order_by

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groups_adjusted: order_by
  groups_effective: order_by

  """Le nombre d'heures d'enseignement par groupe."""
  hours: order_by

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hours_adjusted: order_by
  hours_effective: order_by

  """L'identifiant unique de l'enseignement."""
  id: order_by

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: order_by

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priority_rule: order_by

  """L'identifiant de la mention de l'enseignement."""
  program_id: order_by

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: order_by

  """L'identifiant du parcours de l'enseignement."""
  track_id: order_by

  """L'année de l'enseignement."""
  year: order_by
}

"""aggregate variance on columns"""
type course_variance_fields {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycle_year: Float

  """Le nombre de groupes."""
  groups: Float

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groups_adjusted: Float
  groups_effective: Float

  """Le nombre d'heures d'enseignement par groupe."""
  hours: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hours_adjusted: Float
  hours_effective: Float

  """L'identifiant unique de l'enseignement."""
  id: Float

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Float

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priority_rule: Float

  """L'identifiant de la mention de l'enseignement."""
  program_id: Float

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: Float

  """
  Le namebre d'hours d'course ouvertes par groupe multiplié par le namebre de groups ouverts.
  """
  total_hours_effective: Float

  """L'identifiant du parcours de l'enseignement."""
  track_id: Float

  """L'année de l'enseignement."""
  year: Float
}

"""
order by variance() on columns of table "course"
"""
input course_variance_order_by {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycle_year: order_by

  """Le nombre de groupes."""
  groups: order_by

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groups_adjusted: order_by
  groups_effective: order_by

  """Le nombre d'heures d'enseignement par groupe."""
  hours: order_by

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hours_adjusted: order_by
  hours_effective: order_by

  """L'identifiant unique de l'enseignement."""
  id: order_by

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: order_by

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priority_rule: order_by

  """L'identifiant de la mention de l'enseignement."""
  program_id: order_by

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: order_by

  """L'identifiant du parcours de l'enseignement."""
  track_id: order_by

  """L'année de l'enseignement."""
  year: order_by
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""Table contenant les différents cursus (licence, master, etc.)."""
type degree {
  """L'identifiant unique du cursus."""
  id: Int!

  """Le nom du cursus (unique)."""
  name: String!

  """Le nom abrégé (optionnel)."""
  name_short: String

  """An array relationship"""
  programs(
    """distinct select on columns"""
    distinct_on: [program_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [program_order_by!]

    """filter the rows returned"""
    where: program_bool_exp
  ): [program!]!

  """An aggregate relationship"""
  programs_aggregate(
    """distinct select on columns"""
    distinct_on: [program_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [program_order_by!]

    """filter the rows returned"""
    where: program_bool_exp
  ): program_aggregate!

  """Indique si le cursus correspondant est visible par les utilisateurs."""
  visible: Boolean!
}

"""
aggregated selection of "degree"
"""
type degree_aggregate {
  aggregate: degree_aggregate_fields
  nodes: [degree!]!
}

"""
aggregate fields of "degree"
"""
type degree_aggregate_fields {
  avg: degree_avg_fields
  count(columns: [degree_select_column!], distinct: Boolean): Int!
  max: degree_max_fields
  min: degree_min_fields
  stddev: degree_stddev_fields
  stddev_pop: degree_stddev_pop_fields
  stddev_samp: degree_stddev_samp_fields
  sum: degree_sum_fields
  var_pop: degree_var_pop_fields
  var_samp: degree_var_samp_fields
  variance: degree_variance_fields
}

"""aggregate avg on columns"""
type degree_avg_fields {
  """L'identifiant unique du cursus."""
  id: Float
}

"""
Boolean expression to filter rows from the table "degree". All fields are combined with a logical 'AND'.
"""
input degree_bool_exp {
  _and: [degree_bool_exp!]
  _not: degree_bool_exp
  _or: [degree_bool_exp!]
  id: Int_comparison_exp
  name: String_comparison_exp
  name_short: String_comparison_exp
  programs: program_bool_exp
  programs_aggregate: program_aggregate_bool_exp
  visible: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "degree"
"""
enum degree_constraint {
  """
  unique or primary key constraint on columns "name"
  """
  cursus_nom_key

  """
  unique or primary key constraint on columns "id"
  """
  cursus_pkey
}

"""
input type for incrementing numeric columns in table "degree"
"""
input degree_inc_input {
  """L'identifiant unique du cursus."""
  id: Int
}

"""
input type for inserting data into table "degree"
"""
input degree_insert_input {
  """L'identifiant unique du cursus."""
  id: Int

  """Le nom du cursus (unique)."""
  name: String

  """Le nom abrégé (optionnel)."""
  name_short: String
  programs: program_arr_rel_insert_input

  """Indique si le cursus correspondant est visible par les utilisateurs."""
  visible: Boolean
}

"""aggregate max on columns"""
type degree_max_fields {
  """L'identifiant unique du cursus."""
  id: Int

  """Le nom du cursus (unique)."""
  name: String

  """Le nom abrégé (optionnel)."""
  name_short: String
}

"""aggregate min on columns"""
type degree_min_fields {
  """L'identifiant unique du cursus."""
  id: Int

  """Le nom du cursus (unique)."""
  name: String

  """Le nom abrégé (optionnel)."""
  name_short: String
}

"""
response of any mutation on the table "degree"
"""
type degree_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [degree!]!
}

"""
input type for inserting object relation for remote table "degree"
"""
input degree_obj_rel_insert_input {
  data: degree_insert_input!

  """upsert condition"""
  on_conflict: degree_on_conflict
}

"""
on_conflict condition type for table "degree"
"""
input degree_on_conflict {
  constraint: degree_constraint!
  update_columns: [degree_update_column!]! = []
  where: degree_bool_exp
}

"""Ordering options when selecting data from "degree"."""
input degree_order_by {
  id: order_by
  name: order_by
  name_short: order_by
  programs_aggregate: program_aggregate_order_by
  visible: order_by
}

"""primary key columns input for table: degree"""
input degree_pk_columns_input {
  """L'identifiant unique du cursus."""
  id: Int!
}

"""
select columns of table "degree"
"""
enum degree_select_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  name_short

  """column name"""
  visible
}

"""
input type for updating data in table "degree"
"""
input degree_set_input {
  """L'identifiant unique du cursus."""
  id: Int

  """Le nom du cursus (unique)."""
  name: String

  """Le nom abrégé (optionnel)."""
  name_short: String

  """Indique si le cursus correspondant est visible par les utilisateurs."""
  visible: Boolean
}

"""aggregate stddev on columns"""
type degree_stddev_fields {
  """L'identifiant unique du cursus."""
  id: Float
}

"""aggregate stddev_pop on columns"""
type degree_stddev_pop_fields {
  """L'identifiant unique du cursus."""
  id: Float
}

"""aggregate stddev_samp on columns"""
type degree_stddev_samp_fields {
  """L'identifiant unique du cursus."""
  id: Float
}

"""
Streaming cursor of the table "degree"
"""
input degree_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: degree_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input degree_stream_cursor_value_input {
  """L'identifiant unique du cursus."""
  id: Int

  """Le nom du cursus (unique)."""
  name: String

  """Le nom abrégé (optionnel)."""
  name_short: String

  """Indique si le cursus correspondant est visible par les utilisateurs."""
  visible: Boolean
}

"""aggregate sum on columns"""
type degree_sum_fields {
  """L'identifiant unique du cursus."""
  id: Int
}

"""
update columns of table "degree"
"""
enum degree_update_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  name_short

  """column name"""
  visible
}

input degree_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: degree_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: degree_set_input

  """filter the rows which have to be updated"""
  where: degree_bool_exp!
}

"""aggregate var_pop on columns"""
type degree_var_pop_fields {
  """L'identifiant unique du cursus."""
  id: Float
}

"""aggregate var_samp on columns"""
type degree_var_samp_fields {
  """L'identifiant unique du cursus."""
  id: Float
}

"""aggregate variance on columns"""
type degree_variance_fields {
  """L'identifiant unique du cursus."""
  id: Float
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "coordinator"
  """
  delete_coordinator(
    """filter the rows which have to be deleted"""
    where: coordinator_bool_exp!
  ): coordinator_mutation_response

  """
  delete single row from the table: "coordinator"
  """
  delete_coordinator_by_pk(
    """Unique identifier for the coordinator entry."""
    id: Int!
  ): coordinator

  """
  delete data from the table: "course"
  """
  delete_course(
    """filter the rows which have to be deleted"""
    where: course_bool_exp!
  ): course_mutation_response

  """
  delete single row from the table: "course"
  """
  delete_course_by_pk(
    """L'identifiant unique de l'enseignement."""
    id: Int!
  ): course

  """
  delete data from the table: "course_type"
  """
  delete_course_type(
    """filter the rows which have to be deleted"""
    where: course_type_bool_exp!
  ): course_type_mutation_response

  """
  delete single row from the table: "course_type"
  """
  delete_course_type_by_pk(
    """La clé du type d'enseignement (unique)."""
    value: String!
  ): course_type

  """
  delete data from the table: "degree"
  """
  delete_degree(
    """filter the rows which have to be deleted"""
    where: degree_bool_exp!
  ): degree_mutation_response

  """
  delete single row from the table: "degree"
  """
  delete_degree_by_pk(
    """L'identifiant unique du cursus."""
    id: Int!
  ): degree

  """
  delete data from the table: "phase"
  """
  delete_phase(
    """filter the rows which have to be deleted"""
    where: phase_bool_exp!
  ): phase_mutation_response

  """
  delete single row from the table: "phase"
  """
  delete_phase_by_pk(
    """Phase identifier."""
    value: String!
  ): phase

  """
  delete data from the table: "position"
  """
  delete_position(
    """filter the rows which have to be deleted"""
    where: position_bool_exp!
  ): position_mutation_response

  """
  delete single row from the table: "position"
  """
  delete_position_by_pk(value: String!): position

  """
  delete data from the table: "priority"
  """
  delete_priority(
    """filter the rows which have to be deleted"""
    where: priority_bool_exp!
  ): priority_mutation_response

  """
  delete single row from the table: "priority"
  """
  delete_priority_by_pk(
    """Unique identifier for the priority entry."""
    id: Int!
  ): priority

  """
  delete data from the table: "program"
  """
  delete_program(
    """filter the rows which have to be deleted"""
    where: program_bool_exp!
  ): program_mutation_response

  """
  delete single row from the table: "program"
  """
  delete_program_by_pk(
    """L'identifiant unique de la mention."""
    id: Int!
  ): program

  """
  delete data from the table: "request"
  """
  delete_request(
    """filter the rows which have to be deleted"""
    where: request_bool_exp!
  ): request_mutation_response

  """
  delete single row from the table: "request"
  """
  delete_request_by_pk(id: Int!): request

  """
  delete data from the table: "request_type"
  """
  delete_request_type(
    """filter the rows which have to be deleted"""
    where: request_type_bool_exp!
  ): request_type_mutation_response

  """
  delete single row from the table: "request_type"
  """
  delete_request_type_by_pk(
    """Le type de demande (unique)."""
    value: String!
  ): request_type

  """
  delete data from the table: "service"
  """
  delete_service(
    """filter the rows which have to be deleted"""
    where: service_bool_exp!
  ): service_mutation_response

  """
  delete single row from the table: "service"
  """
  delete_service_by_pk(
    """L'identifiant unique du service."""
    id: Int!
  ): service

  """
  delete data from the table: "service_modification"
  """
  delete_service_modification(
    """filter the rows which have to be deleted"""
    where: service_modification_bool_exp!
  ): service_modification_mutation_response

  """
  delete single row from the table: "service_modification"
  """
  delete_service_modification_by_pk(
    """Unique identifier for the modification."""
    id: Int!
  ): service_modification

  """
  delete data from the table: "service_modification_type"
  """
  delete_service_modification_type(
    """filter the rows which have to be deleted"""
    where: service_modification_type_bool_exp!
  ): service_modification_type_mutation_response

  """
  delete single row from the table: "service_modification_type"
  """
  delete_service_modification_type_by_pk(
    """Modification type (unique)."""
    value: String!
  ): service_modification_type

  """
  delete data from the table: "teacher"
  """
  delete_teacher(
    """filter the rows which have to be deleted"""
    where: teacher_bool_exp!
  ): teacher_mutation_response

  """
  delete single row from the table: "teacher"
  """
  delete_teacher_by_pk(
    """L'identifiant unique de l'intervenant."""
    uid: String!
  ): teacher

  """
  delete data from the table: "track"
  """
  delete_track(
    """filter the rows which have to be deleted"""
    where: track_bool_exp!
  ): track_mutation_response

  """
  delete single row from the table: "track"
  """
  delete_track_by_pk(
    """L'identifiant unique du parcours."""
    id: Int!
  ): track

  """
  delete data from the table: "year"
  """
  delete_year(
    """filter the rows which have to be deleted"""
    where: year_bool_exp!
  ): year_mutation_response

  """
  delete single row from the table: "year"
  """
  delete_year_by_pk(
    """Le numéro de l'année (unique)."""
    value: Int!
  ): year

  """
  insert data into the table: "coordinator"
  """
  insert_coordinator(
    """the rows to be inserted"""
    objects: [coordinator_insert_input!]!

    """upsert condition"""
    on_conflict: coordinator_on_conflict
  ): coordinator_mutation_response

  """
  insert a single row into the table: "coordinator"
  """
  insert_coordinator_one(
    """the row to be inserted"""
    object: coordinator_insert_input!

    """upsert condition"""
    on_conflict: coordinator_on_conflict
  ): coordinator

  """
  insert data into the table: "course"
  """
  insert_course(
    """the rows to be inserted"""
    objects: [course_insert_input!]!

    """upsert condition"""
    on_conflict: course_on_conflict
  ): course_mutation_response

  """
  insert a single row into the table: "course"
  """
  insert_course_one(
    """the row to be inserted"""
    object: course_insert_input!

    """upsert condition"""
    on_conflict: course_on_conflict
  ): course

  """
  insert data into the table: "course_type"
  """
  insert_course_type(
    """the rows to be inserted"""
    objects: [course_type_insert_input!]!

    """upsert condition"""
    on_conflict: course_type_on_conflict
  ): course_type_mutation_response

  """
  insert a single row into the table: "course_type"
  """
  insert_course_type_one(
    """the row to be inserted"""
    object: course_type_insert_input!

    """upsert condition"""
    on_conflict: course_type_on_conflict
  ): course_type

  """
  insert data into the table: "degree"
  """
  insert_degree(
    """the rows to be inserted"""
    objects: [degree_insert_input!]!

    """upsert condition"""
    on_conflict: degree_on_conflict
  ): degree_mutation_response

  """
  insert a single row into the table: "degree"
  """
  insert_degree_one(
    """the row to be inserted"""
    object: degree_insert_input!

    """upsert condition"""
    on_conflict: degree_on_conflict
  ): degree

  """
  insert data into the table: "phase"
  """
  insert_phase(
    """the rows to be inserted"""
    objects: [phase_insert_input!]!

    """upsert condition"""
    on_conflict: phase_on_conflict
  ): phase_mutation_response

  """
  insert a single row into the table: "phase"
  """
  insert_phase_one(
    """the row to be inserted"""
    object: phase_insert_input!

    """upsert condition"""
    on_conflict: phase_on_conflict
  ): phase

  """
  insert data into the table: "position"
  """
  insert_position(
    """the rows to be inserted"""
    objects: [position_insert_input!]!

    """upsert condition"""
    on_conflict: position_on_conflict
  ): position_mutation_response

  """
  insert a single row into the table: "position"
  """
  insert_position_one(
    """the row to be inserted"""
    object: position_insert_input!

    """upsert condition"""
    on_conflict: position_on_conflict
  ): position

  """
  insert data into the table: "priority"
  """
  insert_priority(
    """the rows to be inserted"""
    objects: [priority_insert_input!]!

    """upsert condition"""
    on_conflict: priority_on_conflict
  ): priority_mutation_response

  """
  insert a single row into the table: "priority"
  """
  insert_priority_one(
    """the row to be inserted"""
    object: priority_insert_input!

    """upsert condition"""
    on_conflict: priority_on_conflict
  ): priority

  """
  insert data into the table: "program"
  """
  insert_program(
    """the rows to be inserted"""
    objects: [program_insert_input!]!

    """upsert condition"""
    on_conflict: program_on_conflict
  ): program_mutation_response

  """
  insert a single row into the table: "program"
  """
  insert_program_one(
    """the row to be inserted"""
    object: program_insert_input!

    """upsert condition"""
    on_conflict: program_on_conflict
  ): program

  """
  insert data into the table: "request"
  """
  insert_request(
    """the rows to be inserted"""
    objects: [request_insert_input!]!

    """upsert condition"""
    on_conflict: request_on_conflict
  ): request_mutation_response

  """
  insert a single row into the table: "request"
  """
  insert_request_one(
    """the row to be inserted"""
    object: request_insert_input!

    """upsert condition"""
    on_conflict: request_on_conflict
  ): request

  """
  insert data into the table: "request_type"
  """
  insert_request_type(
    """the rows to be inserted"""
    objects: [request_type_insert_input!]!

    """upsert condition"""
    on_conflict: request_type_on_conflict
  ): request_type_mutation_response

  """
  insert a single row into the table: "request_type"
  """
  insert_request_type_one(
    """the row to be inserted"""
    object: request_type_insert_input!

    """upsert condition"""
    on_conflict: request_type_on_conflict
  ): request_type

  """
  insert data into the table: "service"
  """
  insert_service(
    """the rows to be inserted"""
    objects: [service_insert_input!]!

    """upsert condition"""
    on_conflict: service_on_conflict
  ): service_mutation_response

  """
  insert data into the table: "service_modification"
  """
  insert_service_modification(
    """the rows to be inserted"""
    objects: [service_modification_insert_input!]!

    """upsert condition"""
    on_conflict: service_modification_on_conflict
  ): service_modification_mutation_response

  """
  insert a single row into the table: "service_modification"
  """
  insert_service_modification_one(
    """the row to be inserted"""
    object: service_modification_insert_input!

    """upsert condition"""
    on_conflict: service_modification_on_conflict
  ): service_modification

  """
  insert data into the table: "service_modification_type"
  """
  insert_service_modification_type(
    """the rows to be inserted"""
    objects: [service_modification_type_insert_input!]!

    """upsert condition"""
    on_conflict: service_modification_type_on_conflict
  ): service_modification_type_mutation_response

  """
  insert a single row into the table: "service_modification_type"
  """
  insert_service_modification_type_one(
    """the row to be inserted"""
    object: service_modification_type_insert_input!

    """upsert condition"""
    on_conflict: service_modification_type_on_conflict
  ): service_modification_type

  """
  insert a single row into the table: "service"
  """
  insert_service_one(
    """the row to be inserted"""
    object: service_insert_input!

    """upsert condition"""
    on_conflict: service_on_conflict
  ): service

  """
  insert data into the table: "teacher"
  """
  insert_teacher(
    """the rows to be inserted"""
    objects: [teacher_insert_input!]!

    """upsert condition"""
    on_conflict: teacher_on_conflict
  ): teacher_mutation_response

  """
  insert a single row into the table: "teacher"
  """
  insert_teacher_one(
    """the row to be inserted"""
    object: teacher_insert_input!

    """upsert condition"""
    on_conflict: teacher_on_conflict
  ): teacher

  """
  insert data into the table: "track"
  """
  insert_track(
    """the rows to be inserted"""
    objects: [track_insert_input!]!

    """upsert condition"""
    on_conflict: track_on_conflict
  ): track_mutation_response

  """
  insert a single row into the table: "track"
  """
  insert_track_one(
    """the row to be inserted"""
    object: track_insert_input!

    """upsert condition"""
    on_conflict: track_on_conflict
  ): track

  """
  insert data into the table: "year"
  """
  insert_year(
    """the rows to be inserted"""
    objects: [year_insert_input!]!

    """upsert condition"""
    on_conflict: year_on_conflict
  ): year_mutation_response

  """
  insert a single row into the table: "year"
  """
  insert_year_one(
    """the row to be inserted"""
    object: year_insert_input!

    """upsert condition"""
    on_conflict: year_on_conflict
  ): year

  """
  update data of the table: "coordinator"
  """
  update_coordinator(
    """increments the numeric columns with given value of the filtered values"""
    _inc: coordinator_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: coordinator_set_input

    """filter the rows which have to be updated"""
    where: coordinator_bool_exp!
  ): coordinator_mutation_response

  """
  update single row of the table: "coordinator"
  """
  update_coordinator_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: coordinator_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: coordinator_set_input
    pk_columns: coordinator_pk_columns_input!
  ): coordinator

  """
  update multiples rows of table: "coordinator"
  """
  update_coordinator_many(
    """updates to execute, in order"""
    updates: [coordinator_updates!]!
  ): [coordinator_mutation_response]

  """
  update data of the table: "course"
  """
  update_course(
    """increments the numeric columns with given value of the filtered values"""
    _inc: course_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: course_set_input

    """filter the rows which have to be updated"""
    where: course_bool_exp!
  ): course_mutation_response

  """
  update single row of the table: "course"
  """
  update_course_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: course_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: course_set_input
    pk_columns: course_pk_columns_input!
  ): course

  """
  update multiples rows of table: "course"
  """
  update_course_many(
    """updates to execute, in order"""
    updates: [course_updates!]!
  ): [course_mutation_response]

  """
  update data of the table: "course_type"
  """
  update_course_type(
    """increments the numeric columns with given value of the filtered values"""
    _inc: course_type_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: course_type_set_input

    """filter the rows which have to be updated"""
    where: course_type_bool_exp!
  ): course_type_mutation_response

  """
  update single row of the table: "course_type"
  """
  update_course_type_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: course_type_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: course_type_set_input
    pk_columns: course_type_pk_columns_input!
  ): course_type

  """
  update multiples rows of table: "course_type"
  """
  update_course_type_many(
    """updates to execute, in order"""
    updates: [course_type_updates!]!
  ): [course_type_mutation_response]

  """
  update data of the table: "degree"
  """
  update_degree(
    """increments the numeric columns with given value of the filtered values"""
    _inc: degree_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: degree_set_input

    """filter the rows which have to be updated"""
    where: degree_bool_exp!
  ): degree_mutation_response

  """
  update single row of the table: "degree"
  """
  update_degree_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: degree_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: degree_set_input
    pk_columns: degree_pk_columns_input!
  ): degree

  """
  update multiples rows of table: "degree"
  """
  update_degree_many(
    """updates to execute, in order"""
    updates: [degree_updates!]!
  ): [degree_mutation_response]

  """
  update data of the table: "phase"
  """
  update_phase(
    """sets the columns of the filtered rows to the given values"""
    _set: phase_set_input

    """filter the rows which have to be updated"""
    where: phase_bool_exp!
  ): phase_mutation_response

  """
  update single row of the table: "phase"
  """
  update_phase_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: phase_set_input
    pk_columns: phase_pk_columns_input!
  ): phase

  """
  update multiples rows of table: "phase"
  """
  update_phase_many(
    """updates to execute, in order"""
    updates: [phase_updates!]!
  ): [phase_mutation_response]

  """
  update data of the table: "position"
  """
  update_position(
    """increments the numeric columns with given value of the filtered values"""
    _inc: position_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: position_set_input

    """filter the rows which have to be updated"""
    where: position_bool_exp!
  ): position_mutation_response

  """
  update single row of the table: "position"
  """
  update_position_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: position_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: position_set_input
    pk_columns: position_pk_columns_input!
  ): position

  """
  update multiples rows of table: "position"
  """
  update_position_many(
    """updates to execute, in order"""
    updates: [position_updates!]!
  ): [position_mutation_response]

  """
  update data of the table: "priority"
  """
  update_priority(
    """increments the numeric columns with given value of the filtered values"""
    _inc: priority_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: priority_set_input

    """filter the rows which have to be updated"""
    where: priority_bool_exp!
  ): priority_mutation_response

  """
  update single row of the table: "priority"
  """
  update_priority_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: priority_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: priority_set_input
    pk_columns: priority_pk_columns_input!
  ): priority

  """
  update multiples rows of table: "priority"
  """
  update_priority_many(
    """updates to execute, in order"""
    updates: [priority_updates!]!
  ): [priority_mutation_response]

  """
  update data of the table: "program"
  """
  update_program(
    """increments the numeric columns with given value of the filtered values"""
    _inc: program_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: program_set_input

    """filter the rows which have to be updated"""
    where: program_bool_exp!
  ): program_mutation_response

  """
  update single row of the table: "program"
  """
  update_program_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: program_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: program_set_input
    pk_columns: program_pk_columns_input!
  ): program

  """
  update multiples rows of table: "program"
  """
  update_program_many(
    """updates to execute, in order"""
    updates: [program_updates!]!
  ): [program_mutation_response]

  """
  update data of the table: "request"
  """
  update_request(
    """increments the numeric columns with given value of the filtered values"""
    _inc: request_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: request_set_input

    """filter the rows which have to be updated"""
    where: request_bool_exp!
  ): request_mutation_response

  """
  update single row of the table: "request"
  """
  update_request_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: request_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: request_set_input
    pk_columns: request_pk_columns_input!
  ): request

  """
  update multiples rows of table: "request"
  """
  update_request_many(
    """updates to execute, in order"""
    updates: [request_updates!]!
  ): [request_mutation_response]

  """
  update data of the table: "request_type"
  """
  update_request_type(
    """sets the columns of the filtered rows to the given values"""
    _set: request_type_set_input

    """filter the rows which have to be updated"""
    where: request_type_bool_exp!
  ): request_type_mutation_response

  """
  update single row of the table: "request_type"
  """
  update_request_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: request_type_set_input
    pk_columns: request_type_pk_columns_input!
  ): request_type

  """
  update multiples rows of table: "request_type"
  """
  update_request_type_many(
    """updates to execute, in order"""
    updates: [request_type_updates!]!
  ): [request_type_mutation_response]

  """
  update data of the table: "service"
  """
  update_service(
    """increments the numeric columns with given value of the filtered values"""
    _inc: service_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: service_set_input

    """filter the rows which have to be updated"""
    where: service_bool_exp!
  ): service_mutation_response

  """
  update single row of the table: "service"
  """
  update_service_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: service_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: service_set_input
    pk_columns: service_pk_columns_input!
  ): service

  """
  update multiples rows of table: "service"
  """
  update_service_many(
    """updates to execute, in order"""
    updates: [service_updates!]!
  ): [service_mutation_response]

  """
  update data of the table: "service_modification"
  """
  update_service_modification(
    """increments the numeric columns with given value of the filtered values"""
    _inc: service_modification_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: service_modification_set_input

    """filter the rows which have to be updated"""
    where: service_modification_bool_exp!
  ): service_modification_mutation_response

  """
  update single row of the table: "service_modification"
  """
  update_service_modification_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: service_modification_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: service_modification_set_input
    pk_columns: service_modification_pk_columns_input!
  ): service_modification

  """
  update multiples rows of table: "service_modification"
  """
  update_service_modification_many(
    """updates to execute, in order"""
    updates: [service_modification_updates!]!
  ): [service_modification_mutation_response]

  """
  update data of the table: "service_modification_type"
  """
  update_service_modification_type(
    """sets the columns of the filtered rows to the given values"""
    _set: service_modification_type_set_input

    """filter the rows which have to be updated"""
    where: service_modification_type_bool_exp!
  ): service_modification_type_mutation_response

  """
  update single row of the table: "service_modification_type"
  """
  update_service_modification_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: service_modification_type_set_input
    pk_columns: service_modification_type_pk_columns_input!
  ): service_modification_type

  """
  update multiples rows of table: "service_modification_type"
  """
  update_service_modification_type_many(
    """updates to execute, in order"""
    updates: [service_modification_type_updates!]!
  ): [service_modification_type_mutation_response]

  """
  update data of the table: "teacher"
  """
  update_teacher(
    """increments the numeric columns with given value of the filtered values"""
    _inc: teacher_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: teacher_set_input

    """filter the rows which have to be updated"""
    where: teacher_bool_exp!
  ): teacher_mutation_response

  """
  update single row of the table: "teacher"
  """
  update_teacher_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: teacher_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: teacher_set_input
    pk_columns: teacher_pk_columns_input!
  ): teacher

  """
  update multiples rows of table: "teacher"
  """
  update_teacher_many(
    """updates to execute, in order"""
    updates: [teacher_updates!]!
  ): [teacher_mutation_response]

  """
  update data of the table: "track"
  """
  update_track(
    """increments the numeric columns with given value of the filtered values"""
    _inc: track_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: track_set_input

    """filter the rows which have to be updated"""
    where: track_bool_exp!
  ): track_mutation_response

  """
  update single row of the table: "track"
  """
  update_track_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: track_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: track_set_input
    pk_columns: track_pk_columns_input!
  ): track

  """
  update multiples rows of table: "track"
  """
  update_track_many(
    """updates to execute, in order"""
    updates: [track_updates!]!
  ): [track_mutation_response]

  """
  update data of the table: "year"
  """
  update_year(
    """increments the numeric columns with given value of the filtered values"""
    _inc: year_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: year_set_input

    """filter the rows which have to be updated"""
    where: year_bool_exp!
  ): year_mutation_response

  """
  update single row of the table: "year"
  """
  update_year_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: year_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: year_set_input
    pk_columns: year_pk_columns_input!
  ): year

  """
  update multiples rows of table: "year"
  """
  update_year_many(
    """updates to execute, in order"""
    updates: [year_updates!]!
  ): [year_mutation_response]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""
Table containing the different phases: requests, assignments, results, and shutdown.
"""
type phase {
  """
  Indicates if this is the current phase (TRUE) or not (NULL). Only one phase can be current at a time.
  """
  current: Boolean

  """Une brève description."""
  description: String

  """Phase identifier."""
  value: String!
}

"""
aggregated selection of "phase"
"""
type phase_aggregate {
  aggregate: phase_aggregate_fields
  nodes: [phase!]!
}

"""
aggregate fields of "phase"
"""
type phase_aggregate_fields {
  count(columns: [phase_select_column!], distinct: Boolean): Int!
  max: phase_max_fields
  min: phase_min_fields
}

"""
Boolean expression to filter rows from the table "phase". All fields are combined with a logical 'AND'.
"""
input phase_bool_exp {
  _and: [phase_bool_exp!]
  _not: phase_bool_exp
  _or: [phase_bool_exp!]
  current: Boolean_comparison_exp
  description: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "phase"
"""
enum phase_constraint {
  """
  unique or primary key constraint on columns "current"
  """
  phase_en_cours_key

  """
  unique or primary key constraint on columns "value"
  """
  phase_pkey
}

"""
input type for inserting data into table "phase"
"""
input phase_insert_input {
  """
  Indicates if this is the current phase (TRUE) or not (NULL). Only one phase can be current at a time.
  """
  current: Boolean

  """Une brève description."""
  description: String

  """Phase identifier."""
  value: String
}

"""aggregate max on columns"""
type phase_max_fields {
  """Une brève description."""
  description: String

  """Phase identifier."""
  value: String
}

"""aggregate min on columns"""
type phase_min_fields {
  """Une brève description."""
  description: String

  """Phase identifier."""
  value: String
}

"""
response of any mutation on the table "phase"
"""
type phase_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [phase!]!
}

"""
on_conflict condition type for table "phase"
"""
input phase_on_conflict {
  constraint: phase_constraint!
  update_columns: [phase_update_column!]! = []
  where: phase_bool_exp
}

"""Ordering options when selecting data from "phase"."""
input phase_order_by {
  current: order_by
  description: order_by
  value: order_by
}

"""primary key columns input for table: phase"""
input phase_pk_columns_input {
  """Phase identifier."""
  value: String!
}

"""
select columns of table "phase"
"""
enum phase_select_column {
  """column name"""
  current

  """column name"""
  description

  """column name"""
  value
}

"""
input type for updating data in table "phase"
"""
input phase_set_input {
  """
  Indicates if this is the current phase (TRUE) or not (NULL). Only one phase can be current at a time.
  """
  current: Boolean

  """Une brève description."""
  description: String

  """Phase identifier."""
  value: String
}

"""
Streaming cursor of the table "phase"
"""
input phase_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: phase_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input phase_stream_cursor_value_input {
  """
  Indicates if this is the current phase (TRUE) or not (NULL). Only one phase can be current at a time.
  """
  current: Boolean

  """Une brève description."""
  description: String

  """Phase identifier."""
  value: String
}

"""
update columns of table "phase"
"""
enum phase_update_column {
  """column name"""
  current

  """column name"""
  description

  """column name"""
  value
}

input phase_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: phase_set_input

  """filter the rows which have to be updated"""
  where: phase_bool_exp!
}

"""
columns and relationships of "position"
"""
type position {
  base_service_hours: Float
  description: String
  label: String!

  """An array relationship"""
  teachers(
    """distinct select on columns"""
    distinct_on: [teacher_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teacher_order_by!]

    """filter the rows returned"""
    where: teacher_bool_exp
  ): [teacher!]!

  """An aggregate relationship"""
  teachers_aggregate(
    """distinct select on columns"""
    distinct_on: [teacher_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teacher_order_by!]

    """filter the rows returned"""
    where: teacher_bool_exp
  ): teacher_aggregate!
  value: String!
}

"""
aggregated selection of "position"
"""
type position_aggregate {
  aggregate: position_aggregate_fields
  nodes: [position!]!
}

"""
aggregate fields of "position"
"""
type position_aggregate_fields {
  avg: position_avg_fields
  count(columns: [position_select_column!], distinct: Boolean): Int!
  max: position_max_fields
  min: position_min_fields
  stddev: position_stddev_fields
  stddev_pop: position_stddev_pop_fields
  stddev_samp: position_stddev_samp_fields
  sum: position_sum_fields
  var_pop: position_var_pop_fields
  var_samp: position_var_samp_fields
  variance: position_variance_fields
}

"""aggregate avg on columns"""
type position_avg_fields {
  base_service_hours: Float
}

"""
Boolean expression to filter rows from the table "position". All fields are combined with a logical 'AND'.
"""
input position_bool_exp {
  _and: [position_bool_exp!]
  _not: position_bool_exp
  _or: [position_bool_exp!]
  base_service_hours: Float_comparison_exp
  description: String_comparison_exp
  label: String_comparison_exp
  teachers: teacher_bool_exp
  teachers_aggregate: teacher_aggregate_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "position"
"""
enum position_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  fonction_pkey
}

"""
input type for incrementing numeric columns in table "position"
"""
input position_inc_input {
  base_service_hours: Float
}

"""
input type for inserting data into table "position"
"""
input position_insert_input {
  base_service_hours: Float
  description: String
  label: String
  teachers: teacher_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type position_max_fields {
  base_service_hours: Float
  description: String
  label: String
  value: String
}

"""aggregate min on columns"""
type position_min_fields {
  base_service_hours: Float
  description: String
  label: String
  value: String
}

"""
response of any mutation on the table "position"
"""
type position_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [position!]!
}

"""
input type for inserting object relation for remote table "position"
"""
input position_obj_rel_insert_input {
  data: position_insert_input!

  """upsert condition"""
  on_conflict: position_on_conflict
}

"""
on_conflict condition type for table "position"
"""
input position_on_conflict {
  constraint: position_constraint!
  update_columns: [position_update_column!]! = []
  where: position_bool_exp
}

"""Ordering options when selecting data from "position"."""
input position_order_by {
  base_service_hours: order_by
  description: order_by
  label: order_by
  teachers_aggregate: teacher_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: position"""
input position_pk_columns_input {
  value: String!
}

"""
select columns of table "position"
"""
enum position_select_column {
  """column name"""
  base_service_hours

  """column name"""
  description

  """column name"""
  label

  """column name"""
  value
}

"""
input type for updating data in table "position"
"""
input position_set_input {
  base_service_hours: Float
  description: String
  label: String
  value: String
}

"""aggregate stddev on columns"""
type position_stddev_fields {
  base_service_hours: Float
}

"""aggregate stddev_pop on columns"""
type position_stddev_pop_fields {
  base_service_hours: Float
}

"""aggregate stddev_samp on columns"""
type position_stddev_samp_fields {
  base_service_hours: Float
}

"""
Streaming cursor of the table "position"
"""
input position_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: position_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input position_stream_cursor_value_input {
  base_service_hours: Float
  description: String
  label: String
  value: String
}

"""aggregate sum on columns"""
type position_sum_fields {
  base_service_hours: Float
}

"""
update columns of table "position"
"""
enum position_update_column {
  """column name"""
  base_service_hours

  """column name"""
  description

  """column name"""
  label

  """column name"""
  value
}

input position_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: position_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: position_set_input

  """filter the rows which have to be updated"""
  where: position_bool_exp!
}

"""aggregate var_pop on columns"""
type position_var_pop_fields {
  base_service_hours: Float
}

"""aggregate var_samp on columns"""
type position_var_samp_fields {
  base_service_hours: Float
}

"""aggregate variance on columns"""
type position_variance_fields {
  base_service_hours: Float
}

"""
Table containing information about teacher seniority and priority for courses.
"""
type priority {
  """An object relationship"""
  course: course!

  """Associated course ID."""
  course_id: Int!

  """Unique identifier for the priority entry."""
  id: Int!

  """Indicates if the teacher has priority for this course."""
  is_priority: Boolean

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: Int

  """An object relationship"""
  service: service!

  """Associated service ID."""
  service_id: Int!
}

"""
aggregated selection of "priority"
"""
type priority_aggregate {
  aggregate: priority_aggregate_fields
  nodes: [priority!]!
}

input priority_aggregate_bool_exp {
  bool_and: priority_aggregate_bool_exp_bool_and
  bool_or: priority_aggregate_bool_exp_bool_or
  count: priority_aggregate_bool_exp_count
}

input priority_aggregate_bool_exp_bool_and {
  arguments: priority_select_column_priority_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: priority_bool_exp
  predicate: Boolean_comparison_exp!
}

input priority_aggregate_bool_exp_bool_or {
  arguments: priority_select_column_priority_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: priority_bool_exp
  predicate: Boolean_comparison_exp!
}

input priority_aggregate_bool_exp_count {
  arguments: [priority_select_column!]
  distinct: Boolean
  filter: priority_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "priority"
"""
type priority_aggregate_fields {
  avg: priority_avg_fields
  count(columns: [priority_select_column!], distinct: Boolean): Int!
  max: priority_max_fields
  min: priority_min_fields
  stddev: priority_stddev_fields
  stddev_pop: priority_stddev_pop_fields
  stddev_samp: priority_stddev_samp_fields
  sum: priority_sum_fields
  var_pop: priority_var_pop_fields
  var_samp: priority_var_samp_fields
  variance: priority_variance_fields
}

"""
order by aggregate values of table "priority"
"""
input priority_aggregate_order_by {
  avg: priority_avg_order_by
  count: order_by
  max: priority_max_order_by
  min: priority_min_order_by
  stddev: priority_stddev_order_by
  stddev_pop: priority_stddev_pop_order_by
  stddev_samp: priority_stddev_samp_order_by
  sum: priority_sum_order_by
  var_pop: priority_var_pop_order_by
  var_samp: priority_var_samp_order_by
  variance: priority_variance_order_by
}

"""
input type for inserting array relation for remote table "priority"
"""
input priority_arr_rel_insert_input {
  data: [priority_insert_input!]!

  """upsert condition"""
  on_conflict: priority_on_conflict
}

"""aggregate avg on columns"""
type priority_avg_fields {
  """Associated course ID."""
  course_id: Float

  """Unique identifier for the priority entry."""
  id: Float

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: Float

  """Associated service ID."""
  service_id: Float
}

"""
order by avg() on columns of table "priority"
"""
input priority_avg_order_by {
  """Associated course ID."""
  course_id: order_by

  """Unique identifier for the priority entry."""
  id: order_by

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: order_by

  """Associated service ID."""
  service_id: order_by
}

"""
Boolean expression to filter rows from the table "priority". All fields are combined with a logical 'AND'.
"""
input priority_bool_exp {
  _and: [priority_bool_exp!]
  _not: priority_bool_exp
  _or: [priority_bool_exp!]
  course: course_bool_exp
  course_id: Int_comparison_exp
  id: Int_comparison_exp
  is_priority: Boolean_comparison_exp
  seniority: Int_comparison_exp
  service: service_bool_exp
  service_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "priority"
"""
enum priority_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  priorite_pkey

  """
  unique or primary key constraint on columns "course_id", "service_id"
  """
  priorite_service_id_ens_id_key
}

"""
input type for incrementing numeric columns in table "priority"
"""
input priority_inc_input {
  """Associated course ID."""
  course_id: Int

  """Unique identifier for the priority entry."""
  id: Int

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: Int

  """Associated service ID."""
  service_id: Int
}

"""
input type for inserting data into table "priority"
"""
input priority_insert_input {
  course: course_obj_rel_insert_input

  """Associated course ID."""
  course_id: Int

  """Unique identifier for the priority entry."""
  id: Int

  """Indicates if the teacher has priority for this course."""
  is_priority: Boolean

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: Int
  service: service_obj_rel_insert_input

  """Associated service ID."""
  service_id: Int
}

"""aggregate max on columns"""
type priority_max_fields {
  """Associated course ID."""
  course_id: Int

  """Unique identifier for the priority entry."""
  id: Int

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: Int

  """Associated service ID."""
  service_id: Int
}

"""
order by max() on columns of table "priority"
"""
input priority_max_order_by {
  """Associated course ID."""
  course_id: order_by

  """Unique identifier for the priority entry."""
  id: order_by

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: order_by

  """Associated service ID."""
  service_id: order_by
}

"""aggregate min on columns"""
type priority_min_fields {
  """Associated course ID."""
  course_id: Int

  """Unique identifier for the priority entry."""
  id: Int

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: Int

  """Associated service ID."""
  service_id: Int
}

"""
order by min() on columns of table "priority"
"""
input priority_min_order_by {
  """Associated course ID."""
  course_id: order_by

  """Unique identifier for the priority entry."""
  id: order_by

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: order_by

  """Associated service ID."""
  service_id: order_by
}

"""
response of any mutation on the table "priority"
"""
type priority_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [priority!]!
}

"""
on_conflict condition type for table "priority"
"""
input priority_on_conflict {
  constraint: priority_constraint!
  update_columns: [priority_update_column!]! = []
  where: priority_bool_exp
}

"""Ordering options when selecting data from "priority"."""
input priority_order_by {
  course: course_order_by
  course_id: order_by
  id: order_by
  is_priority: order_by
  seniority: order_by
  service: service_order_by
  service_id: order_by
}

"""primary key columns input for table: priority"""
input priority_pk_columns_input {
  """Unique identifier for the priority entry."""
  id: Int!
}

"""
select columns of table "priority"
"""
enum priority_select_column {
  """column name"""
  course_id

  """column name"""
  id

  """column name"""
  is_priority

  """column name"""
  seniority

  """column name"""
  service_id
}

"""
select "priority_aggregate_bool_exp_bool_and_arguments_columns" columns of table "priority"
"""
enum priority_select_column_priority_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_priority
}

"""
select "priority_aggregate_bool_exp_bool_or_arguments_columns" columns of table "priority"
"""
enum priority_select_column_priority_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_priority
}

"""
input type for updating data in table "priority"
"""
input priority_set_input {
  """Associated course ID."""
  course_id: Int

  """Unique identifier for the priority entry."""
  id: Int

  """Indicates if the teacher has priority for this course."""
  is_priority: Boolean

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: Int

  """Associated service ID."""
  service_id: Int
}

"""aggregate stddev on columns"""
type priority_stddev_fields {
  """Associated course ID."""
  course_id: Float

  """Unique identifier for the priority entry."""
  id: Float

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: Float

  """Associated service ID."""
  service_id: Float
}

"""
order by stddev() on columns of table "priority"
"""
input priority_stddev_order_by {
  """Associated course ID."""
  course_id: order_by

  """Unique identifier for the priority entry."""
  id: order_by

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: order_by

  """Associated service ID."""
  service_id: order_by
}

"""aggregate stddev_pop on columns"""
type priority_stddev_pop_fields {
  """Associated course ID."""
  course_id: Float

  """Unique identifier for the priority entry."""
  id: Float

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: Float

  """Associated service ID."""
  service_id: Float
}

"""
order by stddev_pop() on columns of table "priority"
"""
input priority_stddev_pop_order_by {
  """Associated course ID."""
  course_id: order_by

  """Unique identifier for the priority entry."""
  id: order_by

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: order_by

  """Associated service ID."""
  service_id: order_by
}

"""aggregate stddev_samp on columns"""
type priority_stddev_samp_fields {
  """Associated course ID."""
  course_id: Float

  """Unique identifier for the priority entry."""
  id: Float

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: Float

  """Associated service ID."""
  service_id: Float
}

"""
order by stddev_samp() on columns of table "priority"
"""
input priority_stddev_samp_order_by {
  """Associated course ID."""
  course_id: order_by

  """Unique identifier for the priority entry."""
  id: order_by

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: order_by

  """Associated service ID."""
  service_id: order_by
}

"""
Streaming cursor of the table "priority"
"""
input priority_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: priority_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input priority_stream_cursor_value_input {
  """Associated course ID."""
  course_id: Int

  """Unique identifier for the priority entry."""
  id: Int

  """Indicates if the teacher has priority for this course."""
  is_priority: Boolean

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: Int

  """Associated service ID."""
  service_id: Int
}

"""aggregate sum on columns"""
type priority_sum_fields {
  """Associated course ID."""
  course_id: Int

  """Unique identifier for the priority entry."""
  id: Int

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: Int

  """Associated service ID."""
  service_id: Int
}

"""
order by sum() on columns of table "priority"
"""
input priority_sum_order_by {
  """Associated course ID."""
  course_id: order_by

  """Unique identifier for the priority entry."""
  id: order_by

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: order_by

  """Associated service ID."""
  service_id: order_by
}

"""
update columns of table "priority"
"""
enum priority_update_column {
  """column name"""
  course_id

  """column name"""
  id

  """column name"""
  is_priority

  """column name"""
  seniority

  """column name"""
  service_id
}

input priority_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: priority_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: priority_set_input

  """filter the rows which have to be updated"""
  where: priority_bool_exp!
}

"""aggregate var_pop on columns"""
type priority_var_pop_fields {
  """Associated course ID."""
  course_id: Float

  """Unique identifier for the priority entry."""
  id: Float

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: Float

  """Associated service ID."""
  service_id: Float
}

"""
order by var_pop() on columns of table "priority"
"""
input priority_var_pop_order_by {
  """Associated course ID."""
  course_id: order_by

  """Unique identifier for the priority entry."""
  id: order_by

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: order_by

  """Associated service ID."""
  service_id: order_by
}

"""aggregate var_samp on columns"""
type priority_var_samp_fields {
  """Associated course ID."""
  course_id: Float

  """Unique identifier for the priority entry."""
  id: Float

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: Float

  """Associated service ID."""
  service_id: Float
}

"""
order by var_samp() on columns of table "priority"
"""
input priority_var_samp_order_by {
  """Associated course ID."""
  course_id: order_by

  """Unique identifier for the priority entry."""
  id: order_by

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: order_by

  """Associated service ID."""
  service_id: order_by
}

"""aggregate variance on columns"""
type priority_variance_fields {
  """Associated course ID."""
  course_id: Float

  """Unique identifier for the priority entry."""
  id: Float

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: Float

  """Associated service ID."""
  service_id: Float
}

"""
order by variance() on columns of table "priority"
"""
input priority_variance_order_by {
  """Associated course ID."""
  course_id: order_by

  """Unique identifier for the priority entry."""
  id: order_by

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: order_by

  """Associated service ID."""
  service_id: order_by
}

"""Table contenant les différentes mentions."""
type program {
  """An array relationship"""
  coordinators(
    """distinct select on columns"""
    distinct_on: [coordinator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coordinator_order_by!]

    """filter the rows returned"""
    where: coordinator_bool_exp
  ): [coordinator!]!

  """An aggregate relationship"""
  coordinators_aggregate(
    """distinct select on columns"""
    distinct_on: [coordinator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coordinator_order_by!]

    """filter the rows returned"""
    where: coordinator_bool_exp
  ): coordinator_aggregate!

  """An array relationship"""
  courses(
    """distinct select on columns"""
    distinct_on: [course_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_order_by!]

    """filter the rows returned"""
    where: course_bool_exp
  ): [course!]!

  """An aggregate relationship"""
  courses_aggregate(
    """distinct select on columns"""
    distinct_on: [course_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_order_by!]

    """filter the rows returned"""
    where: course_bool_exp
  ): course_aggregate!

  """An object relationship"""
  degree: degree!
  degree_id: Int!

  """L'identifiant unique de la mention."""
  id: Int!

  """Le nom de la mention (unique)."""
  name: String!

  """Le nom abrégé (optionnel)."""
  name_short: String
  nom_import: String

  """An array relationship"""
  tracks(
    """distinct select on columns"""
    distinct_on: [track_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [track_order_by!]

    """filter the rows returned"""
    where: track_bool_exp
  ): [track!]!

  """An aggregate relationship"""
  tracks_aggregate(
    """distinct select on columns"""
    distinct_on: [track_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [track_order_by!]

    """filter the rows returned"""
    where: track_bool_exp
  ): track_aggregate!

  """Indique si la mention correspondante est visible par les utilisateurs."""
  visible: Boolean!
}

"""
aggregated selection of "program"
"""
type program_aggregate {
  aggregate: program_aggregate_fields
  nodes: [program!]!
}

input program_aggregate_bool_exp {
  bool_and: program_aggregate_bool_exp_bool_and
  bool_or: program_aggregate_bool_exp_bool_or
  count: program_aggregate_bool_exp_count
}

input program_aggregate_bool_exp_bool_and {
  arguments: program_select_column_program_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: program_bool_exp
  predicate: Boolean_comparison_exp!
}

input program_aggregate_bool_exp_bool_or {
  arguments: program_select_column_program_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: program_bool_exp
  predicate: Boolean_comparison_exp!
}

input program_aggregate_bool_exp_count {
  arguments: [program_select_column!]
  distinct: Boolean
  filter: program_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "program"
"""
type program_aggregate_fields {
  avg: program_avg_fields
  count(columns: [program_select_column!], distinct: Boolean): Int!
  max: program_max_fields
  min: program_min_fields
  stddev: program_stddev_fields
  stddev_pop: program_stddev_pop_fields
  stddev_samp: program_stddev_samp_fields
  sum: program_sum_fields
  var_pop: program_var_pop_fields
  var_samp: program_var_samp_fields
  variance: program_variance_fields
}

"""
order by aggregate values of table "program"
"""
input program_aggregate_order_by {
  avg: program_avg_order_by
  count: order_by
  max: program_max_order_by
  min: program_min_order_by
  stddev: program_stddev_order_by
  stddev_pop: program_stddev_pop_order_by
  stddev_samp: program_stddev_samp_order_by
  sum: program_sum_order_by
  var_pop: program_var_pop_order_by
  var_samp: program_var_samp_order_by
  variance: program_variance_order_by
}

"""
input type for inserting array relation for remote table "program"
"""
input program_arr_rel_insert_input {
  data: [program_insert_input!]!

  """upsert condition"""
  on_conflict: program_on_conflict
}

"""aggregate avg on columns"""
type program_avg_fields {
  degree_id: Float

  """L'identifiant unique de la mention."""
  id: Float
}

"""
order by avg() on columns of table "program"
"""
input program_avg_order_by {
  degree_id: order_by

  """L'identifiant unique de la mention."""
  id: order_by
}

"""
Boolean expression to filter rows from the table "program". All fields are combined with a logical 'AND'.
"""
input program_bool_exp {
  _and: [program_bool_exp!]
  _not: program_bool_exp
  _or: [program_bool_exp!]
  coordinators: coordinator_bool_exp
  coordinators_aggregate: coordinator_aggregate_bool_exp
  courses: course_bool_exp
  courses_aggregate: course_aggregate_bool_exp
  degree: degree_bool_exp
  degree_id: Int_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  name_short: String_comparison_exp
  nom_import: String_comparison_exp
  tracks: track_bool_exp
  tracks_aggregate: track_aggregate_bool_exp
  visible: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "program"
"""
enum program_constraint {
  """
  unique or primary key constraint on columns "degree_id", "name"
  """
  mention_cursus_id_nom_key

  """
  unique or primary key constraint on columns "id"
  """
  mention_pkey
}

"""
input type for incrementing numeric columns in table "program"
"""
input program_inc_input {
  degree_id: Int

  """L'identifiant unique de la mention."""
  id: Int
}

"""
input type for inserting data into table "program"
"""
input program_insert_input {
  coordinators: coordinator_arr_rel_insert_input
  courses: course_arr_rel_insert_input
  degree: degree_obj_rel_insert_input
  degree_id: Int

  """L'identifiant unique de la mention."""
  id: Int

  """Le nom de la mention (unique)."""
  name: String

  """Le nom abrégé (optionnel)."""
  name_short: String
  nom_import: String
  tracks: track_arr_rel_insert_input

  """Indique si la mention correspondante est visible par les utilisateurs."""
  visible: Boolean
}

"""aggregate max on columns"""
type program_max_fields {
  degree_id: Int

  """L'identifiant unique de la mention."""
  id: Int

  """Le nom de la mention (unique)."""
  name: String

  """Le nom abrégé (optionnel)."""
  name_short: String
  nom_import: String
}

"""
order by max() on columns of table "program"
"""
input program_max_order_by {
  degree_id: order_by

  """L'identifiant unique de la mention."""
  id: order_by

  """Le nom de la mention (unique)."""
  name: order_by

  """Le nom abrégé (optionnel)."""
  name_short: order_by
  nom_import: order_by
}

"""aggregate min on columns"""
type program_min_fields {
  degree_id: Int

  """L'identifiant unique de la mention."""
  id: Int

  """Le nom de la mention (unique)."""
  name: String

  """Le nom abrégé (optionnel)."""
  name_short: String
  nom_import: String
}

"""
order by min() on columns of table "program"
"""
input program_min_order_by {
  degree_id: order_by

  """L'identifiant unique de la mention."""
  id: order_by

  """Le nom de la mention (unique)."""
  name: order_by

  """Le nom abrégé (optionnel)."""
  name_short: order_by
  nom_import: order_by
}

"""
response of any mutation on the table "program"
"""
type program_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [program!]!
}

"""
input type for inserting object relation for remote table "program"
"""
input program_obj_rel_insert_input {
  data: program_insert_input!

  """upsert condition"""
  on_conflict: program_on_conflict
}

"""
on_conflict condition type for table "program"
"""
input program_on_conflict {
  constraint: program_constraint!
  update_columns: [program_update_column!]! = []
  where: program_bool_exp
}

"""Ordering options when selecting data from "program"."""
input program_order_by {
  coordinators_aggregate: coordinator_aggregate_order_by
  courses_aggregate: course_aggregate_order_by
  degree: degree_order_by
  degree_id: order_by
  id: order_by
  name: order_by
  name_short: order_by
  nom_import: order_by
  tracks_aggregate: track_aggregate_order_by
  visible: order_by
}

"""primary key columns input for table: program"""
input program_pk_columns_input {
  """L'identifiant unique de la mention."""
  id: Int!
}

"""
select columns of table "program"
"""
enum program_select_column {
  """column name"""
  degree_id

  """column name"""
  id

  """column name"""
  name

  """column name"""
  name_short

  """column name"""
  nom_import

  """column name"""
  visible
}

"""
select "program_aggregate_bool_exp_bool_and_arguments_columns" columns of table "program"
"""
enum program_select_column_program_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  visible
}

"""
select "program_aggregate_bool_exp_bool_or_arguments_columns" columns of table "program"
"""
enum program_select_column_program_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  visible
}

"""
input type for updating data in table "program"
"""
input program_set_input {
  degree_id: Int

  """L'identifiant unique de la mention."""
  id: Int

  """Le nom de la mention (unique)."""
  name: String

  """Le nom abrégé (optionnel)."""
  name_short: String
  nom_import: String

  """Indique si la mention correspondante est visible par les utilisateurs."""
  visible: Boolean
}

"""aggregate stddev on columns"""
type program_stddev_fields {
  degree_id: Float

  """L'identifiant unique de la mention."""
  id: Float
}

"""
order by stddev() on columns of table "program"
"""
input program_stddev_order_by {
  degree_id: order_by

  """L'identifiant unique de la mention."""
  id: order_by
}

"""aggregate stddev_pop on columns"""
type program_stddev_pop_fields {
  degree_id: Float

  """L'identifiant unique de la mention."""
  id: Float
}

"""
order by stddev_pop() on columns of table "program"
"""
input program_stddev_pop_order_by {
  degree_id: order_by

  """L'identifiant unique de la mention."""
  id: order_by
}

"""aggregate stddev_samp on columns"""
type program_stddev_samp_fields {
  degree_id: Float

  """L'identifiant unique de la mention."""
  id: Float
}

"""
order by stddev_samp() on columns of table "program"
"""
input program_stddev_samp_order_by {
  degree_id: order_by

  """L'identifiant unique de la mention."""
  id: order_by
}

"""
Streaming cursor of the table "program"
"""
input program_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: program_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input program_stream_cursor_value_input {
  degree_id: Int

  """L'identifiant unique de la mention."""
  id: Int

  """Le nom de la mention (unique)."""
  name: String

  """Le nom abrégé (optionnel)."""
  name_short: String
  nom_import: String

  """Indique si la mention correspondante est visible par les utilisateurs."""
  visible: Boolean
}

"""aggregate sum on columns"""
type program_sum_fields {
  degree_id: Int

  """L'identifiant unique de la mention."""
  id: Int
}

"""
order by sum() on columns of table "program"
"""
input program_sum_order_by {
  degree_id: order_by

  """L'identifiant unique de la mention."""
  id: order_by
}

"""
update columns of table "program"
"""
enum program_update_column {
  """column name"""
  degree_id

  """column name"""
  id

  """column name"""
  name

  """column name"""
  name_short

  """column name"""
  nom_import

  """column name"""
  visible
}

input program_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: program_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: program_set_input

  """filter the rows which have to be updated"""
  where: program_bool_exp!
}

"""aggregate var_pop on columns"""
type program_var_pop_fields {
  degree_id: Float

  """L'identifiant unique de la mention."""
  id: Float
}

"""
order by var_pop() on columns of table "program"
"""
input program_var_pop_order_by {
  degree_id: order_by

  """L'identifiant unique de la mention."""
  id: order_by
}

"""aggregate var_samp on columns"""
type program_var_samp_fields {
  degree_id: Float

  """L'identifiant unique de la mention."""
  id: Float
}

"""
order by var_samp() on columns of table "program"
"""
input program_var_samp_order_by {
  degree_id: order_by

  """L'identifiant unique de la mention."""
  id: order_by
}

"""aggregate variance on columns"""
type program_variance_fields {
  degree_id: Float

  """L'identifiant unique de la mention."""
  id: Float
}

"""
order by variance() on columns of table "program"
"""
input program_variance_order_by {
  degree_id: order_by

  """L'identifiant unique de la mention."""
  id: order_by
}

type query_root {
  """
  fetch data from the table: "coordinator"
  """
  coordinator(
    """distinct select on columns"""
    distinct_on: [coordinator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coordinator_order_by!]

    """filter the rows returned"""
    where: coordinator_bool_exp
  ): [coordinator!]!

  """
  fetch aggregated fields from the table: "coordinator"
  """
  coordinator_aggregate(
    """distinct select on columns"""
    distinct_on: [coordinator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coordinator_order_by!]

    """filter the rows returned"""
    where: coordinator_bool_exp
  ): coordinator_aggregate!

  """fetch data from the table: "coordinator" using primary key columns"""
  coordinator_by_pk(
    """Unique identifier for the coordinator entry."""
    id: Int!
  ): coordinator

  """
  fetch data from the table: "course"
  """
  course(
    """distinct select on columns"""
    distinct_on: [course_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_order_by!]

    """filter the rows returned"""
    where: course_bool_exp
  ): [course!]!

  """
  fetch aggregated fields from the table: "course"
  """
  course_aggregate(
    """distinct select on columns"""
    distinct_on: [course_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_order_by!]

    """filter the rows returned"""
    where: course_bool_exp
  ): course_aggregate!

  """fetch data from the table: "course" using primary key columns"""
  course_by_pk(
    """L'identifiant unique de l'enseignement."""
    id: Int!
  ): course

  """
  fetch data from the table: "course_type"
  """
  course_type(
    """distinct select on columns"""
    distinct_on: [course_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_type_order_by!]

    """filter the rows returned"""
    where: course_type_bool_exp
  ): [course_type!]!

  """
  fetch aggregated fields from the table: "course_type"
  """
  course_type_aggregate(
    """distinct select on columns"""
    distinct_on: [course_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_type_order_by!]

    """filter the rows returned"""
    where: course_type_bool_exp
  ): course_type_aggregate!

  """fetch data from the table: "course_type" using primary key columns"""
  course_type_by_pk(
    """La clé du type d'enseignement (unique)."""
    value: String!
  ): course_type

  """
  fetch data from the table: "degree"
  """
  degree(
    """distinct select on columns"""
    distinct_on: [degree_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [degree_order_by!]

    """filter the rows returned"""
    where: degree_bool_exp
  ): [degree!]!

  """
  fetch aggregated fields from the table: "degree"
  """
  degree_aggregate(
    """distinct select on columns"""
    distinct_on: [degree_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [degree_order_by!]

    """filter the rows returned"""
    where: degree_bool_exp
  ): degree_aggregate!

  """fetch data from the table: "degree" using primary key columns"""
  degree_by_pk(
    """L'identifiant unique du cursus."""
    id: Int!
  ): degree

  """
  fetch data from the table: "phase"
  """
  phase(
    """distinct select on columns"""
    distinct_on: [phase_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [phase_order_by!]

    """filter the rows returned"""
    where: phase_bool_exp
  ): [phase!]!

  """
  fetch aggregated fields from the table: "phase"
  """
  phase_aggregate(
    """distinct select on columns"""
    distinct_on: [phase_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [phase_order_by!]

    """filter the rows returned"""
    where: phase_bool_exp
  ): phase_aggregate!

  """fetch data from the table: "phase" using primary key columns"""
  phase_by_pk(
    """Phase identifier."""
    value: String!
  ): phase

  """
  fetch data from the table: "position"
  """
  position(
    """distinct select on columns"""
    distinct_on: [position_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [position_order_by!]

    """filter the rows returned"""
    where: position_bool_exp
  ): [position!]!

  """
  fetch aggregated fields from the table: "position"
  """
  position_aggregate(
    """distinct select on columns"""
    distinct_on: [position_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [position_order_by!]

    """filter the rows returned"""
    where: position_bool_exp
  ): position_aggregate!

  """fetch data from the table: "position" using primary key columns"""
  position_by_pk(value: String!): position

  """
  fetch data from the table: "priority"
  """
  priority(
    """distinct select on columns"""
    distinct_on: [priority_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [priority_order_by!]

    """filter the rows returned"""
    where: priority_bool_exp
  ): [priority!]!

  """
  fetch aggregated fields from the table: "priority"
  """
  priority_aggregate(
    """distinct select on columns"""
    distinct_on: [priority_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [priority_order_by!]

    """filter the rows returned"""
    where: priority_bool_exp
  ): priority_aggregate!

  """fetch data from the table: "priority" using primary key columns"""
  priority_by_pk(
    """Unique identifier for the priority entry."""
    id: Int!
  ): priority

  """
  fetch data from the table: "program"
  """
  program(
    """distinct select on columns"""
    distinct_on: [program_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [program_order_by!]

    """filter the rows returned"""
    where: program_bool_exp
  ): [program!]!

  """
  fetch aggregated fields from the table: "program"
  """
  program_aggregate(
    """distinct select on columns"""
    distinct_on: [program_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [program_order_by!]

    """filter the rows returned"""
    where: program_bool_exp
  ): program_aggregate!

  """fetch data from the table: "program" using primary key columns"""
  program_by_pk(
    """L'identifiant unique de la mention."""
    id: Int!
  ): program

  """
  fetch data from the table: "request"
  """
  request(
    """distinct select on columns"""
    distinct_on: [request_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [request_order_by!]

    """filter the rows returned"""
    where: request_bool_exp
  ): [request!]!

  """
  fetch aggregated fields from the table: "request"
  """
  request_aggregate(
    """distinct select on columns"""
    distinct_on: [request_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [request_order_by!]

    """filter the rows returned"""
    where: request_bool_exp
  ): request_aggregate!

  """fetch data from the table: "request" using primary key columns"""
  request_by_pk(id: Int!): request

  """
  fetch data from the table: "request_type"
  """
  request_type(
    """distinct select on columns"""
    distinct_on: [request_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [request_type_order_by!]

    """filter the rows returned"""
    where: request_type_bool_exp
  ): [request_type!]!

  """
  fetch aggregated fields from the table: "request_type"
  """
  request_type_aggregate(
    """distinct select on columns"""
    distinct_on: [request_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [request_type_order_by!]

    """filter the rows returned"""
    where: request_type_bool_exp
  ): request_type_aggregate!

  """fetch data from the table: "request_type" using primary key columns"""
  request_type_by_pk(
    """Le type de demande (unique)."""
    value: String!
  ): request_type

  """
  fetch data from the table: "service"
  """
  service(
    """distinct select on columns"""
    distinct_on: [service_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_order_by!]

    """filter the rows returned"""
    where: service_bool_exp
  ): [service!]!

  """
  fetch aggregated fields from the table: "service"
  """
  service_aggregate(
    """distinct select on columns"""
    distinct_on: [service_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_order_by!]

    """filter the rows returned"""
    where: service_bool_exp
  ): service_aggregate!

  """fetch data from the table: "service" using primary key columns"""
  service_by_pk(
    """L'identifiant unique du service."""
    id: Int!
  ): service

  """
  fetch data from the table: "service_modification"
  """
  service_modification(
    """distinct select on columns"""
    distinct_on: [service_modification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_modification_order_by!]

    """filter the rows returned"""
    where: service_modification_bool_exp
  ): [service_modification!]!

  """
  fetch aggregated fields from the table: "service_modification"
  """
  service_modification_aggregate(
    """distinct select on columns"""
    distinct_on: [service_modification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_modification_order_by!]

    """filter the rows returned"""
    where: service_modification_bool_exp
  ): service_modification_aggregate!

  """
  fetch data from the table: "service_modification" using primary key columns
  """
  service_modification_by_pk(
    """Unique identifier for the modification."""
    id: Int!
  ): service_modification

  """
  fetch data from the table: "service_modification_type"
  """
  service_modification_type(
    """distinct select on columns"""
    distinct_on: [service_modification_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_modification_type_order_by!]

    """filter the rows returned"""
    where: service_modification_type_bool_exp
  ): [service_modification_type!]!

  """
  fetch aggregated fields from the table: "service_modification_type"
  """
  service_modification_type_aggregate(
    """distinct select on columns"""
    distinct_on: [service_modification_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_modification_type_order_by!]

    """filter the rows returned"""
    where: service_modification_type_bool_exp
  ): service_modification_type_aggregate!

  """
  fetch data from the table: "service_modification_type" using primary key columns
  """
  service_modification_type_by_pk(
    """Modification type (unique)."""
    value: String!
  ): service_modification_type

  """
  fetch data from the table: "teacher"
  """
  teacher(
    """distinct select on columns"""
    distinct_on: [teacher_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teacher_order_by!]

    """filter the rows returned"""
    where: teacher_bool_exp
  ): [teacher!]!

  """
  fetch aggregated fields from the table: "teacher"
  """
  teacher_aggregate(
    """distinct select on columns"""
    distinct_on: [teacher_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teacher_order_by!]

    """filter the rows returned"""
    where: teacher_bool_exp
  ): teacher_aggregate!

  """fetch data from the table: "teacher" using primary key columns"""
  teacher_by_pk(
    """L'identifiant unique de l'intervenant."""
    uid: String!
  ): teacher

  """
  fetch data from the table: "track"
  """
  track(
    """distinct select on columns"""
    distinct_on: [track_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [track_order_by!]

    """filter the rows returned"""
    where: track_bool_exp
  ): [track!]!

  """
  fetch aggregated fields from the table: "track"
  """
  track_aggregate(
    """distinct select on columns"""
    distinct_on: [track_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [track_order_by!]

    """filter the rows returned"""
    where: track_bool_exp
  ): track_aggregate!

  """fetch data from the table: "track" using primary key columns"""
  track_by_pk(
    """L'identifiant unique du parcours."""
    id: Int!
  ): track

  """
  fetch data from the table: "year"
  """
  year(
    """distinct select on columns"""
    distinct_on: [year_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [year_order_by!]

    """filter the rows returned"""
    where: year_bool_exp
  ): [year!]!

  """
  fetch aggregated fields from the table: "year"
  """
  year_aggregate(
    """distinct select on columns"""
    distinct_on: [year_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [year_order_by!]

    """filter the rows returned"""
    where: year_bool_exp
  ): year_aggregate!

  """fetch data from the table: "year" using primary key columns"""
  year_by_pk(
    """Le numéro de l'année (unique)."""
    value: Int!
  ): year
}

"""Table contenant les demandes."""
type request {
  """An object relationship"""
  course: course!

  """L'identifiant de l'enseignement correspondant à la demande."""
  course_id: Int!
  created_at: timestamptz!

  """Le nombre d'heures demandées."""
  hours: Float!

  """
  A computed field, executes function "hours_weighted"
  """
  hours_weighted: Float
  id: Int!

  """
  A computed field, executes function "is_priority"
  """
  is_priority: Boolean

  """An object relationship"""
  service: service!
  service_id: Int!

  """Le type de demande."""
  type: String!

  """An object relationship"""
  typeByType: request_type!
  updated_at: timestamptz!
}

"""
aggregated selection of "request"
"""
type request_aggregate {
  aggregate: request_aggregate_fields
  nodes: [request!]!
}

input request_aggregate_bool_exp {
  count: request_aggregate_bool_exp_count
}

input request_aggregate_bool_exp_count {
  arguments: [request_select_column!]
  distinct: Boolean
  filter: request_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "request"
"""
type request_aggregate_fields {
  avg: request_avg_fields
  count(columns: [request_select_column!], distinct: Boolean): Int!
  max: request_max_fields
  min: request_min_fields
  stddev: request_stddev_fields
  stddev_pop: request_stddev_pop_fields
  stddev_samp: request_stddev_samp_fields
  sum: request_sum_fields
  var_pop: request_var_pop_fields
  var_samp: request_var_samp_fields
  variance: request_variance_fields
}

"""
order by aggregate values of table "request"
"""
input request_aggregate_order_by {
  avg: request_avg_order_by
  count: order_by
  max: request_max_order_by
  min: request_min_order_by
  stddev: request_stddev_order_by
  stddev_pop: request_stddev_pop_order_by
  stddev_samp: request_stddev_samp_order_by
  sum: request_sum_order_by
  var_pop: request_var_pop_order_by
  var_samp: request_var_samp_order_by
  variance: request_variance_order_by
}

"""
input type for inserting array relation for remote table "request"
"""
input request_arr_rel_insert_input {
  data: [request_insert_input!]!

  """upsert condition"""
  on_conflict: request_on_conflict
}

"""aggregate avg on columns"""
type request_avg_fields {
  """L'identifiant de l'enseignement correspondant à la demande."""
  course_id: Float

  """Le nombre d'heures demandées."""
  hours: Float

  """
  A computed field, executes function "hours_weighted"
  """
  hours_weighted: Float
  id: Float
  service_id: Float
}

"""
order by avg() on columns of table "request"
"""
input request_avg_order_by {
  """L'identifiant de l'enseignement correspondant à la demande."""
  course_id: order_by

  """Le nombre d'heures demandées."""
  hours: order_by
  id: order_by
  service_id: order_by
}

"""
Boolean expression to filter rows from the table "request". All fields are combined with a logical 'AND'.
"""
input request_bool_exp {
  _and: [request_bool_exp!]
  _not: request_bool_exp
  _or: [request_bool_exp!]
  course: course_bool_exp
  course_id: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  hours: Float_comparison_exp
  hours_weighted: Float_comparison_exp
  id: Int_comparison_exp
  is_priority: Boolean_comparison_exp
  service: service_bool_exp
  service_id: Int_comparison_exp
  type: String_comparison_exp
  typeByType: request_type_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "request"
"""
enum request_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  demande_pkey

  """
  unique or primary key constraint on columns "type", "course_id", "service_id"
  """
  request_service_id_course_id_type_key
}

"""
input type for incrementing numeric columns in table "request"
"""
input request_inc_input {
  """L'identifiant de l'enseignement correspondant à la demande."""
  course_id: Int

  """Le nombre d'heures demandées."""
  hours: Float
  id: Int
  service_id: Int
}

"""
input type for inserting data into table "request"
"""
input request_insert_input {
  course: course_obj_rel_insert_input

  """L'identifiant de l'enseignement correspondant à la demande."""
  course_id: Int
  created_at: timestamptz

  """Le nombre d'heures demandées."""
  hours: Float
  id: Int
  service: service_obj_rel_insert_input
  service_id: Int

  """Le type de demande."""
  type: String
  typeByType: request_type_obj_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type request_max_fields {
  """L'identifiant de l'enseignement correspondant à la demande."""
  course_id: Int
  created_at: timestamptz

  """Le nombre d'heures demandées."""
  hours: Float

  """
  A computed field, executes function "hours_weighted"
  """
  hours_weighted: Float
  id: Int
  service_id: Int

  """Le type de demande."""
  type: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "request"
"""
input request_max_order_by {
  """L'identifiant de l'enseignement correspondant à la demande."""
  course_id: order_by
  created_at: order_by

  """Le nombre d'heures demandées."""
  hours: order_by
  id: order_by
  service_id: order_by

  """Le type de demande."""
  type: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type request_min_fields {
  """L'identifiant de l'enseignement correspondant à la demande."""
  course_id: Int
  created_at: timestamptz

  """Le nombre d'heures demandées."""
  hours: Float

  """
  A computed field, executes function "hours_weighted"
  """
  hours_weighted: Float
  id: Int
  service_id: Int

  """Le type de demande."""
  type: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "request"
"""
input request_min_order_by {
  """L'identifiant de l'enseignement correspondant à la demande."""
  course_id: order_by
  created_at: order_by

  """Le nombre d'heures demandées."""
  hours: order_by
  id: order_by
  service_id: order_by

  """Le type de demande."""
  type: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "request"
"""
type request_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [request!]!
}

"""
on_conflict condition type for table "request"
"""
input request_on_conflict {
  constraint: request_constraint!
  update_columns: [request_update_column!]! = []
  where: request_bool_exp
}

"""Ordering options when selecting data from "request"."""
input request_order_by {
  course: course_order_by
  course_id: order_by
  created_at: order_by
  hours: order_by
  hours_weighted: order_by
  id: order_by
  is_priority: order_by
  service: service_order_by
  service_id: order_by
  type: order_by
  typeByType: request_type_order_by
  updated_at: order_by
}

"""primary key columns input for table: request"""
input request_pk_columns_input {
  id: Int!
}

"""
select columns of table "request"
"""
enum request_select_column {
  """column name"""
  course_id

  """column name"""
  created_at

  """column name"""
  hours

  """column name"""
  id

  """column name"""
  service_id

  """column name"""
  type

  """column name"""
  updated_at
}

"""
input type for updating data in table "request"
"""
input request_set_input {
  """L'identifiant de l'enseignement correspondant à la demande."""
  course_id: Int
  created_at: timestamptz

  """Le nombre d'heures demandées."""
  hours: Float
  id: Int
  service_id: Int

  """Le type de demande."""
  type: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type request_stddev_fields {
  """L'identifiant de l'enseignement correspondant à la demande."""
  course_id: Float

  """Le nombre d'heures demandées."""
  hours: Float

  """
  A computed field, executes function "hours_weighted"
  """
  hours_weighted: Float
  id: Float
  service_id: Float
}

"""
order by stddev() on columns of table "request"
"""
input request_stddev_order_by {
  """L'identifiant de l'enseignement correspondant à la demande."""
  course_id: order_by

  """Le nombre d'heures demandées."""
  hours: order_by
  id: order_by
  service_id: order_by
}

"""aggregate stddev_pop on columns"""
type request_stddev_pop_fields {
  """L'identifiant de l'enseignement correspondant à la demande."""
  course_id: Float

  """Le nombre d'heures demandées."""
  hours: Float

  """
  A computed field, executes function "hours_weighted"
  """
  hours_weighted: Float
  id: Float
  service_id: Float
}

"""
order by stddev_pop() on columns of table "request"
"""
input request_stddev_pop_order_by {
  """L'identifiant de l'enseignement correspondant à la demande."""
  course_id: order_by

  """Le nombre d'heures demandées."""
  hours: order_by
  id: order_by
  service_id: order_by
}

"""aggregate stddev_samp on columns"""
type request_stddev_samp_fields {
  """L'identifiant de l'enseignement correspondant à la demande."""
  course_id: Float

  """Le nombre d'heures demandées."""
  hours: Float

  """
  A computed field, executes function "hours_weighted"
  """
  hours_weighted: Float
  id: Float
  service_id: Float
}

"""
order by stddev_samp() on columns of table "request"
"""
input request_stddev_samp_order_by {
  """L'identifiant de l'enseignement correspondant à la demande."""
  course_id: order_by

  """Le nombre d'heures demandées."""
  hours: order_by
  id: order_by
  service_id: order_by
}

"""
Streaming cursor of the table "request"
"""
input request_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: request_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input request_stream_cursor_value_input {
  """L'identifiant de l'enseignement correspondant à la demande."""
  course_id: Int
  created_at: timestamptz

  """Le nombre d'heures demandées."""
  hours: Float
  id: Int
  service_id: Int

  """Le type de demande."""
  type: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type request_sum_fields {
  """L'identifiant de l'enseignement correspondant à la demande."""
  course_id: Int

  """Le nombre d'heures demandées."""
  hours: Float

  """
  A computed field, executes function "hours_weighted"
  """
  hours_weighted: Float
  id: Int
  service_id: Int
}

"""
order by sum() on columns of table "request"
"""
input request_sum_order_by {
  """L'identifiant de l'enseignement correspondant à la demande."""
  course_id: order_by

  """Le nombre d'heures demandées."""
  hours: order_by
  id: order_by
  service_id: order_by
}

"""
Table contenant les différents types de demande (principale, secondaire, attribution).
"""
type request_type {
  """Une brève description."""
  description: String

  """An array relationship"""
  requests(
    """distinct select on columns"""
    distinct_on: [request_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [request_order_by!]

    """filter the rows returned"""
    where: request_bool_exp
  ): [request!]!

  """An aggregate relationship"""
  requests_aggregate(
    """distinct select on columns"""
    distinct_on: [request_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [request_order_by!]

    """filter the rows returned"""
    where: request_bool_exp
  ): request_aggregate!

  """Le type de demande (unique)."""
  value: String!
}

"""
aggregated selection of "request_type"
"""
type request_type_aggregate {
  aggregate: request_type_aggregate_fields
  nodes: [request_type!]!
}

"""
aggregate fields of "request_type"
"""
type request_type_aggregate_fields {
  count(columns: [request_type_select_column!], distinct: Boolean): Int!
  max: request_type_max_fields
  min: request_type_min_fields
}

"""
Boolean expression to filter rows from the table "request_type". All fields are combined with a logical 'AND'.
"""
input request_type_bool_exp {
  _and: [request_type_bool_exp!]
  _not: request_type_bool_exp
  _or: [request_type_bool_exp!]
  description: String_comparison_exp
  requests: request_bool_exp
  requests_aggregate: request_aggregate_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "request_type"
"""
enum request_type_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  type_demande_pkey
}

"""
input type for inserting data into table "request_type"
"""
input request_type_insert_input {
  """Une brève description."""
  description: String
  requests: request_arr_rel_insert_input

  """Le type de demande (unique)."""
  value: String
}

"""aggregate max on columns"""
type request_type_max_fields {
  """Une brève description."""
  description: String

  """Le type de demande (unique)."""
  value: String
}

"""aggregate min on columns"""
type request_type_min_fields {
  """Une brève description."""
  description: String

  """Le type de demande (unique)."""
  value: String
}

"""
response of any mutation on the table "request_type"
"""
type request_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [request_type!]!
}

"""
input type for inserting object relation for remote table "request_type"
"""
input request_type_obj_rel_insert_input {
  data: request_type_insert_input!

  """upsert condition"""
  on_conflict: request_type_on_conflict
}

"""
on_conflict condition type for table "request_type"
"""
input request_type_on_conflict {
  constraint: request_type_constraint!
  update_columns: [request_type_update_column!]! = []
  where: request_type_bool_exp
}

"""Ordering options when selecting data from "request_type"."""
input request_type_order_by {
  description: order_by
  requests_aggregate: request_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: request_type"""
input request_type_pk_columns_input {
  """Le type de demande (unique)."""
  value: String!
}

"""
select columns of table "request_type"
"""
enum request_type_select_column {
  """column name"""
  description

  """column name"""
  value
}

"""
input type for updating data in table "request_type"
"""
input request_type_set_input {
  """Une brève description."""
  description: String

  """Le type de demande (unique)."""
  value: String
}

"""
Streaming cursor of the table "request_type"
"""
input request_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: request_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input request_type_stream_cursor_value_input {
  """Une brève description."""
  description: String

  """Le type de demande (unique)."""
  value: String
}

"""
update columns of table "request_type"
"""
enum request_type_update_column {
  """column name"""
  description

  """column name"""
  value
}

input request_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: request_type_set_input

  """filter the rows which have to be updated"""
  where: request_type_bool_exp!
}

"""
update columns of table "request"
"""
enum request_update_column {
  """column name"""
  course_id

  """column name"""
  created_at

  """column name"""
  hours

  """column name"""
  id

  """column name"""
  service_id

  """column name"""
  type

  """column name"""
  updated_at
}

input request_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: request_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: request_set_input

  """filter the rows which have to be updated"""
  where: request_bool_exp!
}

"""aggregate var_pop on columns"""
type request_var_pop_fields {
  """L'identifiant de l'enseignement correspondant à la demande."""
  course_id: Float

  """Le nombre d'heures demandées."""
  hours: Float

  """
  A computed field, executes function "hours_weighted"
  """
  hours_weighted: Float
  id: Float
  service_id: Float
}

"""
order by var_pop() on columns of table "request"
"""
input request_var_pop_order_by {
  """L'identifiant de l'enseignement correspondant à la demande."""
  course_id: order_by

  """Le nombre d'heures demandées."""
  hours: order_by
  id: order_by
  service_id: order_by
}

"""aggregate var_samp on columns"""
type request_var_samp_fields {
  """L'identifiant de l'enseignement correspondant à la demande."""
  course_id: Float

  """Le nombre d'heures demandées."""
  hours: Float

  """
  A computed field, executes function "hours_weighted"
  """
  hours_weighted: Float
  id: Float
  service_id: Float
}

"""
order by var_samp() on columns of table "request"
"""
input request_var_samp_order_by {
  """L'identifiant de l'enseignement correspondant à la demande."""
  course_id: order_by

  """Le nombre d'heures demandées."""
  hours: order_by
  id: order_by
  service_id: order_by
}

"""aggregate variance on columns"""
type request_variance_fields {
  """L'identifiant de l'enseignement correspondant à la demande."""
  course_id: Float

  """Le nombre d'heures demandées."""
  hours: Float

  """
  A computed field, executes function "hours_weighted"
  """
  hours_weighted: Float
  id: Float
  service_id: Float
}

"""
order by variance() on columns of table "request"
"""
input request_variance_order_by {
  """L'identifiant de l'enseignement correspondant à la demande."""
  course_id: order_by

  """Le nombre d'heures demandées."""
  hours: order_by
  id: order_by
  service_id: order_by
}

"""
Table contenant les services de base, c'est-à-dire le nombre d'heures EQTD qu'un intervenant donné doit réaliser lors d'une année donnée avant modifications éventuelles.
"""
type service {
  created_at: timestamptz!

  """Le nombre d'heures EQTD du service."""
  hours: Float!

  """L'identifiant unique du service."""
  id: Int!
  message: String

  """An array relationship"""
  modifications(
    """distinct select on columns"""
    distinct_on: [service_modification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_modification_order_by!]

    """filter the rows returned"""
    where: service_modification_bool_exp
  ): [service_modification!]!

  """An aggregate relationship"""
  modifications_aggregate(
    """distinct select on columns"""
    distinct_on: [service_modification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_modification_order_by!]

    """filter the rows returned"""
    where: service_modification_bool_exp
  ): service_modification_aggregate!

  """An array relationship"""
  priorities(
    """distinct select on columns"""
    distinct_on: [priority_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [priority_order_by!]

    """filter the rows returned"""
    where: priority_bool_exp
  ): [priority!]!

  """An aggregate relationship"""
  priorities_aggregate(
    """distinct select on columns"""
    distinct_on: [priority_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [priority_order_by!]

    """filter the rows returned"""
    where: priority_bool_exp
  ): priority_aggregate!

  """An array relationship"""
  requests(
    """distinct select on columns"""
    distinct_on: [request_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [request_order_by!]

    """filter the rows returned"""
    where: request_bool_exp
  ): [request!]!

  """An aggregate relationship"""
  requests_aggregate(
    """distinct select on columns"""
    distinct_on: [request_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [request_order_by!]

    """filter the rows returned"""
    where: request_bool_exp
  ): request_aggregate!

  """An object relationship"""
  teacher: teacher!

  """L'identifiant de l'intervenant correspond au service."""
  uid: String!
  updated_at: timestamptz!

  """L'année correspondant au service."""
  year: Int!

  """An object relationship"""
  yearByYear: year!
}

"""
aggregated selection of "service"
"""
type service_aggregate {
  aggregate: service_aggregate_fields
  nodes: [service!]!
}

input service_aggregate_bool_exp {
  count: service_aggregate_bool_exp_count
}

input service_aggregate_bool_exp_count {
  arguments: [service_select_column!]
  distinct: Boolean
  filter: service_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "service"
"""
type service_aggregate_fields {
  avg: service_avg_fields
  count(columns: [service_select_column!], distinct: Boolean): Int!
  max: service_max_fields
  min: service_min_fields
  stddev: service_stddev_fields
  stddev_pop: service_stddev_pop_fields
  stddev_samp: service_stddev_samp_fields
  sum: service_sum_fields
  var_pop: service_var_pop_fields
  var_samp: service_var_samp_fields
  variance: service_variance_fields
}

"""
order by aggregate values of table "service"
"""
input service_aggregate_order_by {
  avg: service_avg_order_by
  count: order_by
  max: service_max_order_by
  min: service_min_order_by
  stddev: service_stddev_order_by
  stddev_pop: service_stddev_pop_order_by
  stddev_samp: service_stddev_samp_order_by
  sum: service_sum_order_by
  var_pop: service_var_pop_order_by
  var_samp: service_var_samp_order_by
  variance: service_variance_order_by
}

"""
input type for inserting array relation for remote table "service"
"""
input service_arr_rel_insert_input {
  data: [service_insert_input!]!

  """upsert condition"""
  on_conflict: service_on_conflict
}

"""aggregate avg on columns"""
type service_avg_fields {
  """Le nombre d'heures EQTD du service."""
  hours: Float

  """L'identifiant unique du service."""
  id: Float

  """L'année correspondant au service."""
  year: Float
}

"""
order by avg() on columns of table "service"
"""
input service_avg_order_by {
  """Le nombre d'heures EQTD du service."""
  hours: order_by

  """L'identifiant unique du service."""
  id: order_by

  """L'année correspondant au service."""
  year: order_by
}

"""
Boolean expression to filter rows from the table "service". All fields are combined with a logical 'AND'.
"""
input service_bool_exp {
  _and: [service_bool_exp!]
  _not: service_bool_exp
  _or: [service_bool_exp!]
  created_at: timestamptz_comparison_exp
  hours: Float_comparison_exp
  id: Int_comparison_exp
  message: String_comparison_exp
  modifications: service_modification_bool_exp
  modifications_aggregate: service_modification_aggregate_bool_exp
  priorities: priority_bool_exp
  priorities_aggregate: priority_aggregate_bool_exp
  requests: request_bool_exp
  requests_aggregate: request_aggregate_bool_exp
  teacher: teacher_bool_exp
  uid: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  year: Int_comparison_exp
  yearByYear: year_bool_exp
}

"""
unique or primary key constraints on table "service"
"""
enum service_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  service_pkey

  """
  unique or primary key constraint on columns "uid", "year"
  """
  service_year_uid_key
}

"""
input type for incrementing numeric columns in table "service"
"""
input service_inc_input {
  """Le nombre d'heures EQTD du service."""
  hours: Float

  """L'identifiant unique du service."""
  id: Int

  """L'année correspondant au service."""
  year: Int
}

"""
input type for inserting data into table "service"
"""
input service_insert_input {
  created_at: timestamptz

  """Le nombre d'heures EQTD du service."""
  hours: Float

  """L'identifiant unique du service."""
  id: Int
  message: String
  modifications: service_modification_arr_rel_insert_input
  priorities: priority_arr_rel_insert_input
  requests: request_arr_rel_insert_input
  teacher: teacher_obj_rel_insert_input

  """L'identifiant de l'intervenant correspond au service."""
  uid: String
  updated_at: timestamptz

  """L'année correspondant au service."""
  year: Int
  yearByYear: year_obj_rel_insert_input
}

"""aggregate max on columns"""
type service_max_fields {
  created_at: timestamptz

  """Le nombre d'heures EQTD du service."""
  hours: Float

  """L'identifiant unique du service."""
  id: Int
  message: String

  """L'identifiant de l'intervenant correspond au service."""
  uid: String
  updated_at: timestamptz

  """L'année correspondant au service."""
  year: Int
}

"""
order by max() on columns of table "service"
"""
input service_max_order_by {
  created_at: order_by

  """Le nombre d'heures EQTD du service."""
  hours: order_by

  """L'identifiant unique du service."""
  id: order_by
  message: order_by

  """L'identifiant de l'intervenant correspond au service."""
  uid: order_by
  updated_at: order_by

  """L'année correspondant au service."""
  year: order_by
}

"""aggregate min on columns"""
type service_min_fields {
  created_at: timestamptz

  """Le nombre d'heures EQTD du service."""
  hours: Float

  """L'identifiant unique du service."""
  id: Int
  message: String

  """L'identifiant de l'intervenant correspond au service."""
  uid: String
  updated_at: timestamptz

  """L'année correspondant au service."""
  year: Int
}

"""
order by min() on columns of table "service"
"""
input service_min_order_by {
  created_at: order_by

  """Le nombre d'heures EQTD du service."""
  hours: order_by

  """L'identifiant unique du service."""
  id: order_by
  message: order_by

  """L'identifiant de l'intervenant correspond au service."""
  uid: order_by
  updated_at: order_by

  """L'année correspondant au service."""
  year: order_by
}

"""
Table containing modifications to a teacher's base service for a given year.
"""
type service_modification {
  """Timestamp of when the modification was created."""
  created_at: timestamptz!

  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: Float!

  """Unique identifier for the modification."""
  id: Int!

  """An object relationship"""
  service: service!

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  service_id: Int!

  """Type of modification."""
  type: String!

  """An object relationship"""
  typeByType: service_modification_type!

  """Timestamp of when the modification was last updated."""
  updated_at: timestamptz!
}

"""
aggregated selection of "service_modification"
"""
type service_modification_aggregate {
  aggregate: service_modification_aggregate_fields
  nodes: [service_modification!]!
}

input service_modification_aggregate_bool_exp {
  count: service_modification_aggregate_bool_exp_count
}

input service_modification_aggregate_bool_exp_count {
  arguments: [service_modification_select_column!]
  distinct: Boolean
  filter: service_modification_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "service_modification"
"""
type service_modification_aggregate_fields {
  avg: service_modification_avg_fields
  count(columns: [service_modification_select_column!], distinct: Boolean): Int!
  max: service_modification_max_fields
  min: service_modification_min_fields
  stddev: service_modification_stddev_fields
  stddev_pop: service_modification_stddev_pop_fields
  stddev_samp: service_modification_stddev_samp_fields
  sum: service_modification_sum_fields
  var_pop: service_modification_var_pop_fields
  var_samp: service_modification_var_samp_fields
  variance: service_modification_variance_fields
}

"""
order by aggregate values of table "service_modification"
"""
input service_modification_aggregate_order_by {
  avg: service_modification_avg_order_by
  count: order_by
  max: service_modification_max_order_by
  min: service_modification_min_order_by
  stddev: service_modification_stddev_order_by
  stddev_pop: service_modification_stddev_pop_order_by
  stddev_samp: service_modification_stddev_samp_order_by
  sum: service_modification_sum_order_by
  var_pop: service_modification_var_pop_order_by
  var_samp: service_modification_var_samp_order_by
  variance: service_modification_variance_order_by
}

"""
input type for inserting array relation for remote table "service_modification"
"""
input service_modification_arr_rel_insert_input {
  data: [service_modification_insert_input!]!

  """upsert condition"""
  on_conflict: service_modification_on_conflict
}

"""aggregate avg on columns"""
type service_modification_avg_fields {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: Float

  """Unique identifier for the modification."""
  id: Float

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  service_id: Float
}

"""
order by avg() on columns of table "service_modification"
"""
input service_modification_avg_order_by {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: order_by

  """Unique identifier for the modification."""
  id: order_by

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  service_id: order_by
}

"""
Boolean expression to filter rows from the table "service_modification". All fields are combined with a logical 'AND'.
"""
input service_modification_bool_exp {
  _and: [service_modification_bool_exp!]
  _not: service_modification_bool_exp
  _or: [service_modification_bool_exp!]
  created_at: timestamptz_comparison_exp
  hours: Float_comparison_exp
  id: Int_comparison_exp
  service: service_bool_exp
  service_id: Int_comparison_exp
  type: String_comparison_exp
  typeByType: service_modification_type_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "service_modification"
"""
enum service_modification_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  modification_service_pkey
}

"""
input type for incrementing numeric columns in table "service_modification"
"""
input service_modification_inc_input {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: Float

  """Unique identifier for the modification."""
  id: Int

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  service_id: Int
}

"""
input type for inserting data into table "service_modification"
"""
input service_modification_insert_input {
  """Timestamp of when the modification was created."""
  created_at: timestamptz

  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: Float

  """Unique identifier for the modification."""
  id: Int
  service: service_obj_rel_insert_input

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  service_id: Int

  """Type of modification."""
  type: String
  typeByType: service_modification_type_obj_rel_insert_input

  """Timestamp of when the modification was last updated."""
  updated_at: timestamptz
}

"""aggregate max on columns"""
type service_modification_max_fields {
  """Timestamp of when the modification was created."""
  created_at: timestamptz

  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: Float

  """Unique identifier for the modification."""
  id: Int

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  service_id: Int

  """Type of modification."""
  type: String

  """Timestamp of when the modification was last updated."""
  updated_at: timestamptz
}

"""
order by max() on columns of table "service_modification"
"""
input service_modification_max_order_by {
  """Timestamp of when the modification was created."""
  created_at: order_by

  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: order_by

  """Unique identifier for the modification."""
  id: order_by

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  service_id: order_by

  """Type of modification."""
  type: order_by

  """Timestamp of when the modification was last updated."""
  updated_at: order_by
}

"""aggregate min on columns"""
type service_modification_min_fields {
  """Timestamp of when the modification was created."""
  created_at: timestamptz

  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: Float

  """Unique identifier for the modification."""
  id: Int

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  service_id: Int

  """Type of modification."""
  type: String

  """Timestamp of when the modification was last updated."""
  updated_at: timestamptz
}

"""
order by min() on columns of table "service_modification"
"""
input service_modification_min_order_by {
  """Timestamp of when the modification was created."""
  created_at: order_by

  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: order_by

  """Unique identifier for the modification."""
  id: order_by

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  service_id: order_by

  """Type of modification."""
  type: order_by

  """Timestamp of when the modification was last updated."""
  updated_at: order_by
}

"""
response of any mutation on the table "service_modification"
"""
type service_modification_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [service_modification!]!
}

"""
on_conflict condition type for table "service_modification"
"""
input service_modification_on_conflict {
  constraint: service_modification_constraint!
  update_columns: [service_modification_update_column!]! = []
  where: service_modification_bool_exp
}

"""Ordering options when selecting data from "service_modification"."""
input service_modification_order_by {
  created_at: order_by
  hours: order_by
  id: order_by
  service: service_order_by
  service_id: order_by
  type: order_by
  typeByType: service_modification_type_order_by
  updated_at: order_by
}

"""primary key columns input for table: service_modification"""
input service_modification_pk_columns_input {
  """Unique identifier for the modification."""
  id: Int!
}

"""
select columns of table "service_modification"
"""
enum service_modification_select_column {
  """column name"""
  created_at

  """column name"""
  hours

  """column name"""
  id

  """column name"""
  service_id

  """column name"""
  type

  """column name"""
  updated_at
}

"""
input type for updating data in table "service_modification"
"""
input service_modification_set_input {
  """Timestamp of when the modification was created."""
  created_at: timestamptz

  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: Float

  """Unique identifier for the modification."""
  id: Int

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  service_id: Int

  """Type of modification."""
  type: String

  """Timestamp of when the modification was last updated."""
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type service_modification_stddev_fields {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: Float

  """Unique identifier for the modification."""
  id: Float

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  service_id: Float
}

"""
order by stddev() on columns of table "service_modification"
"""
input service_modification_stddev_order_by {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: order_by

  """Unique identifier for the modification."""
  id: order_by

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  service_id: order_by
}

"""aggregate stddev_pop on columns"""
type service_modification_stddev_pop_fields {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: Float

  """Unique identifier for the modification."""
  id: Float

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  service_id: Float
}

"""
order by stddev_pop() on columns of table "service_modification"
"""
input service_modification_stddev_pop_order_by {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: order_by

  """Unique identifier for the modification."""
  id: order_by

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  service_id: order_by
}

"""aggregate stddev_samp on columns"""
type service_modification_stddev_samp_fields {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: Float

  """Unique identifier for the modification."""
  id: Float

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  service_id: Float
}

"""
order by stddev_samp() on columns of table "service_modification"
"""
input service_modification_stddev_samp_order_by {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: order_by

  """Unique identifier for the modification."""
  id: order_by

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  service_id: order_by
}

"""
Streaming cursor of the table "service_modification"
"""
input service_modification_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: service_modification_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input service_modification_stream_cursor_value_input {
  """Timestamp of when the modification was created."""
  created_at: timestamptz

  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: Float

  """Unique identifier for the modification."""
  id: Int

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  service_id: Int

  """Type of modification."""
  type: String

  """Timestamp of when the modification was last updated."""
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type service_modification_sum_fields {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: Float

  """Unique identifier for the modification."""
  id: Int

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  service_id: Int
}

"""
order by sum() on columns of table "service_modification"
"""
input service_modification_sum_order_by {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: order_by

  """Unique identifier for the modification."""
  id: order_by

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  service_id: order_by
}

"""Table containing different types of service modifications."""
type service_modification_type {
  """Brief description."""
  description: String

  """Display label for the modification type."""
  label: String!

  """An array relationship"""
  modifications_service(
    """distinct select on columns"""
    distinct_on: [service_modification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_modification_order_by!]

    """filter the rows returned"""
    where: service_modification_bool_exp
  ): [service_modification!]!

  """An aggregate relationship"""
  modifications_service_aggregate(
    """distinct select on columns"""
    distinct_on: [service_modification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_modification_order_by!]

    """filter the rows returned"""
    where: service_modification_bool_exp
  ): service_modification_aggregate!

  """Modification type (unique)."""
  value: String!
}

"""
aggregated selection of "service_modification_type"
"""
type service_modification_type_aggregate {
  aggregate: service_modification_type_aggregate_fields
  nodes: [service_modification_type!]!
}

"""
aggregate fields of "service_modification_type"
"""
type service_modification_type_aggregate_fields {
  count(columns: [service_modification_type_select_column!], distinct: Boolean): Int!
  max: service_modification_type_max_fields
  min: service_modification_type_min_fields
}

"""
Boolean expression to filter rows from the table "service_modification_type". All fields are combined with a logical 'AND'.
"""
input service_modification_type_bool_exp {
  _and: [service_modification_type_bool_exp!]
  _not: service_modification_type_bool_exp
  _or: [service_modification_type_bool_exp!]
  description: String_comparison_exp
  label: String_comparison_exp
  modifications_service: service_modification_bool_exp
  modifications_service_aggregate: service_modification_aggregate_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "service_modification_type"
"""
enum service_modification_type_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  type_modification_pkey
}

"""
input type for inserting data into table "service_modification_type"
"""
input service_modification_type_insert_input {
  """Brief description."""
  description: String

  """Display label for the modification type."""
  label: String
  modifications_service: service_modification_arr_rel_insert_input

  """Modification type (unique)."""
  value: String
}

"""aggregate max on columns"""
type service_modification_type_max_fields {
  """Brief description."""
  description: String

  """Display label for the modification type."""
  label: String

  """Modification type (unique)."""
  value: String
}

"""aggregate min on columns"""
type service_modification_type_min_fields {
  """Brief description."""
  description: String

  """Display label for the modification type."""
  label: String

  """Modification type (unique)."""
  value: String
}

"""
response of any mutation on the table "service_modification_type"
"""
type service_modification_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [service_modification_type!]!
}

"""
input type for inserting object relation for remote table "service_modification_type"
"""
input service_modification_type_obj_rel_insert_input {
  data: service_modification_type_insert_input!

  """upsert condition"""
  on_conflict: service_modification_type_on_conflict
}

"""
on_conflict condition type for table "service_modification_type"
"""
input service_modification_type_on_conflict {
  constraint: service_modification_type_constraint!
  update_columns: [service_modification_type_update_column!]! = []
  where: service_modification_type_bool_exp
}

"""Ordering options when selecting data from "service_modification_type"."""
input service_modification_type_order_by {
  description: order_by
  label: order_by
  modifications_service_aggregate: service_modification_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: service_modification_type"""
input service_modification_type_pk_columns_input {
  """Modification type (unique)."""
  value: String!
}

"""
select columns of table "service_modification_type"
"""
enum service_modification_type_select_column {
  """column name"""
  description

  """column name"""
  label

  """column name"""
  value
}

"""
input type for updating data in table "service_modification_type"
"""
input service_modification_type_set_input {
  """Brief description."""
  description: String

  """Display label for the modification type."""
  label: String

  """Modification type (unique)."""
  value: String
}

"""
Streaming cursor of the table "service_modification_type"
"""
input service_modification_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: service_modification_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input service_modification_type_stream_cursor_value_input {
  """Brief description."""
  description: String

  """Display label for the modification type."""
  label: String

  """Modification type (unique)."""
  value: String
}

"""
update columns of table "service_modification_type"
"""
enum service_modification_type_update_column {
  """column name"""
  description

  """column name"""
  label

  """column name"""
  value
}

input service_modification_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: service_modification_type_set_input

  """filter the rows which have to be updated"""
  where: service_modification_type_bool_exp!
}

"""
update columns of table "service_modification"
"""
enum service_modification_update_column {
  """column name"""
  created_at

  """column name"""
  hours

  """column name"""
  id

  """column name"""
  service_id

  """column name"""
  type

  """column name"""
  updated_at
}

input service_modification_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: service_modification_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: service_modification_set_input

  """filter the rows which have to be updated"""
  where: service_modification_bool_exp!
}

"""aggregate var_pop on columns"""
type service_modification_var_pop_fields {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: Float

  """Unique identifier for the modification."""
  id: Float

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  service_id: Float
}

"""
order by var_pop() on columns of table "service_modification"
"""
input service_modification_var_pop_order_by {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: order_by

  """Unique identifier for the modification."""
  id: order_by

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  service_id: order_by
}

"""aggregate var_samp on columns"""
type service_modification_var_samp_fields {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: Float

  """Unique identifier for the modification."""
  id: Float

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  service_id: Float
}

"""
order by var_samp() on columns of table "service_modification"
"""
input service_modification_var_samp_order_by {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: order_by

  """Unique identifier for the modification."""
  id: order_by

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  service_id: order_by
}

"""aggregate variance on columns"""
type service_modification_variance_fields {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: Float

  """Unique identifier for the modification."""
  id: Float

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  service_id: Float
}

"""
order by variance() on columns of table "service_modification"
"""
input service_modification_variance_order_by {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: order_by

  """Unique identifier for the modification."""
  id: order_by

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  service_id: order_by
}

"""
response of any mutation on the table "service"
"""
type service_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [service!]!
}

"""
input type for inserting object relation for remote table "service"
"""
input service_obj_rel_insert_input {
  data: service_insert_input!

  """upsert condition"""
  on_conflict: service_on_conflict
}

"""
on_conflict condition type for table "service"
"""
input service_on_conflict {
  constraint: service_constraint!
  update_columns: [service_update_column!]! = []
  where: service_bool_exp
}

"""Ordering options when selecting data from "service"."""
input service_order_by {
  created_at: order_by
  hours: order_by
  id: order_by
  message: order_by
  modifications_aggregate: service_modification_aggregate_order_by
  priorities_aggregate: priority_aggregate_order_by
  requests_aggregate: request_aggregate_order_by
  teacher: teacher_order_by
  uid: order_by
  updated_at: order_by
  year: order_by
  yearByYear: year_order_by
}

"""primary key columns input for table: service"""
input service_pk_columns_input {
  """L'identifiant unique du service."""
  id: Int!
}

"""
select columns of table "service"
"""
enum service_select_column {
  """column name"""
  created_at

  """column name"""
  hours

  """column name"""
  id

  """column name"""
  message

  """column name"""
  uid

  """column name"""
  updated_at

  """column name"""
  year
}

"""
input type for updating data in table "service"
"""
input service_set_input {
  created_at: timestamptz

  """Le nombre d'heures EQTD du service."""
  hours: Float

  """L'identifiant unique du service."""
  id: Int
  message: String

  """L'identifiant de l'intervenant correspond au service."""
  uid: String
  updated_at: timestamptz

  """L'année correspondant au service."""
  year: Int
}

"""aggregate stddev on columns"""
type service_stddev_fields {
  """Le nombre d'heures EQTD du service."""
  hours: Float

  """L'identifiant unique du service."""
  id: Float

  """L'année correspondant au service."""
  year: Float
}

"""
order by stddev() on columns of table "service"
"""
input service_stddev_order_by {
  """Le nombre d'heures EQTD du service."""
  hours: order_by

  """L'identifiant unique du service."""
  id: order_by

  """L'année correspondant au service."""
  year: order_by
}

"""aggregate stddev_pop on columns"""
type service_stddev_pop_fields {
  """Le nombre d'heures EQTD du service."""
  hours: Float

  """L'identifiant unique du service."""
  id: Float

  """L'année correspondant au service."""
  year: Float
}

"""
order by stddev_pop() on columns of table "service"
"""
input service_stddev_pop_order_by {
  """Le nombre d'heures EQTD du service."""
  hours: order_by

  """L'identifiant unique du service."""
  id: order_by

  """L'année correspondant au service."""
  year: order_by
}

"""aggregate stddev_samp on columns"""
type service_stddev_samp_fields {
  """Le nombre d'heures EQTD du service."""
  hours: Float

  """L'identifiant unique du service."""
  id: Float

  """L'année correspondant au service."""
  year: Float
}

"""
order by stddev_samp() on columns of table "service"
"""
input service_stddev_samp_order_by {
  """Le nombre d'heures EQTD du service."""
  hours: order_by

  """L'identifiant unique du service."""
  id: order_by

  """L'année correspondant au service."""
  year: order_by
}

"""
Streaming cursor of the table "service"
"""
input service_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: service_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input service_stream_cursor_value_input {
  created_at: timestamptz

  """Le nombre d'heures EQTD du service."""
  hours: Float

  """L'identifiant unique du service."""
  id: Int
  message: String

  """L'identifiant de l'intervenant correspond au service."""
  uid: String
  updated_at: timestamptz

  """L'année correspondant au service."""
  year: Int
}

"""aggregate sum on columns"""
type service_sum_fields {
  """Le nombre d'heures EQTD du service."""
  hours: Float

  """L'identifiant unique du service."""
  id: Int

  """L'année correspondant au service."""
  year: Int
}

"""
order by sum() on columns of table "service"
"""
input service_sum_order_by {
  """Le nombre d'heures EQTD du service."""
  hours: order_by

  """L'identifiant unique du service."""
  id: order_by

  """L'année correspondant au service."""
  year: order_by
}

"""
update columns of table "service"
"""
enum service_update_column {
  """column name"""
  created_at

  """column name"""
  hours

  """column name"""
  id

  """column name"""
  message

  """column name"""
  uid

  """column name"""
  updated_at

  """column name"""
  year
}

input service_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: service_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: service_set_input

  """filter the rows which have to be updated"""
  where: service_bool_exp!
}

"""aggregate var_pop on columns"""
type service_var_pop_fields {
  """Le nombre d'heures EQTD du service."""
  hours: Float

  """L'identifiant unique du service."""
  id: Float

  """L'année correspondant au service."""
  year: Float
}

"""
order by var_pop() on columns of table "service"
"""
input service_var_pop_order_by {
  """Le nombre d'heures EQTD du service."""
  hours: order_by

  """L'identifiant unique du service."""
  id: order_by

  """L'année correspondant au service."""
  year: order_by
}

"""aggregate var_samp on columns"""
type service_var_samp_fields {
  """Le nombre d'heures EQTD du service."""
  hours: Float

  """L'identifiant unique du service."""
  id: Float

  """L'année correspondant au service."""
  year: Float
}

"""
order by var_samp() on columns of table "service"
"""
input service_var_samp_order_by {
  """Le nombre d'heures EQTD du service."""
  hours: order_by

  """L'identifiant unique du service."""
  id: order_by

  """L'année correspondant au service."""
  year: order_by
}

"""aggregate variance on columns"""
type service_variance_fields {
  """Le nombre d'heures EQTD du service."""
  hours: Float

  """L'identifiant unique du service."""
  id: Float

  """L'année correspondant au service."""
  year: Float
}

"""
order by variance() on columns of table "service"
"""
input service_variance_order_by {
  """Le nombre d'heures EQTD du service."""
  hours: order_by

  """L'identifiant unique du service."""
  id: order_by

  """L'année correspondant au service."""
  year: order_by
}

type subscription_root {
  """
  fetch data from the table: "coordinator"
  """
  coordinator(
    """distinct select on columns"""
    distinct_on: [coordinator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coordinator_order_by!]

    """filter the rows returned"""
    where: coordinator_bool_exp
  ): [coordinator!]!

  """
  fetch aggregated fields from the table: "coordinator"
  """
  coordinator_aggregate(
    """distinct select on columns"""
    distinct_on: [coordinator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coordinator_order_by!]

    """filter the rows returned"""
    where: coordinator_bool_exp
  ): coordinator_aggregate!

  """fetch data from the table: "coordinator" using primary key columns"""
  coordinator_by_pk(
    """Unique identifier for the coordinator entry."""
    id: Int!
  ): coordinator

  """
  fetch data from the table in a streaming manner: "coordinator"
  """
  coordinator_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [coordinator_stream_cursor_input]!

    """filter the rows returned"""
    where: coordinator_bool_exp
  ): [coordinator!]!

  """
  fetch data from the table: "course"
  """
  course(
    """distinct select on columns"""
    distinct_on: [course_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_order_by!]

    """filter the rows returned"""
    where: course_bool_exp
  ): [course!]!

  """
  fetch aggregated fields from the table: "course"
  """
  course_aggregate(
    """distinct select on columns"""
    distinct_on: [course_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_order_by!]

    """filter the rows returned"""
    where: course_bool_exp
  ): course_aggregate!

  """fetch data from the table: "course" using primary key columns"""
  course_by_pk(
    """L'identifiant unique de l'enseignement."""
    id: Int!
  ): course

  """
  fetch data from the table in a streaming manner: "course"
  """
  course_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [course_stream_cursor_input]!

    """filter the rows returned"""
    where: course_bool_exp
  ): [course!]!

  """
  fetch data from the table: "course_type"
  """
  course_type(
    """distinct select on columns"""
    distinct_on: [course_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_type_order_by!]

    """filter the rows returned"""
    where: course_type_bool_exp
  ): [course_type!]!

  """
  fetch aggregated fields from the table: "course_type"
  """
  course_type_aggregate(
    """distinct select on columns"""
    distinct_on: [course_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_type_order_by!]

    """filter the rows returned"""
    where: course_type_bool_exp
  ): course_type_aggregate!

  """fetch data from the table: "course_type" using primary key columns"""
  course_type_by_pk(
    """La clé du type d'enseignement (unique)."""
    value: String!
  ): course_type

  """
  fetch data from the table in a streaming manner: "course_type"
  """
  course_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [course_type_stream_cursor_input]!

    """filter the rows returned"""
    where: course_type_bool_exp
  ): [course_type!]!

  """
  fetch data from the table: "degree"
  """
  degree(
    """distinct select on columns"""
    distinct_on: [degree_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [degree_order_by!]

    """filter the rows returned"""
    where: degree_bool_exp
  ): [degree!]!

  """
  fetch aggregated fields from the table: "degree"
  """
  degree_aggregate(
    """distinct select on columns"""
    distinct_on: [degree_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [degree_order_by!]

    """filter the rows returned"""
    where: degree_bool_exp
  ): degree_aggregate!

  """fetch data from the table: "degree" using primary key columns"""
  degree_by_pk(
    """L'identifiant unique du cursus."""
    id: Int!
  ): degree

  """
  fetch data from the table in a streaming manner: "degree"
  """
  degree_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [degree_stream_cursor_input]!

    """filter the rows returned"""
    where: degree_bool_exp
  ): [degree!]!

  """
  fetch data from the table: "phase"
  """
  phase(
    """distinct select on columns"""
    distinct_on: [phase_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [phase_order_by!]

    """filter the rows returned"""
    where: phase_bool_exp
  ): [phase!]!

  """
  fetch aggregated fields from the table: "phase"
  """
  phase_aggregate(
    """distinct select on columns"""
    distinct_on: [phase_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [phase_order_by!]

    """filter the rows returned"""
    where: phase_bool_exp
  ): phase_aggregate!

  """fetch data from the table: "phase" using primary key columns"""
  phase_by_pk(
    """Phase identifier."""
    value: String!
  ): phase

  """
  fetch data from the table in a streaming manner: "phase"
  """
  phase_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [phase_stream_cursor_input]!

    """filter the rows returned"""
    where: phase_bool_exp
  ): [phase!]!

  """
  fetch data from the table: "position"
  """
  position(
    """distinct select on columns"""
    distinct_on: [position_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [position_order_by!]

    """filter the rows returned"""
    where: position_bool_exp
  ): [position!]!

  """
  fetch aggregated fields from the table: "position"
  """
  position_aggregate(
    """distinct select on columns"""
    distinct_on: [position_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [position_order_by!]

    """filter the rows returned"""
    where: position_bool_exp
  ): position_aggregate!

  """fetch data from the table: "position" using primary key columns"""
  position_by_pk(value: String!): position

  """
  fetch data from the table in a streaming manner: "position"
  """
  position_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [position_stream_cursor_input]!

    """filter the rows returned"""
    where: position_bool_exp
  ): [position!]!

  """
  fetch data from the table: "priority"
  """
  priority(
    """distinct select on columns"""
    distinct_on: [priority_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [priority_order_by!]

    """filter the rows returned"""
    where: priority_bool_exp
  ): [priority!]!

  """
  fetch aggregated fields from the table: "priority"
  """
  priority_aggregate(
    """distinct select on columns"""
    distinct_on: [priority_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [priority_order_by!]

    """filter the rows returned"""
    where: priority_bool_exp
  ): priority_aggregate!

  """fetch data from the table: "priority" using primary key columns"""
  priority_by_pk(
    """Unique identifier for the priority entry."""
    id: Int!
  ): priority

  """
  fetch data from the table in a streaming manner: "priority"
  """
  priority_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [priority_stream_cursor_input]!

    """filter the rows returned"""
    where: priority_bool_exp
  ): [priority!]!

  """
  fetch data from the table: "program"
  """
  program(
    """distinct select on columns"""
    distinct_on: [program_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [program_order_by!]

    """filter the rows returned"""
    where: program_bool_exp
  ): [program!]!

  """
  fetch aggregated fields from the table: "program"
  """
  program_aggregate(
    """distinct select on columns"""
    distinct_on: [program_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [program_order_by!]

    """filter the rows returned"""
    where: program_bool_exp
  ): program_aggregate!

  """fetch data from the table: "program" using primary key columns"""
  program_by_pk(
    """L'identifiant unique de la mention."""
    id: Int!
  ): program

  """
  fetch data from the table in a streaming manner: "program"
  """
  program_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [program_stream_cursor_input]!

    """filter the rows returned"""
    where: program_bool_exp
  ): [program!]!

  """
  fetch data from the table: "request"
  """
  request(
    """distinct select on columns"""
    distinct_on: [request_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [request_order_by!]

    """filter the rows returned"""
    where: request_bool_exp
  ): [request!]!

  """
  fetch aggregated fields from the table: "request"
  """
  request_aggregate(
    """distinct select on columns"""
    distinct_on: [request_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [request_order_by!]

    """filter the rows returned"""
    where: request_bool_exp
  ): request_aggregate!

  """fetch data from the table: "request" using primary key columns"""
  request_by_pk(id: Int!): request

  """
  fetch data from the table in a streaming manner: "request"
  """
  request_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [request_stream_cursor_input]!

    """filter the rows returned"""
    where: request_bool_exp
  ): [request!]!

  """
  fetch data from the table: "request_type"
  """
  request_type(
    """distinct select on columns"""
    distinct_on: [request_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [request_type_order_by!]

    """filter the rows returned"""
    where: request_type_bool_exp
  ): [request_type!]!

  """
  fetch aggregated fields from the table: "request_type"
  """
  request_type_aggregate(
    """distinct select on columns"""
    distinct_on: [request_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [request_type_order_by!]

    """filter the rows returned"""
    where: request_type_bool_exp
  ): request_type_aggregate!

  """fetch data from the table: "request_type" using primary key columns"""
  request_type_by_pk(
    """Le type de demande (unique)."""
    value: String!
  ): request_type

  """
  fetch data from the table in a streaming manner: "request_type"
  """
  request_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [request_type_stream_cursor_input]!

    """filter the rows returned"""
    where: request_type_bool_exp
  ): [request_type!]!

  """
  fetch data from the table: "service"
  """
  service(
    """distinct select on columns"""
    distinct_on: [service_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_order_by!]

    """filter the rows returned"""
    where: service_bool_exp
  ): [service!]!

  """
  fetch aggregated fields from the table: "service"
  """
  service_aggregate(
    """distinct select on columns"""
    distinct_on: [service_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_order_by!]

    """filter the rows returned"""
    where: service_bool_exp
  ): service_aggregate!

  """fetch data from the table: "service" using primary key columns"""
  service_by_pk(
    """L'identifiant unique du service."""
    id: Int!
  ): service

  """
  fetch data from the table: "service_modification"
  """
  service_modification(
    """distinct select on columns"""
    distinct_on: [service_modification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_modification_order_by!]

    """filter the rows returned"""
    where: service_modification_bool_exp
  ): [service_modification!]!

  """
  fetch aggregated fields from the table: "service_modification"
  """
  service_modification_aggregate(
    """distinct select on columns"""
    distinct_on: [service_modification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_modification_order_by!]

    """filter the rows returned"""
    where: service_modification_bool_exp
  ): service_modification_aggregate!

  """
  fetch data from the table: "service_modification" using primary key columns
  """
  service_modification_by_pk(
    """Unique identifier for the modification."""
    id: Int!
  ): service_modification

  """
  fetch data from the table in a streaming manner: "service_modification"
  """
  service_modification_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [service_modification_stream_cursor_input]!

    """filter the rows returned"""
    where: service_modification_bool_exp
  ): [service_modification!]!

  """
  fetch data from the table: "service_modification_type"
  """
  service_modification_type(
    """distinct select on columns"""
    distinct_on: [service_modification_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_modification_type_order_by!]

    """filter the rows returned"""
    where: service_modification_type_bool_exp
  ): [service_modification_type!]!

  """
  fetch aggregated fields from the table: "service_modification_type"
  """
  service_modification_type_aggregate(
    """distinct select on columns"""
    distinct_on: [service_modification_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_modification_type_order_by!]

    """filter the rows returned"""
    where: service_modification_type_bool_exp
  ): service_modification_type_aggregate!

  """
  fetch data from the table: "service_modification_type" using primary key columns
  """
  service_modification_type_by_pk(
    """Modification type (unique)."""
    value: String!
  ): service_modification_type

  """
  fetch data from the table in a streaming manner: "service_modification_type"
  """
  service_modification_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [service_modification_type_stream_cursor_input]!

    """filter the rows returned"""
    where: service_modification_type_bool_exp
  ): [service_modification_type!]!

  """
  fetch data from the table in a streaming manner: "service"
  """
  service_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [service_stream_cursor_input]!

    """filter the rows returned"""
    where: service_bool_exp
  ): [service!]!

  """
  fetch data from the table: "teacher"
  """
  teacher(
    """distinct select on columns"""
    distinct_on: [teacher_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teacher_order_by!]

    """filter the rows returned"""
    where: teacher_bool_exp
  ): [teacher!]!

  """
  fetch aggregated fields from the table: "teacher"
  """
  teacher_aggregate(
    """distinct select on columns"""
    distinct_on: [teacher_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teacher_order_by!]

    """filter the rows returned"""
    where: teacher_bool_exp
  ): teacher_aggregate!

  """fetch data from the table: "teacher" using primary key columns"""
  teacher_by_pk(
    """L'identifiant unique de l'intervenant."""
    uid: String!
  ): teacher

  """
  fetch data from the table in a streaming manner: "teacher"
  """
  teacher_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [teacher_stream_cursor_input]!

    """filter the rows returned"""
    where: teacher_bool_exp
  ): [teacher!]!

  """
  fetch data from the table: "track"
  """
  track(
    """distinct select on columns"""
    distinct_on: [track_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [track_order_by!]

    """filter the rows returned"""
    where: track_bool_exp
  ): [track!]!

  """
  fetch aggregated fields from the table: "track"
  """
  track_aggregate(
    """distinct select on columns"""
    distinct_on: [track_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [track_order_by!]

    """filter the rows returned"""
    where: track_bool_exp
  ): track_aggregate!

  """fetch data from the table: "track" using primary key columns"""
  track_by_pk(
    """L'identifiant unique du parcours."""
    id: Int!
  ): track

  """
  fetch data from the table in a streaming manner: "track"
  """
  track_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [track_stream_cursor_input]!

    """filter the rows returned"""
    where: track_bool_exp
  ): [track!]!

  """
  fetch data from the table: "year"
  """
  year(
    """distinct select on columns"""
    distinct_on: [year_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [year_order_by!]

    """filter the rows returned"""
    where: year_bool_exp
  ): [year!]!

  """
  fetch aggregated fields from the table: "year"
  """
  year_aggregate(
    """distinct select on columns"""
    distinct_on: [year_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [year_order_by!]

    """filter the rows returned"""
    where: year_bool_exp
  ): year_aggregate!

  """fetch data from the table: "year" using primary key columns"""
  year_by_pk(
    """Le numéro de l'année (unique)."""
    value: Int!
  ): year

  """
  fetch data from the table in a streaming manner: "year"
  """
  year_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [year_stream_cursor_input]!

    """filter the rows returned"""
    where: year_bool_exp
  ): [year!]!
}

"""Table contenant les intervenants."""
type teacher {
  """
  Indique si un service doit être automatiquement créé pour l'intervenant lors de la prochaine année.
  """
  active: Boolean!

  """
  Un alias pour l'intervenant à afficher à la place du nom et prénom (optionnel).
  """
  alias: String

  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  base_service_hours: Float

  """Le prénom de l'intervenant."""
  firstname: String!

  """Le nom de l'intervenant."""
  lastname: String!
  position: String

  """An object relationship"""
  positionByPosition: position

  """An array relationship"""
  responsibilities(
    """distinct select on columns"""
    distinct_on: [coordinator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coordinator_order_by!]

    """filter the rows returned"""
    where: coordinator_bool_exp
  ): [coordinator!]!

  """An aggregate relationship"""
  responsibilities_aggregate(
    """distinct select on columns"""
    distinct_on: [coordinator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coordinator_order_by!]

    """filter the rows returned"""
    where: coordinator_bool_exp
  ): coordinator_aggregate!

  """An array relationship"""
  services(
    """distinct select on columns"""
    distinct_on: [service_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_order_by!]

    """filter the rows returned"""
    where: service_bool_exp
  ): [service!]!

  """An aggregate relationship"""
  services_aggregate(
    """distinct select on columns"""
    distinct_on: [service_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_order_by!]

    """filter the rows returned"""
    where: service_bool_exp
  ): service_aggregate!

  """L'identifiant unique de l'intervenant."""
  uid: String!

  """Indique si l'intervenant est visible par les utilisateurs."""
  visible: Boolean!
}

"""
aggregated selection of "teacher"
"""
type teacher_aggregate {
  aggregate: teacher_aggregate_fields
  nodes: [teacher!]!
}

input teacher_aggregate_bool_exp {
  bool_and: teacher_aggregate_bool_exp_bool_and
  bool_or: teacher_aggregate_bool_exp_bool_or
  count: teacher_aggregate_bool_exp_count
}

input teacher_aggregate_bool_exp_bool_and {
  arguments: teacher_select_column_teacher_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: teacher_bool_exp
  predicate: Boolean_comparison_exp!
}

input teacher_aggregate_bool_exp_bool_or {
  arguments: teacher_select_column_teacher_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: teacher_bool_exp
  predicate: Boolean_comparison_exp!
}

input teacher_aggregate_bool_exp_count {
  arguments: [teacher_select_column!]
  distinct: Boolean
  filter: teacher_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "teacher"
"""
type teacher_aggregate_fields {
  avg: teacher_avg_fields
  count(columns: [teacher_select_column!], distinct: Boolean): Int!
  max: teacher_max_fields
  min: teacher_min_fields
  stddev: teacher_stddev_fields
  stddev_pop: teacher_stddev_pop_fields
  stddev_samp: teacher_stddev_samp_fields
  sum: teacher_sum_fields
  var_pop: teacher_var_pop_fields
  var_samp: teacher_var_samp_fields
  variance: teacher_variance_fields
}

"""
order by aggregate values of table "teacher"
"""
input teacher_aggregate_order_by {
  avg: teacher_avg_order_by
  count: order_by
  max: teacher_max_order_by
  min: teacher_min_order_by
  stddev: teacher_stddev_order_by
  stddev_pop: teacher_stddev_pop_order_by
  stddev_samp: teacher_stddev_samp_order_by
  sum: teacher_sum_order_by
  var_pop: teacher_var_pop_order_by
  var_samp: teacher_var_samp_order_by
  variance: teacher_variance_order_by
}

"""
input type for inserting array relation for remote table "teacher"
"""
input teacher_arr_rel_insert_input {
  data: [teacher_insert_input!]!

  """upsert condition"""
  on_conflict: teacher_on_conflict
}

"""aggregate avg on columns"""
type teacher_avg_fields {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  base_service_hours: Float
}

"""
order by avg() on columns of table "teacher"
"""
input teacher_avg_order_by {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  base_service_hours: order_by
}

"""
Boolean expression to filter rows from the table "teacher". All fields are combined with a logical 'AND'.
"""
input teacher_bool_exp {
  _and: [teacher_bool_exp!]
  _not: teacher_bool_exp
  _or: [teacher_bool_exp!]
  active: Boolean_comparison_exp
  alias: String_comparison_exp
  base_service_hours: Float_comparison_exp
  firstname: String_comparison_exp
  lastname: String_comparison_exp
  position: String_comparison_exp
  positionByPosition: position_bool_exp
  responsibilities: coordinator_bool_exp
  responsibilities_aggregate: coordinator_aggregate_bool_exp
  services: service_bool_exp
  services_aggregate: service_aggregate_bool_exp
  uid: String_comparison_exp
  visible: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "teacher"
"""
enum teacher_constraint {
  """
  unique or primary key constraint on columns "uid"
  """
  intervenant_pkey
}

"""
input type for incrementing numeric columns in table "teacher"
"""
input teacher_inc_input {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  base_service_hours: Float
}

"""
input type for inserting data into table "teacher"
"""
input teacher_insert_input {
  """
  Indique si un service doit être automatiquement créé pour l'intervenant lors de la prochaine année.
  """
  active: Boolean

  """
  Un alias pour l'intervenant à afficher à la place du nom et prénom (optionnel).
  """
  alias: String

  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  base_service_hours: Float

  """Le prénom de l'intervenant."""
  firstname: String

  """Le nom de l'intervenant."""
  lastname: String
  position: String
  positionByPosition: position_obj_rel_insert_input
  responsibilities: coordinator_arr_rel_insert_input
  services: service_arr_rel_insert_input

  """L'identifiant unique de l'intervenant."""
  uid: String

  """Indique si l'intervenant est visible par les utilisateurs."""
  visible: Boolean
}

"""aggregate max on columns"""
type teacher_max_fields {
  """
  Un alias pour l'intervenant à afficher à la place du nom et prénom (optionnel).
  """
  alias: String

  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  base_service_hours: Float

  """Le prénom de l'intervenant."""
  firstname: String

  """Le nom de l'intervenant."""
  lastname: String
  position: String

  """L'identifiant unique de l'intervenant."""
  uid: String
}

"""
order by max() on columns of table "teacher"
"""
input teacher_max_order_by {
  """
  Un alias pour l'intervenant à afficher à la place du nom et prénom (optionnel).
  """
  alias: order_by

  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  base_service_hours: order_by

  """Le prénom de l'intervenant."""
  firstname: order_by

  """Le nom de l'intervenant."""
  lastname: order_by
  position: order_by

  """L'identifiant unique de l'intervenant."""
  uid: order_by
}

"""aggregate min on columns"""
type teacher_min_fields {
  """
  Un alias pour l'intervenant à afficher à la place du nom et prénom (optionnel).
  """
  alias: String

  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  base_service_hours: Float

  """Le prénom de l'intervenant."""
  firstname: String

  """Le nom de l'intervenant."""
  lastname: String
  position: String

  """L'identifiant unique de l'intervenant."""
  uid: String
}

"""
order by min() on columns of table "teacher"
"""
input teacher_min_order_by {
  """
  Un alias pour l'intervenant à afficher à la place du nom et prénom (optionnel).
  """
  alias: order_by

  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  base_service_hours: order_by

  """Le prénom de l'intervenant."""
  firstname: order_by

  """Le nom de l'intervenant."""
  lastname: order_by
  position: order_by

  """L'identifiant unique de l'intervenant."""
  uid: order_by
}

"""
response of any mutation on the table "teacher"
"""
type teacher_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [teacher!]!
}

"""
input type for inserting object relation for remote table "teacher"
"""
input teacher_obj_rel_insert_input {
  data: teacher_insert_input!

  """upsert condition"""
  on_conflict: teacher_on_conflict
}

"""
on_conflict condition type for table "teacher"
"""
input teacher_on_conflict {
  constraint: teacher_constraint!
  update_columns: [teacher_update_column!]! = []
  where: teacher_bool_exp
}

"""Ordering options when selecting data from "teacher"."""
input teacher_order_by {
  active: order_by
  alias: order_by
  base_service_hours: order_by
  firstname: order_by
  lastname: order_by
  position: order_by
  positionByPosition: position_order_by
  responsibilities_aggregate: coordinator_aggregate_order_by
  services_aggregate: service_aggregate_order_by
  uid: order_by
  visible: order_by
}

"""primary key columns input for table: teacher"""
input teacher_pk_columns_input {
  """L'identifiant unique de l'intervenant."""
  uid: String!
}

"""
select columns of table "teacher"
"""
enum teacher_select_column {
  """column name"""
  active

  """column name"""
  alias

  """column name"""
  base_service_hours

  """column name"""
  firstname

  """column name"""
  lastname

  """column name"""
  position

  """column name"""
  uid

  """column name"""
  visible
}

"""
select "teacher_aggregate_bool_exp_bool_and_arguments_columns" columns of table "teacher"
"""
enum teacher_select_column_teacher_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  active

  """column name"""
  visible
}

"""
select "teacher_aggregate_bool_exp_bool_or_arguments_columns" columns of table "teacher"
"""
enum teacher_select_column_teacher_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  active

  """column name"""
  visible
}

"""
input type for updating data in table "teacher"
"""
input teacher_set_input {
  """
  Indique si un service doit être automatiquement créé pour l'intervenant lors de la prochaine année.
  """
  active: Boolean

  """
  Un alias pour l'intervenant à afficher à la place du nom et prénom (optionnel).
  """
  alias: String

  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  base_service_hours: Float

  """Le prénom de l'intervenant."""
  firstname: String

  """Le nom de l'intervenant."""
  lastname: String
  position: String

  """L'identifiant unique de l'intervenant."""
  uid: String

  """Indique si l'intervenant est visible par les utilisateurs."""
  visible: Boolean
}

"""aggregate stddev on columns"""
type teacher_stddev_fields {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  base_service_hours: Float
}

"""
order by stddev() on columns of table "teacher"
"""
input teacher_stddev_order_by {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  base_service_hours: order_by
}

"""aggregate stddev_pop on columns"""
type teacher_stddev_pop_fields {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  base_service_hours: Float
}

"""
order by stddev_pop() on columns of table "teacher"
"""
input teacher_stddev_pop_order_by {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  base_service_hours: order_by
}

"""aggregate stddev_samp on columns"""
type teacher_stddev_samp_fields {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  base_service_hours: Float
}

"""
order by stddev_samp() on columns of table "teacher"
"""
input teacher_stddev_samp_order_by {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  base_service_hours: order_by
}

"""
Streaming cursor of the table "teacher"
"""
input teacher_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: teacher_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input teacher_stream_cursor_value_input {
  """
  Indique si un service doit être automatiquement créé pour l'intervenant lors de la prochaine année.
  """
  active: Boolean

  """
  Un alias pour l'intervenant à afficher à la place du nom et prénom (optionnel).
  """
  alias: String

  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  base_service_hours: Float

  """Le prénom de l'intervenant."""
  firstname: String

  """Le nom de l'intervenant."""
  lastname: String
  position: String

  """L'identifiant unique de l'intervenant."""
  uid: String

  """Indique si l'intervenant est visible par les utilisateurs."""
  visible: Boolean
}

"""aggregate sum on columns"""
type teacher_sum_fields {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  base_service_hours: Float
}

"""
order by sum() on columns of table "teacher"
"""
input teacher_sum_order_by {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  base_service_hours: order_by
}

"""
update columns of table "teacher"
"""
enum teacher_update_column {
  """column name"""
  active

  """column name"""
  alias

  """column name"""
  base_service_hours

  """column name"""
  firstname

  """column name"""
  lastname

  """column name"""
  position

  """column name"""
  uid

  """column name"""
  visible
}

input teacher_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: teacher_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: teacher_set_input

  """filter the rows which have to be updated"""
  where: teacher_bool_exp!
}

"""aggregate var_pop on columns"""
type teacher_var_pop_fields {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  base_service_hours: Float
}

"""
order by var_pop() on columns of table "teacher"
"""
input teacher_var_pop_order_by {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  base_service_hours: order_by
}

"""aggregate var_samp on columns"""
type teacher_var_samp_fields {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  base_service_hours: Float
}

"""
order by var_samp() on columns of table "teacher"
"""
input teacher_var_samp_order_by {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  base_service_hours: order_by
}

"""aggregate variance on columns"""
type teacher_variance_fields {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  base_service_hours: Float
}

"""
order by variance() on columns of table "teacher"
"""
input teacher_variance_order_by {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  base_service_hours: order_by
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""Table contenant les différents parcours."""
type track {
  """An array relationship"""
  coordinators(
    """distinct select on columns"""
    distinct_on: [coordinator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coordinator_order_by!]

    """filter the rows returned"""
    where: coordinator_bool_exp
  ): [coordinator!]!

  """An aggregate relationship"""
  coordinators_aggregate(
    """distinct select on columns"""
    distinct_on: [coordinator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coordinator_order_by!]

    """filter the rows returned"""
    where: coordinator_bool_exp
  ): coordinator_aggregate!

  """An array relationship"""
  courses(
    """distinct select on columns"""
    distinct_on: [course_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_order_by!]

    """filter the rows returned"""
    where: course_bool_exp
  ): [course!]!

  """An aggregate relationship"""
  courses_aggregate(
    """distinct select on columns"""
    distinct_on: [course_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_order_by!]

    """filter the rows returned"""
    where: course_bool_exp
  ): course_aggregate!

  """L'identifiant unique du parcours."""
  id: Int!

  """Le nom du parcours (unique)."""
  name: String!

  """Le nom abrégé (optionnel)."""
  name_short: String
  nom_import: String

  """An object relationship"""
  program: program!
  program_id: Int!

  """Indique si le parcours correspondant est visible par les utilisateurs."""
  visible: Boolean!
}

"""
aggregated selection of "track"
"""
type track_aggregate {
  aggregate: track_aggregate_fields
  nodes: [track!]!
}

input track_aggregate_bool_exp {
  bool_and: track_aggregate_bool_exp_bool_and
  bool_or: track_aggregate_bool_exp_bool_or
  count: track_aggregate_bool_exp_count
}

input track_aggregate_bool_exp_bool_and {
  arguments: track_select_column_track_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: track_bool_exp
  predicate: Boolean_comparison_exp!
}

input track_aggregate_bool_exp_bool_or {
  arguments: track_select_column_track_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: track_bool_exp
  predicate: Boolean_comparison_exp!
}

input track_aggregate_bool_exp_count {
  arguments: [track_select_column!]
  distinct: Boolean
  filter: track_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "track"
"""
type track_aggregate_fields {
  avg: track_avg_fields
  count(columns: [track_select_column!], distinct: Boolean): Int!
  max: track_max_fields
  min: track_min_fields
  stddev: track_stddev_fields
  stddev_pop: track_stddev_pop_fields
  stddev_samp: track_stddev_samp_fields
  sum: track_sum_fields
  var_pop: track_var_pop_fields
  var_samp: track_var_samp_fields
  variance: track_variance_fields
}

"""
order by aggregate values of table "track"
"""
input track_aggregate_order_by {
  avg: track_avg_order_by
  count: order_by
  max: track_max_order_by
  min: track_min_order_by
  stddev: track_stddev_order_by
  stddev_pop: track_stddev_pop_order_by
  stddev_samp: track_stddev_samp_order_by
  sum: track_sum_order_by
  var_pop: track_var_pop_order_by
  var_samp: track_var_samp_order_by
  variance: track_variance_order_by
}

"""
input type for inserting array relation for remote table "track"
"""
input track_arr_rel_insert_input {
  data: [track_insert_input!]!

  """upsert condition"""
  on_conflict: track_on_conflict
}

"""aggregate avg on columns"""
type track_avg_fields {
  """L'identifiant unique du parcours."""
  id: Float
  program_id: Float
}

"""
order by avg() on columns of table "track"
"""
input track_avg_order_by {
  """L'identifiant unique du parcours."""
  id: order_by
  program_id: order_by
}

"""
Boolean expression to filter rows from the table "track". All fields are combined with a logical 'AND'.
"""
input track_bool_exp {
  _and: [track_bool_exp!]
  _not: track_bool_exp
  _or: [track_bool_exp!]
  coordinators: coordinator_bool_exp
  coordinators_aggregate: coordinator_aggregate_bool_exp
  courses: course_bool_exp
  courses_aggregate: course_aggregate_bool_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  name_short: String_comparison_exp
  nom_import: String_comparison_exp
  program: program_bool_exp
  program_id: Int_comparison_exp
  visible: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "track"
"""
enum track_constraint {
  """
  unique or primary key constraint on columns "program_id", "name"
  """
  parcours_mention_id_nom_key

  """
  unique or primary key constraint on columns "id"
  """
  parcours_pkey
}

"""
input type for incrementing numeric columns in table "track"
"""
input track_inc_input {
  """L'identifiant unique du parcours."""
  id: Int
  program_id: Int
}

"""
input type for inserting data into table "track"
"""
input track_insert_input {
  coordinators: coordinator_arr_rel_insert_input
  courses: course_arr_rel_insert_input

  """L'identifiant unique du parcours."""
  id: Int

  """Le nom du parcours (unique)."""
  name: String

  """Le nom abrégé (optionnel)."""
  name_short: String
  nom_import: String
  program: program_obj_rel_insert_input
  program_id: Int

  """Indique si le parcours correspondant est visible par les utilisateurs."""
  visible: Boolean
}

"""aggregate max on columns"""
type track_max_fields {
  """L'identifiant unique du parcours."""
  id: Int

  """Le nom du parcours (unique)."""
  name: String

  """Le nom abrégé (optionnel)."""
  name_short: String
  nom_import: String
  program_id: Int
}

"""
order by max() on columns of table "track"
"""
input track_max_order_by {
  """L'identifiant unique du parcours."""
  id: order_by

  """Le nom du parcours (unique)."""
  name: order_by

  """Le nom abrégé (optionnel)."""
  name_short: order_by
  nom_import: order_by
  program_id: order_by
}

"""aggregate min on columns"""
type track_min_fields {
  """L'identifiant unique du parcours."""
  id: Int

  """Le nom du parcours (unique)."""
  name: String

  """Le nom abrégé (optionnel)."""
  name_short: String
  nom_import: String
  program_id: Int
}

"""
order by min() on columns of table "track"
"""
input track_min_order_by {
  """L'identifiant unique du parcours."""
  id: order_by

  """Le nom du parcours (unique)."""
  name: order_by

  """Le nom abrégé (optionnel)."""
  name_short: order_by
  nom_import: order_by
  program_id: order_by
}

"""
response of any mutation on the table "track"
"""
type track_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [track!]!
}

"""
input type for inserting object relation for remote table "track"
"""
input track_obj_rel_insert_input {
  data: track_insert_input!

  """upsert condition"""
  on_conflict: track_on_conflict
}

"""
on_conflict condition type for table "track"
"""
input track_on_conflict {
  constraint: track_constraint!
  update_columns: [track_update_column!]! = []
  where: track_bool_exp
}

"""Ordering options when selecting data from "track"."""
input track_order_by {
  coordinators_aggregate: coordinator_aggregate_order_by
  courses_aggregate: course_aggregate_order_by
  id: order_by
  name: order_by
  name_short: order_by
  nom_import: order_by
  program: program_order_by
  program_id: order_by
  visible: order_by
}

"""primary key columns input for table: track"""
input track_pk_columns_input {
  """L'identifiant unique du parcours."""
  id: Int!
}

"""
select columns of table "track"
"""
enum track_select_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  name_short

  """column name"""
  nom_import

  """column name"""
  program_id

  """column name"""
  visible
}

"""
select "track_aggregate_bool_exp_bool_and_arguments_columns" columns of table "track"
"""
enum track_select_column_track_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  visible
}

"""
select "track_aggregate_bool_exp_bool_or_arguments_columns" columns of table "track"
"""
enum track_select_column_track_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  visible
}

"""
input type for updating data in table "track"
"""
input track_set_input {
  """L'identifiant unique du parcours."""
  id: Int

  """Le nom du parcours (unique)."""
  name: String

  """Le nom abrégé (optionnel)."""
  name_short: String
  nom_import: String
  program_id: Int

  """Indique si le parcours correspondant est visible par les utilisateurs."""
  visible: Boolean
}

"""aggregate stddev on columns"""
type track_stddev_fields {
  """L'identifiant unique du parcours."""
  id: Float
  program_id: Float
}

"""
order by stddev() on columns of table "track"
"""
input track_stddev_order_by {
  """L'identifiant unique du parcours."""
  id: order_by
  program_id: order_by
}

"""aggregate stddev_pop on columns"""
type track_stddev_pop_fields {
  """L'identifiant unique du parcours."""
  id: Float
  program_id: Float
}

"""
order by stddev_pop() on columns of table "track"
"""
input track_stddev_pop_order_by {
  """L'identifiant unique du parcours."""
  id: order_by
  program_id: order_by
}

"""aggregate stddev_samp on columns"""
type track_stddev_samp_fields {
  """L'identifiant unique du parcours."""
  id: Float
  program_id: Float
}

"""
order by stddev_samp() on columns of table "track"
"""
input track_stddev_samp_order_by {
  """L'identifiant unique du parcours."""
  id: order_by
  program_id: order_by
}

"""
Streaming cursor of the table "track"
"""
input track_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: track_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input track_stream_cursor_value_input {
  """L'identifiant unique du parcours."""
  id: Int

  """Le nom du parcours (unique)."""
  name: String

  """Le nom abrégé (optionnel)."""
  name_short: String
  nom_import: String
  program_id: Int

  """Indique si le parcours correspondant est visible par les utilisateurs."""
  visible: Boolean
}

"""aggregate sum on columns"""
type track_sum_fields {
  """L'identifiant unique du parcours."""
  id: Int
  program_id: Int
}

"""
order by sum() on columns of table "track"
"""
input track_sum_order_by {
  """L'identifiant unique du parcours."""
  id: order_by
  program_id: order_by
}

"""
update columns of table "track"
"""
enum track_update_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  name_short

  """column name"""
  nom_import

  """column name"""
  program_id

  """column name"""
  visible
}

input track_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: track_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: track_set_input

  """filter the rows which have to be updated"""
  where: track_bool_exp!
}

"""aggregate var_pop on columns"""
type track_var_pop_fields {
  """L'identifiant unique du parcours."""
  id: Float
  program_id: Float
}

"""
order by var_pop() on columns of table "track"
"""
input track_var_pop_order_by {
  """L'identifiant unique du parcours."""
  id: order_by
  program_id: order_by
}

"""aggregate var_samp on columns"""
type track_var_samp_fields {
  """L'identifiant unique du parcours."""
  id: Float
  program_id: Float
}

"""
order by var_samp() on columns of table "track"
"""
input track_var_samp_order_by {
  """L'identifiant unique du parcours."""
  id: order_by
  program_id: order_by
}

"""aggregate variance on columns"""
type track_variance_fields {
  """L'identifiant unique du parcours."""
  id: Float
  program_id: Float
}

"""
order by variance() on columns of table "track"
"""
input track_variance_order_by {
  """L'identifiant unique du parcours."""
  id: order_by
  program_id: order_by
}

"""Table contenant les différentes années."""
type year {
  """An array relationship"""
  courses(
    """distinct select on columns"""
    distinct_on: [course_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_order_by!]

    """filter the rows returned"""
    where: course_bool_exp
  ): [course!]!

  """An aggregate relationship"""
  courses_aggregate(
    """distinct select on columns"""
    distinct_on: [course_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_order_by!]

    """filter the rows returned"""
    where: course_bool_exp
  ): course_aggregate!

  """
  Indique si l'année correspondante est l'année en cours (TRUE) ou non (NULL). Une seule année peut être en cours à la fois.
  """
  current: Boolean

  """An array relationship"""
  services(
    """distinct select on columns"""
    distinct_on: [service_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_order_by!]

    """filter the rows returned"""
    where: service_bool_exp
  ): [service!]!

  """An aggregate relationship"""
  services_aggregate(
    """distinct select on columns"""
    distinct_on: [service_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_order_by!]

    """filter the rows returned"""
    where: service_bool_exp
  ): service_aggregate!

  """Le numéro de l'année (unique)."""
  value: Int!

  """Indique si l'année correspondante est visible par les utilisateurs."""
  visible: Boolean!
}

"""
aggregated selection of "year"
"""
type year_aggregate {
  aggregate: year_aggregate_fields
  nodes: [year!]!
}

"""
aggregate fields of "year"
"""
type year_aggregate_fields {
  avg: year_avg_fields
  count(columns: [year_select_column!], distinct: Boolean): Int!
  max: year_max_fields
  min: year_min_fields
  stddev: year_stddev_fields
  stddev_pop: year_stddev_pop_fields
  stddev_samp: year_stddev_samp_fields
  sum: year_sum_fields
  var_pop: year_var_pop_fields
  var_samp: year_var_samp_fields
  variance: year_variance_fields
}

"""aggregate avg on columns"""
type year_avg_fields {
  """Le numéro de l'année (unique)."""
  value: Float
}

"""
Boolean expression to filter rows from the table "year". All fields are combined with a logical 'AND'.
"""
input year_bool_exp {
  _and: [year_bool_exp!]
  _not: year_bool_exp
  _or: [year_bool_exp!]
  courses: course_bool_exp
  courses_aggregate: course_aggregate_bool_exp
  current: Boolean_comparison_exp
  services: service_bool_exp
  services_aggregate: service_aggregate_bool_exp
  value: Int_comparison_exp
  visible: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "year"
"""
enum year_constraint {
  """
  unique or primary key constraint on columns "current"
  """
  annee_en_cours_key

  """
  unique or primary key constraint on columns "value"
  """
  annee_pkey
}

"""
input type for incrementing numeric columns in table "year"
"""
input year_inc_input {
  """Le numéro de l'année (unique)."""
  value: Int
}

"""
input type for inserting data into table "year"
"""
input year_insert_input {
  courses: course_arr_rel_insert_input

  """
  Indique si l'année correspondante est l'année en cours (TRUE) ou non (NULL). Une seule année peut être en cours à la fois.
  """
  current: Boolean
  services: service_arr_rel_insert_input

  """Le numéro de l'année (unique)."""
  value: Int

  """Indique si l'année correspondante est visible par les utilisateurs."""
  visible: Boolean
}

"""aggregate max on columns"""
type year_max_fields {
  """Le numéro de l'année (unique)."""
  value: Int
}

"""aggregate min on columns"""
type year_min_fields {
  """Le numéro de l'année (unique)."""
  value: Int
}

"""
response of any mutation on the table "year"
"""
type year_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [year!]!
}

"""
input type for inserting object relation for remote table "year"
"""
input year_obj_rel_insert_input {
  data: year_insert_input!

  """upsert condition"""
  on_conflict: year_on_conflict
}

"""
on_conflict condition type for table "year"
"""
input year_on_conflict {
  constraint: year_constraint!
  update_columns: [year_update_column!]! = []
  where: year_bool_exp
}

"""Ordering options when selecting data from "year"."""
input year_order_by {
  courses_aggregate: course_aggregate_order_by
  current: order_by
  services_aggregate: service_aggregate_order_by
  value: order_by
  visible: order_by
}

"""primary key columns input for table: year"""
input year_pk_columns_input {
  """Le numéro de l'année (unique)."""
  value: Int!
}

"""
select columns of table "year"
"""
enum year_select_column {
  """column name"""
  current

  """column name"""
  value

  """column name"""
  visible
}

"""
input type for updating data in table "year"
"""
input year_set_input {
  """
  Indique si l'année correspondante est l'année en cours (TRUE) ou non (NULL). Une seule année peut être en cours à la fois.
  """
  current: Boolean

  """Le numéro de l'année (unique)."""
  value: Int

  """Indique si l'année correspondante est visible par les utilisateurs."""
  visible: Boolean
}

"""aggregate stddev on columns"""
type year_stddev_fields {
  """Le numéro de l'année (unique)."""
  value: Float
}

"""aggregate stddev_pop on columns"""
type year_stddev_pop_fields {
  """Le numéro de l'année (unique)."""
  value: Float
}

"""aggregate stddev_samp on columns"""
type year_stddev_samp_fields {
  """Le numéro de l'année (unique)."""
  value: Float
}

"""
Streaming cursor of the table "year"
"""
input year_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: year_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input year_stream_cursor_value_input {
  """
  Indique si l'année correspondante est l'année en cours (TRUE) ou non (NULL). Une seule année peut être en cours à la fois.
  """
  current: Boolean

  """Le numéro de l'année (unique)."""
  value: Int

  """Indique si l'année correspondante est visible par les utilisateurs."""
  visible: Boolean
}

"""aggregate sum on columns"""
type year_sum_fields {
  """Le numéro de l'année (unique)."""
  value: Int
}

"""
update columns of table "year"
"""
enum year_update_column {
  """column name"""
  current

  """column name"""
  value

  """column name"""
  visible
}

input year_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: year_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: year_set_input

  """filter the rows which have to be updated"""
  where: year_bool_exp!
}

"""aggregate var_pop on columns"""
type year_var_pop_fields {
  """Le numéro de l'année (unique)."""
  value: Float
}

"""aggregate var_samp on columns"""
type year_var_samp_fields {
  """Le numéro de l'année (unique)."""
  value: Float
}

"""aggregate variance on columns"""
type year_variance_fields {
  """Le numéro de l'année (unique)."""
  value: Float
}