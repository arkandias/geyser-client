schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""
whether this query should be cached (Hasura Cloud only)
"""
directive @cached(
  """
  refresh the cache entry
  """
  refresh: Boolean! = false

  """
  measured in seconds
  """
  ttl: Int! = 60
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Float". All fields are combined with logical 'AND'.
"""
input Float_comparison_exp {
  _eq: Float
  _gt: Float
  _gte: Float
  _in: [Float!]
  _is_null: Boolean
  _lt: Float
  _lte: Float
  _neq: Float
  _nin: [Float!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """
  does the column match the given case-insensitive pattern
  """
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """
  does the column match the given pattern
  """
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """
  does the column NOT match the given case-insensitive pattern
  """
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """
  does the column NOT match the given pattern
  """
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """
  does the column NOT match the given SQL regular expression
  """
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """
  does the column match the given SQL regular expression
  """
  _similar: String
}

"""
ordering argument of a cursor
"""
enum cursor_ordering {
  """
  ascending ordering of the cursor
  """
  ASC

  """
  descending ordering of the cursor
  """
  DESC
}

"""
Table contenant les différentes années.
"""
type ec_annee {
  """
  Indique si l'année correspondante est l'année en cours (TRUE) ou non (NULL). Une seule année peut être en cours à la fois.
  """
  en_cours: Boolean

  """
  An array relationship
  """
  enseignements(
    """
    distinct select on columns
    """
    distinct_on: [ec_enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_enseignement_order_by!]

    """
    filter the rows returned
    """
    where: ec_enseignement_bool_exp
  ): [ec_enseignement!]!

  """
  An aggregate relationship
  """
  enseignements_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_enseignement_order_by!]

    """
    filter the rows returned
    """
    where: ec_enseignement_bool_exp
  ): ec_enseignement_aggregate!

  """
  An array relationship
  """
  messages(
    """
    distinct select on columns
    """
    distinct_on: [ec_message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_message_order_by!]

    """
    filter the rows returned
    """
    where: ec_message_bool_exp
  ): [ec_message!]!

  """
  An aggregate relationship
  """
  messages_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_message_order_by!]

    """
    filter the rows returned
    """
    where: ec_message_bool_exp
  ): ec_message_aggregate!

  """
  An array relationship
  """
  modifications_service(
    """
    distinct select on columns
    """
    distinct_on: [ec_modification_service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_modification_service_order_by!]

    """
    filter the rows returned
    """
    where: ec_modification_service_bool_exp
  ): [ec_modification_service!]!

  """
  An aggregate relationship
  """
  modifications_service_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_modification_service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_modification_service_order_by!]

    """
    filter the rows returned
    """
    where: ec_modification_service_bool_exp
  ): ec_modification_service_aggregate!

  """
  An array relationship
  """
  services(
    """
    distinct select on columns
    """
    distinct_on: [ec_service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_service_order_by!]

    """
    filter the rows returned
    """
    where: ec_service_bool_exp
  ): [ec_service!]!

  """
  An aggregate relationship
  """
  services_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_service_order_by!]

    """
    filter the rows returned
    """
    where: ec_service_bool_exp
  ): ec_service_aggregate!

  """
  Le numéro de l'année (unique).
  """
  value: Int!

  """
  Indique si l'année correspondante est visible par les utilisateurs.
  """
  visible: Boolean!
}

"""
aggregated selection of "ec.annee"
"""
type ec_annee_aggregate {
  aggregate: ec_annee_aggregate_fields
  nodes: [ec_annee!]!
}

"""
aggregate fields of "ec.annee"
"""
type ec_annee_aggregate_fields {
  avg: ec_annee_avg_fields
  count(columns: [ec_annee_select_column!], distinct: Boolean): Int!
  max: ec_annee_max_fields
  min: ec_annee_min_fields
  stddev: ec_annee_stddev_fields
  stddev_pop: ec_annee_stddev_pop_fields
  stddev_samp: ec_annee_stddev_samp_fields
  sum: ec_annee_sum_fields
  var_pop: ec_annee_var_pop_fields
  var_samp: ec_annee_var_samp_fields
  variance: ec_annee_variance_fields
}

"""
aggregate avg on columns
"""
type ec_annee_avg_fields {
  """
  Le numéro de l'année (unique).
  """
  value: Float
}

"""
Boolean expression to filter rows from the table "ec.annee". All fields are combined with a logical 'AND'.
"""
input ec_annee_bool_exp {
  _and: [ec_annee_bool_exp!]
  _not: ec_annee_bool_exp
  _or: [ec_annee_bool_exp!]
  en_cours: Boolean_comparison_exp
  enseignements: ec_enseignement_bool_exp
  enseignements_aggregate: ec_enseignement_aggregate_bool_exp
  messages: ec_message_bool_exp
  messages_aggregate: ec_message_aggregate_bool_exp
  modifications_service: ec_modification_service_bool_exp
  modifications_service_aggregate: ec_modification_service_aggregate_bool_exp
  services: ec_service_bool_exp
  services_aggregate: ec_service_aggregate_bool_exp
  value: Int_comparison_exp
  visible: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "ec.annee"
"""
enum ec_annee_constraint {
  """
  unique or primary key constraint on columns "en_cours"
  """
  annee_en_cours_key

  """
  unique or primary key constraint on columns "value"
  """
  annee_pkey
}

"""
input type for incrementing numeric columns in table "ec.annee"
"""
input ec_annee_inc_input {
  """
  Le numéro de l'année (unique).
  """
  value: Int
}

"""
input type for inserting data into table "ec.annee"
"""
input ec_annee_insert_input {
  """
  Indique si l'année correspondante est l'année en cours (TRUE) ou non (NULL). Une seule année peut être en cours à la fois.
  """
  en_cours: Boolean
  enseignements: ec_enseignement_arr_rel_insert_input
  messages: ec_message_arr_rel_insert_input
  modifications_service: ec_modification_service_arr_rel_insert_input
  services: ec_service_arr_rel_insert_input

  """
  Le numéro de l'année (unique).
  """
  value: Int

  """
  Indique si l'année correspondante est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate max on columns
"""
type ec_annee_max_fields {
  """
  Le numéro de l'année (unique).
  """
  value: Int
}

"""
aggregate min on columns
"""
type ec_annee_min_fields {
  """
  Le numéro de l'année (unique).
  """
  value: Int
}

"""
response of any mutation on the table "ec.annee"
"""
type ec_annee_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [ec_annee!]!
}

"""
input type for inserting object relation for remote table "ec.annee"
"""
input ec_annee_obj_rel_insert_input {
  data: ec_annee_insert_input!

  """
  upsert condition
  """
  on_conflict: ec_annee_on_conflict
}

"""
on_conflict condition type for table "ec.annee"
"""
input ec_annee_on_conflict {
  constraint: ec_annee_constraint!
  update_columns: [ec_annee_update_column!]! = []
  where: ec_annee_bool_exp
}

"""
Ordering options when selecting data from "ec.annee".
"""
input ec_annee_order_by {
  en_cours: order_by
  enseignements_aggregate: ec_enseignement_aggregate_order_by
  messages_aggregate: ec_message_aggregate_order_by
  modifications_service_aggregate: ec_modification_service_aggregate_order_by
  services_aggregate: ec_service_aggregate_order_by
  value: order_by
  visible: order_by
}

"""
primary key columns input for table: ec.annee
"""
input ec_annee_pk_columns_input {
  """
  Le numéro de l'année (unique).
  """
  value: Int!
}

"""
select columns of table "ec.annee"
"""
enum ec_annee_select_column {
  """
  column name
  """
  en_cours

  """
  column name
  """
  value

  """
  column name
  """
  visible
}

"""
input type for updating data in table "ec.annee"
"""
input ec_annee_set_input {
  """
  Indique si l'année correspondante est l'année en cours (TRUE) ou non (NULL). Une seule année peut être en cours à la fois.
  """
  en_cours: Boolean

  """
  Le numéro de l'année (unique).
  """
  value: Int

  """
  Indique si l'année correspondante est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate stddev on columns
"""
type ec_annee_stddev_fields {
  """
  Le numéro de l'année (unique).
  """
  value: Float
}

"""
aggregate stddev_pop on columns
"""
type ec_annee_stddev_pop_fields {
  """
  Le numéro de l'année (unique).
  """
  value: Float
}

"""
aggregate stddev_samp on columns
"""
type ec_annee_stddev_samp_fields {
  """
  Le numéro de l'année (unique).
  """
  value: Float
}

"""
Streaming cursor of the table "ec_annee"
"""
input ec_annee_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: ec_annee_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input ec_annee_stream_cursor_value_input {
  """
  Indique si l'année correspondante est l'année en cours (TRUE) ou non (NULL). Une seule année peut être en cours à la fois.
  """
  en_cours: Boolean

  """
  Le numéro de l'année (unique).
  """
  value: Int

  """
  Indique si l'année correspondante est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate sum on columns
"""
type ec_annee_sum_fields {
  """
  Le numéro de l'année (unique).
  """
  value: Int
}

"""
update columns of table "ec.annee"
"""
enum ec_annee_update_column {
  """
  column name
  """
  en_cours

  """
  column name
  """
  value

  """
  column name
  """
  visible
}

input ec_annee_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: ec_annee_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: ec_annee_set_input

  """
  filter the rows which have to be updated
  """
  where: ec_annee_bool_exp!
}

"""
aggregate var_pop on columns
"""
type ec_annee_var_pop_fields {
  """
  Le numéro de l'année (unique).
  """
  value: Float
}

"""
aggregate var_samp on columns
"""
type ec_annee_var_samp_fields {
  """
  Le numéro de l'année (unique).
  """
  value: Float
}

"""
aggregate variance on columns
"""
type ec_annee_variance_fields {
  """
  Le numéro de l'année (unique).
  """
  value: Float
}

"""
Table contenant les différents cursus (licence, master, etc.).
"""
type ec_cursus {
  """
  L'identifiant unique du cursus.
  """
  id: Int!

  """
  An array relationship
  """
  mentions(
    """
    distinct select on columns
    """
    distinct_on: [ec_mention_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_mention_order_by!]

    """
    filter the rows returned
    """
    where: ec_mention_bool_exp
  ): [ec_mention!]!

  """
  An aggregate relationship
  """
  mentions_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_mention_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_mention_order_by!]

    """
    filter the rows returned
    """
    where: ec_mention_bool_exp
  ): ec_mention_aggregate!

  """
  Le nom du cursus (unique).
  """
  nom: String!

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String

  """
  Indique si le cursus correspondant est visible par les utilisateurs.
  """
  visible: Boolean!
}

"""
aggregated selection of "ec.cursus"
"""
type ec_cursus_aggregate {
  aggregate: ec_cursus_aggregate_fields
  nodes: [ec_cursus!]!
}

"""
aggregate fields of "ec.cursus"
"""
type ec_cursus_aggregate_fields {
  avg: ec_cursus_avg_fields
  count(columns: [ec_cursus_select_column!], distinct: Boolean): Int!
  max: ec_cursus_max_fields
  min: ec_cursus_min_fields
  stddev: ec_cursus_stddev_fields
  stddev_pop: ec_cursus_stddev_pop_fields
  stddev_samp: ec_cursus_stddev_samp_fields
  sum: ec_cursus_sum_fields
  var_pop: ec_cursus_var_pop_fields
  var_samp: ec_cursus_var_samp_fields
  variance: ec_cursus_variance_fields
}

"""
aggregate avg on columns
"""
type ec_cursus_avg_fields {
  """
  L'identifiant unique du cursus.
  """
  id: Float
}

"""
Boolean expression to filter rows from the table "ec.cursus". All fields are combined with a logical 'AND'.
"""
input ec_cursus_bool_exp {
  _and: [ec_cursus_bool_exp!]
  _not: ec_cursus_bool_exp
  _or: [ec_cursus_bool_exp!]
  id: Int_comparison_exp
  mentions: ec_mention_bool_exp
  mentions_aggregate: ec_mention_aggregate_bool_exp
  nom: String_comparison_exp
  nom_court: String_comparison_exp
  visible: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "ec.cursus"
"""
enum ec_cursus_constraint {
  """
  unique or primary key constraint on columns "nom"
  """
  cursus_nom_key

  """
  unique or primary key constraint on columns "id"
  """
  cursus_pkey
}

"""
input type for incrementing numeric columns in table "ec.cursus"
"""
input ec_cursus_inc_input {
  """
  L'identifiant unique du cursus.
  """
  id: Int
}

"""
input type for inserting data into table "ec.cursus"
"""
input ec_cursus_insert_input {
  """
  L'identifiant unique du cursus.
  """
  id: Int
  mentions: ec_mention_arr_rel_insert_input

  """
  Le nom du cursus (unique).
  """
  nom: String

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String

  """
  Indique si le cursus correspondant est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate max on columns
"""
type ec_cursus_max_fields {
  """
  L'identifiant unique du cursus.
  """
  id: Int

  """
  Le nom du cursus (unique).
  """
  nom: String

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String
}

"""
aggregate min on columns
"""
type ec_cursus_min_fields {
  """
  L'identifiant unique du cursus.
  """
  id: Int

  """
  Le nom du cursus (unique).
  """
  nom: String

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String
}

"""
response of any mutation on the table "ec.cursus"
"""
type ec_cursus_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [ec_cursus!]!
}

"""
input type for inserting object relation for remote table "ec.cursus"
"""
input ec_cursus_obj_rel_insert_input {
  data: ec_cursus_insert_input!

  """
  upsert condition
  """
  on_conflict: ec_cursus_on_conflict
}

"""
on_conflict condition type for table "ec.cursus"
"""
input ec_cursus_on_conflict {
  constraint: ec_cursus_constraint!
  update_columns: [ec_cursus_update_column!]! = []
  where: ec_cursus_bool_exp
}

"""
Ordering options when selecting data from "ec.cursus".
"""
input ec_cursus_order_by {
  id: order_by
  mentions_aggregate: ec_mention_aggregate_order_by
  nom: order_by
  nom_court: order_by
  visible: order_by
}

"""
primary key columns input for table: ec.cursus
"""
input ec_cursus_pk_columns_input {
  """
  L'identifiant unique du cursus.
  """
  id: Int!
}

"""
select columns of table "ec.cursus"
"""
enum ec_cursus_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  nom

  """
  column name
  """
  nom_court

  """
  column name
  """
  visible
}

"""
input type for updating data in table "ec.cursus"
"""
input ec_cursus_set_input {
  """
  L'identifiant unique du cursus.
  """
  id: Int

  """
  Le nom du cursus (unique).
  """
  nom: String

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String

  """
  Indique si le cursus correspondant est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate stddev on columns
"""
type ec_cursus_stddev_fields {
  """
  L'identifiant unique du cursus.
  """
  id: Float
}

"""
aggregate stddev_pop on columns
"""
type ec_cursus_stddev_pop_fields {
  """
  L'identifiant unique du cursus.
  """
  id: Float
}

"""
aggregate stddev_samp on columns
"""
type ec_cursus_stddev_samp_fields {
  """
  L'identifiant unique du cursus.
  """
  id: Float
}

"""
Streaming cursor of the table "ec_cursus"
"""
input ec_cursus_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: ec_cursus_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input ec_cursus_stream_cursor_value_input {
  """
  L'identifiant unique du cursus.
  """
  id: Int

  """
  Le nom du cursus (unique).
  """
  nom: String

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String

  """
  Indique si le cursus correspondant est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate sum on columns
"""
type ec_cursus_sum_fields {
  """
  L'identifiant unique du cursus.
  """
  id: Int
}

"""
update columns of table "ec.cursus"
"""
enum ec_cursus_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  nom

  """
  column name
  """
  nom_court

  """
  column name
  """
  visible
}

input ec_cursus_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: ec_cursus_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: ec_cursus_set_input

  """
  filter the rows which have to be updated
  """
  where: ec_cursus_bool_exp!
}

"""
aggregate var_pop on columns
"""
type ec_cursus_var_pop_fields {
  """
  L'identifiant unique du cursus.
  """
  id: Float
}

"""
aggregate var_samp on columns
"""
type ec_cursus_var_samp_fields {
  """
  L'identifiant unique du cursus.
  """
  id: Float
}

"""
aggregate variance on columns
"""
type ec_cursus_variance_fields {
  """
  L'identifiant unique du cursus.
  """
  id: Float
}

"""
Table contenant les demandes.
"""
type ec_demande {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: Int!

  """
  An object relationship
  """
  enseignement: ec_enseignement!

  """
  Le nombre d'heures demandées.
  """
  heures: Float!

  """
  Fonction qui renvoie, pour une demande donnée, le nombre d'heures EQTD correspondant en utilisant le coefficient multiplicateur du type d'enseignement correspondant.
  """
  heures_eqtd: Float
  id: Int!

  """
  An object relationship
  """
  intervenant: ec_intervenant!

  """
  Fonction qui indique, pour une demande donnée, si celle-ci est prioritaire.
  """
  prioritaire: Boolean

  """
  Le type de demande.
  """
  type: String!

  """
  An object relationship
  """
  type_demande: ec_type_demande!

  """
  L'identifiant de l'intervenant correspondant à la demande.
  """
  uid: String!
}

"""
aggregated selection of "ec.demande"
"""
type ec_demande_aggregate {
  aggregate: ec_demande_aggregate_fields
  nodes: [ec_demande!]!
}

input ec_demande_aggregate_bool_exp {
  count: ec_demande_aggregate_bool_exp_count
}

input ec_demande_aggregate_bool_exp_count {
  arguments: [ec_demande_select_column!]
  distinct: Boolean
  filter: ec_demande_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "ec.demande"
"""
type ec_demande_aggregate_fields {
  avg: ec_demande_avg_fields
  count(columns: [ec_demande_select_column!], distinct: Boolean): Int!
  max: ec_demande_max_fields
  min: ec_demande_min_fields
  stddev: ec_demande_stddev_fields
  stddev_pop: ec_demande_stddev_pop_fields
  stddev_samp: ec_demande_stddev_samp_fields
  sum: ec_demande_sum_fields
  var_pop: ec_demande_var_pop_fields
  var_samp: ec_demande_var_samp_fields
  variance: ec_demande_variance_fields
}

"""
order by aggregate values of table "ec.demande"
"""
input ec_demande_aggregate_order_by {
  avg: ec_demande_avg_order_by
  count: order_by
  max: ec_demande_max_order_by
  min: ec_demande_min_order_by
  stddev: ec_demande_stddev_order_by
  stddev_pop: ec_demande_stddev_pop_order_by
  stddev_samp: ec_demande_stddev_samp_order_by
  sum: ec_demande_sum_order_by
  var_pop: ec_demande_var_pop_order_by
  var_samp: ec_demande_var_samp_order_by
  variance: ec_demande_variance_order_by
}

"""
input type for inserting array relation for remote table "ec.demande"
"""
input ec_demande_arr_rel_insert_input {
  data: [ec_demande_insert_input!]!

  """
  upsert condition
  """
  on_conflict: ec_demande_on_conflict
}

"""
aggregate avg on columns
"""
type ec_demande_avg_fields {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: Float

  """
  Le nombre d'heures demandées.
  """
  heures: Float

  """
  Fonction qui renvoie, pour une demande donnée, le nombre d'heures EQTD correspondant en utilisant le coefficient multiplicateur du type d'enseignement correspondant.
  """
  heures_eqtd: Float
  id: Float
}

"""
order by avg() on columns of table "ec.demande"
"""
input ec_demande_avg_order_by {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: order_by

  """
  Le nombre d'heures demandées.
  """
  heures: order_by
  id: order_by
}

"""
Boolean expression to filter rows from the table "ec.demande". All fields are combined with a logical 'AND'.
"""
input ec_demande_bool_exp {
  _and: [ec_demande_bool_exp!]
  _not: ec_demande_bool_exp
  _or: [ec_demande_bool_exp!]
  ens_id: Int_comparison_exp
  enseignement: ec_enseignement_bool_exp
  heures: Float_comparison_exp
  heures_eqtd: Float_comparison_exp
  id: Int_comparison_exp
  intervenant: ec_intervenant_bool_exp
  prioritaire: Boolean_comparison_exp
  type: String_comparison_exp
  type_demande: ec_type_demande_bool_exp
  uid: String_comparison_exp
}

"""
unique or primary key constraints on table "ec.demande"
"""
enum ec_demande_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  demande_pkey

  """
  unique or primary key constraint on columns "uid", "type", "ens_id"
  """
  demande_uid_ens_id_type_key
}

"""
input type for incrementing numeric columns in table "ec.demande"
"""
input ec_demande_inc_input {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: Int

  """
  Le nombre d'heures demandées.
  """
  heures: Float
  id: Int
}

"""
input type for inserting data into table "ec.demande"
"""
input ec_demande_insert_input {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: Int
  enseignement: ec_enseignement_obj_rel_insert_input

  """
  Le nombre d'heures demandées.
  """
  heures: Float
  id: Int
  intervenant: ec_intervenant_obj_rel_insert_input

  """
  Le type de demande.
  """
  type: String
  type_demande: ec_type_demande_obj_rel_insert_input

  """
  L'identifiant de l'intervenant correspondant à la demande.
  """
  uid: String
}

"""
aggregate max on columns
"""
type ec_demande_max_fields {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: Int

  """
  Le nombre d'heures demandées.
  """
  heures: Float

  """
  Fonction qui renvoie, pour une demande donnée, le nombre d'heures EQTD correspondant en utilisant le coefficient multiplicateur du type d'enseignement correspondant.
  """
  heures_eqtd: Float
  id: Int

  """
  Le type de demande.
  """
  type: String

  """
  L'identifiant de l'intervenant correspondant à la demande.
  """
  uid: String
}

"""
order by max() on columns of table "ec.demande"
"""
input ec_demande_max_order_by {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: order_by

  """
  Le nombre d'heures demandées.
  """
  heures: order_by
  id: order_by

  """
  Le type de demande.
  """
  type: order_by

  """
  L'identifiant de l'intervenant correspondant à la demande.
  """
  uid: order_by
}

"""
aggregate min on columns
"""
type ec_demande_min_fields {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: Int

  """
  Le nombre d'heures demandées.
  """
  heures: Float

  """
  Fonction qui renvoie, pour une demande donnée, le nombre d'heures EQTD correspondant en utilisant le coefficient multiplicateur du type d'enseignement correspondant.
  """
  heures_eqtd: Float
  id: Int

  """
  Le type de demande.
  """
  type: String

  """
  L'identifiant de l'intervenant correspondant à la demande.
  """
  uid: String
}

"""
order by min() on columns of table "ec.demande"
"""
input ec_demande_min_order_by {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: order_by

  """
  Le nombre d'heures demandées.
  """
  heures: order_by
  id: order_by

  """
  Le type de demande.
  """
  type: order_by

  """
  L'identifiant de l'intervenant correspondant à la demande.
  """
  uid: order_by
}

"""
response of any mutation on the table "ec.demande"
"""
type ec_demande_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [ec_demande!]!
}

"""
on_conflict condition type for table "ec.demande"
"""
input ec_demande_on_conflict {
  constraint: ec_demande_constraint!
  update_columns: [ec_demande_update_column!]! = []
  where: ec_demande_bool_exp
}

"""
Ordering options when selecting data from "ec.demande".
"""
input ec_demande_order_by {
  ens_id: order_by
  enseignement: ec_enseignement_order_by
  heures: order_by
  heures_eqtd: order_by
  id: order_by
  intervenant: ec_intervenant_order_by
  prioritaire: order_by
  type: order_by
  type_demande: ec_type_demande_order_by
  uid: order_by
}

"""
primary key columns input for table: ec.demande
"""
input ec_demande_pk_columns_input {
  id: Int!
}

"""
select columns of table "ec.demande"
"""
enum ec_demande_select_column {
  """
  column name
  """
  ens_id

  """
  column name
  """
  heures

  """
  column name
  """
  id

  """
  column name
  """
  type

  """
  column name
  """
  uid
}

"""
input type for updating data in table "ec.demande"
"""
input ec_demande_set_input {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: Int

  """
  Le nombre d'heures demandées.
  """
  heures: Float
  id: Int

  """
  Le type de demande.
  """
  type: String

  """
  L'identifiant de l'intervenant correspondant à la demande.
  """
  uid: String
}

"""
aggregate stddev on columns
"""
type ec_demande_stddev_fields {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: Float

  """
  Le nombre d'heures demandées.
  """
  heures: Float

  """
  Fonction qui renvoie, pour une demande donnée, le nombre d'heures EQTD correspondant en utilisant le coefficient multiplicateur du type d'enseignement correspondant.
  """
  heures_eqtd: Float
  id: Float
}

"""
order by stddev() on columns of table "ec.demande"
"""
input ec_demande_stddev_order_by {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: order_by

  """
  Le nombre d'heures demandées.
  """
  heures: order_by
  id: order_by
}

"""
aggregate stddev_pop on columns
"""
type ec_demande_stddev_pop_fields {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: Float

  """
  Le nombre d'heures demandées.
  """
  heures: Float

  """
  Fonction qui renvoie, pour une demande donnée, le nombre d'heures EQTD correspondant en utilisant le coefficient multiplicateur du type d'enseignement correspondant.
  """
  heures_eqtd: Float
  id: Float
}

"""
order by stddev_pop() on columns of table "ec.demande"
"""
input ec_demande_stddev_pop_order_by {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: order_by

  """
  Le nombre d'heures demandées.
  """
  heures: order_by
  id: order_by
}

"""
aggregate stddev_samp on columns
"""
type ec_demande_stddev_samp_fields {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: Float

  """
  Le nombre d'heures demandées.
  """
  heures: Float

  """
  Fonction qui renvoie, pour une demande donnée, le nombre d'heures EQTD correspondant en utilisant le coefficient multiplicateur du type d'enseignement correspondant.
  """
  heures_eqtd: Float
  id: Float
}

"""
order by stddev_samp() on columns of table "ec.demande"
"""
input ec_demande_stddev_samp_order_by {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: order_by

  """
  Le nombre d'heures demandées.
  """
  heures: order_by
  id: order_by
}

"""
Streaming cursor of the table "ec_demande"
"""
input ec_demande_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: ec_demande_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input ec_demande_stream_cursor_value_input {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: Int

  """
  Le nombre d'heures demandées.
  """
  heures: Float
  id: Int

  """
  Le type de demande.
  """
  type: String

  """
  L'identifiant de l'intervenant correspondant à la demande.
  """
  uid: String
}

"""
aggregate sum on columns
"""
type ec_demande_sum_fields {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: Int

  """
  Le nombre d'heures demandées.
  """
  heures: Float

  """
  Fonction qui renvoie, pour une demande donnée, le nombre d'heures EQTD correspondant en utilisant le coefficient multiplicateur du type d'enseignement correspondant.
  """
  heures_eqtd: Float
  id: Int
}

"""
order by sum() on columns of table "ec.demande"
"""
input ec_demande_sum_order_by {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: order_by

  """
  Le nombre d'heures demandées.
  """
  heures: order_by
  id: order_by
}

"""
update columns of table "ec.demande"
"""
enum ec_demande_update_column {
  """
  column name
  """
  ens_id

  """
  column name
  """
  heures

  """
  column name
  """
  id

  """
  column name
  """
  type

  """
  column name
  """
  uid
}

input ec_demande_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: ec_demande_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: ec_demande_set_input

  """
  filter the rows which have to be updated
  """
  where: ec_demande_bool_exp!
}

"""
aggregate var_pop on columns
"""
type ec_demande_var_pop_fields {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: Float

  """
  Le nombre d'heures demandées.
  """
  heures: Float

  """
  Fonction qui renvoie, pour une demande donnée, le nombre d'heures EQTD correspondant en utilisant le coefficient multiplicateur du type d'enseignement correspondant.
  """
  heures_eqtd: Float
  id: Float
}

"""
order by var_pop() on columns of table "ec.demande"
"""
input ec_demande_var_pop_order_by {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: order_by

  """
  Le nombre d'heures demandées.
  """
  heures: order_by
  id: order_by
}

"""
aggregate var_samp on columns
"""
type ec_demande_var_samp_fields {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: Float

  """
  Le nombre d'heures demandées.
  """
  heures: Float

  """
  Fonction qui renvoie, pour une demande donnée, le nombre d'heures EQTD correspondant en utilisant le coefficient multiplicateur du type d'enseignement correspondant.
  """
  heures_eqtd: Float
  id: Float
}

"""
order by var_samp() on columns of table "ec.demande"
"""
input ec_demande_var_samp_order_by {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: order_by

  """
  Le nombre d'heures demandées.
  """
  heures: order_by
  id: order_by
}

"""
aggregate variance on columns
"""
type ec_demande_variance_fields {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: Float

  """
  Le nombre d'heures demandées.
  """
  heures: Float

  """
  Fonction qui renvoie, pour une demande donnée, le nombre d'heures EQTD correspondant en utilisant le coefficient multiplicateur du type d'enseignement correspondant.
  """
  heures_eqtd: Float
  id: Float
}

"""
order by variance() on columns of table "ec.demande"
"""
input ec_demande_variance_order_by {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: order_by

  """
  Le nombre d'heures demandées.
  """
  heures: order_by
  id: order_by
}

"""
Table contenant les enseignements.
"""
type ec_enseignement {
  """
  L'année de l'enseignement.
  """
  annee: Int!

  """
  An object relationship
  """
  anneeByAnnee: ec_annee!

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: Int!

  """
  An array relationship
  """
  demandes(
    """
    distinct select on columns
    """
    distinct_on: [ec_demande_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_demande_order_by!]

    """
    filter the rows returned
    """
    where: ec_demande_bool_exp
  ): [ec_demande!]!

  """
  An aggregate relationship
  """
  demandes_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_demande_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_demande_order_by!]

    """
    filter the rows returned
    """
    where: ec_demande_bool_exp
  ): ec_demande_aggregate!

  """
  Une description de l'enseignement.
  """
  description: String

  """
  An array relationship
  """
  enfants(
    """
    distinct select on columns
    """
    distinct_on: [ec_enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_enseignement_order_by!]

    """
    filter the rows returned
    """
    where: ec_enseignement_bool_exp
  ): [ec_enseignement!]!

  """
  An aggregate relationship
  """
  enfants_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_enseignement_order_by!]

    """
    filter the rows returned
    """
    where: ec_enseignement_bool_exp
  ): ec_enseignement_aggregate!
  ens_id_import: String
  formation_id_import: String

  """
  Le nombre de groupes.
  """
  groupes: Int!

  """
  Le nombre de groupes ouverts, et à défaut le nombre de groupes.
  """
  groupes_corriges: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: Int

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: Float!

  """
  Le nombre d'heures d'enseignement ouvertes par groupe, et à défaut le nombre d'heures d'enseignement.
  """
  heures_corrigees: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: Float

  """
  L'identifiant unique de l'enseignement.
  """
  id: Int!

  """
  An object relationship
  """
  mention: ec_mention!

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: Int!

  """
  Le nom de l'enseignement.
  """
  nom: String!

  """
  Le nom abrégé (optionnel)
  """
  nom_court: String
  nom_import: String

  """
  An object relationship
  """
  parcours: ec_parcours

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: Int

  """
  An object relationship
  """
  parent: ec_enseignement

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Int

  """
  An array relationship
  """
  priorites(
    """
    distinct select on columns
    """
    distinct_on: [ec_priorite_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_priorite_order_by!]

    """
    filter the rows returned
    """
    where: ec_priorite_bool_exp
  ): [ec_priorite!]!

  """
  An aggregate relationship
  """
  priorites_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_priorite_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_priorite_order_by!]

    """
    filter the rows returned
    """
    where: ec_priorite_bool_exp
  ): ec_priorite_aggregate!

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: Int

  """
  An array relationship
  """
  responsables(
    """
    distinct select on columns
    """
    distinct_on: [ec_responsable_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_responsable_order_by!]

    """
    filter the rows returned
    """
    where: ec_responsable_bool_exp
  ): [ec_responsable!]!

  """
  An aggregate relationship
  """
  responsables_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_responsable_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_responsable_order_by!]

    """
    filter the rows returned
    """
    where: ec_responsable_bool_exp
  ): ec_responsable_aggregate!

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: Int!

  """
  Le type d'enseignement.
  """
  type: String!

  """
  An object relationship
  """
  type_enseignement: ec_type_enseignement!

  """
  Indique si l'enseignement correspondant est visible par les utilisateurs.
  """
  visible: Boolean!
}

"""
aggregated selection of "ec.enseignement"
"""
type ec_enseignement_aggregate {
  aggregate: ec_enseignement_aggregate_fields
  nodes: [ec_enseignement!]!
}

input ec_enseignement_aggregate_bool_exp {
  bool_and: ec_enseignement_aggregate_bool_exp_bool_and
  bool_or: ec_enseignement_aggregate_bool_exp_bool_or
  count: ec_enseignement_aggregate_bool_exp_count
}

input ec_enseignement_aggregate_bool_exp_bool_and {
  arguments: ec_enseignement_select_column_ec_enseignement_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: ec_enseignement_bool_exp
  predicate: Boolean_comparison_exp!
}

input ec_enseignement_aggregate_bool_exp_bool_or {
  arguments: ec_enseignement_select_column_ec_enseignement_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: ec_enseignement_bool_exp
  predicate: Boolean_comparison_exp!
}

input ec_enseignement_aggregate_bool_exp_count {
  arguments: [ec_enseignement_select_column!]
  distinct: Boolean
  filter: ec_enseignement_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "ec.enseignement"
"""
type ec_enseignement_aggregate_fields {
  avg: ec_enseignement_avg_fields
  count(columns: [ec_enseignement_select_column!], distinct: Boolean): Int!
  max: ec_enseignement_max_fields
  min: ec_enseignement_min_fields
  stddev: ec_enseignement_stddev_fields
  stddev_pop: ec_enseignement_stddev_pop_fields
  stddev_samp: ec_enseignement_stddev_samp_fields
  sum: ec_enseignement_sum_fields
  var_pop: ec_enseignement_var_pop_fields
  var_samp: ec_enseignement_var_samp_fields
  variance: ec_enseignement_variance_fields
}

"""
order by aggregate values of table "ec.enseignement"
"""
input ec_enseignement_aggregate_order_by {
  avg: ec_enseignement_avg_order_by
  count: order_by
  max: ec_enseignement_max_order_by
  min: ec_enseignement_min_order_by
  stddev: ec_enseignement_stddev_order_by
  stddev_pop: ec_enseignement_stddev_pop_order_by
  stddev_samp: ec_enseignement_stddev_samp_order_by
  sum: ec_enseignement_sum_order_by
  var_pop: ec_enseignement_var_pop_order_by
  var_samp: ec_enseignement_var_samp_order_by
  variance: ec_enseignement_variance_order_by
}

"""
input type for inserting array relation for remote table "ec.enseignement"
"""
input ec_enseignement_arr_rel_insert_input {
  data: [ec_enseignement_insert_input!]!

  """
  upsert condition
  """
  on_conflict: ec_enseignement_on_conflict
}

"""
aggregate avg on columns
"""
type ec_enseignement_avg_fields {
  """
  L'année de l'enseignement.
  """
  annee: Float

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: Float

  """
  Le nombre de groupes.
  """
  groupes: Float

  """
  Le nombre de groupes ouverts, et à défaut le nombre de groupes.
  """
  groupes_corriges: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: Float

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe, et à défaut le nombre d'heures d'enseignement.
  """
  heures_corrigees: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: Float

  """
  L'identifiant unique de l'enseignement.
  """
  id: Float

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: Float

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: Float

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Float

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: Float

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: Float
}

"""
order by avg() on columns of table "ec.enseignement"
"""
input ec_enseignement_avg_order_by {
  """
  L'année de l'enseignement.
  """
  annee: order_by

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: order_by

  """
  Le nombre de groupes.
  """
  groupes: order_by

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: order_by

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: order_by

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: order_by

  """
  L'identifiant unique de l'enseignement.
  """
  id: order_by

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: order_by

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: order_by

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: order_by

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: order_by

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: order_by
}

"""
Boolean expression to filter rows from the table "ec.enseignement". All fields are combined with a logical 'AND'.
"""
input ec_enseignement_bool_exp {
  _and: [ec_enseignement_bool_exp!]
  _not: ec_enseignement_bool_exp
  _or: [ec_enseignement_bool_exp!]
  annee: Int_comparison_exp
  anneeByAnnee: ec_annee_bool_exp
  annee_cycle: Int_comparison_exp
  demandes: ec_demande_bool_exp
  demandes_aggregate: ec_demande_aggregate_bool_exp
  description: String_comparison_exp
  enfants: ec_enseignement_bool_exp
  enfants_aggregate: ec_enseignement_aggregate_bool_exp
  ens_id_import: String_comparison_exp
  formation_id_import: String_comparison_exp
  groupes: Int_comparison_exp
  groupes_corriges: Int_comparison_exp
  groupes_ouverts: Int_comparison_exp
  heures: Float_comparison_exp
  heures_corrigees: Float_comparison_exp
  heures_ouvertes: Float_comparison_exp
  id: Int_comparison_exp
  mention: ec_mention_bool_exp
  mention_id: Int_comparison_exp
  nom: String_comparison_exp
  nom_court: String_comparison_exp
  nom_import: String_comparison_exp
  parcours: ec_parcours_bool_exp
  parcours_id: Int_comparison_exp
  parent: ec_enseignement_bool_exp
  parent_id: Int_comparison_exp
  priorites: ec_priorite_bool_exp
  priorites_aggregate: ec_priorite_aggregate_bool_exp
  regle_priorite: Int_comparison_exp
  responsables: ec_responsable_bool_exp
  responsables_aggregate: ec_responsable_aggregate_bool_exp
  semestre: Int_comparison_exp
  type: String_comparison_exp
  type_enseignement: ec_type_enseignement_bool_exp
  visible: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "ec.enseignement"
"""
enum ec_enseignement_constraint {
  """
  unique or primary key constraint on columns "annee", "semestre", "parcours_id", "type", "mention_id", "nom"
  """
  enseignement_annee_mention_id_parcours_id_nom_semestre_type_key

  """
  unique or primary key constraint on columns "id"
  """
  enseignement_pkey
}

"""
input type for incrementing numeric columns in table "ec.enseignement"
"""
input ec_enseignement_inc_input {
  """
  L'année de l'enseignement.
  """
  annee: Int

  """
  Le nombre de groupes.
  """
  groupes: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: Int

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: Float

  """
  L'identifiant unique de l'enseignement.
  """
  id: Int

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: Int

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: Int

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Int

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: Int

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: Int
}

"""
input type for inserting data into table "ec.enseignement"
"""
input ec_enseignement_insert_input {
  """
  L'année de l'enseignement.
  """
  annee: Int
  anneeByAnnee: ec_annee_obj_rel_insert_input
  demandes: ec_demande_arr_rel_insert_input

  """
  Une description de l'enseignement.
  """
  description: String
  enfants: ec_enseignement_arr_rel_insert_input
  ens_id_import: String
  formation_id_import: String

  """
  Le nombre de groupes.
  """
  groupes: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: Int

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: Float

  """
  L'identifiant unique de l'enseignement.
  """
  id: Int
  mention: ec_mention_obj_rel_insert_input

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: Int

  """
  Le nom de l'enseignement.
  """
  nom: String

  """
  Le nom abrégé (optionnel)
  """
  nom_court: String
  nom_import: String
  parcours: ec_parcours_obj_rel_insert_input

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: Int
  parent: ec_enseignement_obj_rel_insert_input

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Int
  priorites: ec_priorite_arr_rel_insert_input

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: Int
  responsables: ec_responsable_arr_rel_insert_input

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: Int

  """
  Le type d'enseignement.
  """
  type: String
  type_enseignement: ec_type_enseignement_obj_rel_insert_input

  """
  Indique si l'enseignement correspondant est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate max on columns
"""
type ec_enseignement_max_fields {
  """
  L'année de l'enseignement.
  """
  annee: Int

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: Int

  """
  Une description de l'enseignement.
  """
  description: String
  ens_id_import: String
  formation_id_import: String

  """
  Le nombre de groupes.
  """
  groupes: Int

  """
  Le nombre de groupes ouverts, et à défaut le nombre de groupes.
  """
  groupes_corriges: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: Int

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe, et à défaut le nombre d'heures d'enseignement.
  """
  heures_corrigees: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: Float

  """
  L'identifiant unique de l'enseignement.
  """
  id: Int

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: Int

  """
  Le nom de l'enseignement.
  """
  nom: String

  """
  Le nom abrégé (optionnel)
  """
  nom_court: String
  nom_import: String

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: Int

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Int

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: Int

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: Int

  """
  Le type d'enseignement.
  """
  type: String
}

"""
order by max() on columns of table "ec.enseignement"
"""
input ec_enseignement_max_order_by {
  """
  L'année de l'enseignement.
  """
  annee: order_by

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: order_by

  """
  Une description de l'enseignement.
  """
  description: order_by
  ens_id_import: order_by
  formation_id_import: order_by

  """
  Le nombre de groupes.
  """
  groupes: order_by

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: order_by

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: order_by

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: order_by

  """
  L'identifiant unique de l'enseignement.
  """
  id: order_by

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: order_by

  """
  Le nom de l'enseignement.
  """
  nom: order_by

  """
  Le nom abrégé (optionnel)
  """
  nom_court: order_by
  nom_import: order_by

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: order_by

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: order_by

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: order_by

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: order_by

  """
  Le type d'enseignement.
  """
  type: order_by
}

"""
aggregate min on columns
"""
type ec_enseignement_min_fields {
  """
  L'année de l'enseignement.
  """
  annee: Int

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: Int

  """
  Une description de l'enseignement.
  """
  description: String
  ens_id_import: String
  formation_id_import: String

  """
  Le nombre de groupes.
  """
  groupes: Int

  """
  Le nombre de groupes ouverts, et à défaut le nombre de groupes.
  """
  groupes_corriges: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: Int

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe, et à défaut le nombre d'heures d'enseignement.
  """
  heures_corrigees: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: Float

  """
  L'identifiant unique de l'enseignement.
  """
  id: Int

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: Int

  """
  Le nom de l'enseignement.
  """
  nom: String

  """
  Le nom abrégé (optionnel)
  """
  nom_court: String
  nom_import: String

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: Int

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Int

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: Int

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: Int

  """
  Le type d'enseignement.
  """
  type: String
}

"""
order by min() on columns of table "ec.enseignement"
"""
input ec_enseignement_min_order_by {
  """
  L'année de l'enseignement.
  """
  annee: order_by

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: order_by

  """
  Une description de l'enseignement.
  """
  description: order_by
  ens_id_import: order_by
  formation_id_import: order_by

  """
  Le nombre de groupes.
  """
  groupes: order_by

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: order_by

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: order_by

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: order_by

  """
  L'identifiant unique de l'enseignement.
  """
  id: order_by

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: order_by

  """
  Le nom de l'enseignement.
  """
  nom: order_by

  """
  Le nom abrégé (optionnel)
  """
  nom_court: order_by
  nom_import: order_by

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: order_by

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: order_by

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: order_by

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: order_by

  """
  Le type d'enseignement.
  """
  type: order_by
}

"""
response of any mutation on the table "ec.enseignement"
"""
type ec_enseignement_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [ec_enseignement!]!
}

"""
input type for inserting object relation for remote table "ec.enseignement"
"""
input ec_enseignement_obj_rel_insert_input {
  data: ec_enseignement_insert_input!

  """
  upsert condition
  """
  on_conflict: ec_enseignement_on_conflict
}

"""
on_conflict condition type for table "ec.enseignement"
"""
input ec_enseignement_on_conflict {
  constraint: ec_enseignement_constraint!
  update_columns: [ec_enseignement_update_column!]! = []
  where: ec_enseignement_bool_exp
}

"""
Ordering options when selecting data from "ec.enseignement".
"""
input ec_enseignement_order_by {
  annee: order_by
  anneeByAnnee: ec_annee_order_by
  annee_cycle: order_by
  demandes_aggregate: ec_demande_aggregate_order_by
  description: order_by
  enfants_aggregate: ec_enseignement_aggregate_order_by
  ens_id_import: order_by
  formation_id_import: order_by
  groupes: order_by
  groupes_corriges: order_by
  groupes_ouverts: order_by
  heures: order_by
  heures_corrigees: order_by
  heures_ouvertes: order_by
  id: order_by
  mention: ec_mention_order_by
  mention_id: order_by
  nom: order_by
  nom_court: order_by
  nom_import: order_by
  parcours: ec_parcours_order_by
  parcours_id: order_by
  parent: ec_enseignement_order_by
  parent_id: order_by
  priorites_aggregate: ec_priorite_aggregate_order_by
  regle_priorite: order_by
  responsables_aggregate: ec_responsable_aggregate_order_by
  semestre: order_by
  type: order_by
  type_enseignement: ec_type_enseignement_order_by
  visible: order_by
}

"""
primary key columns input for table: ec.enseignement
"""
input ec_enseignement_pk_columns_input {
  """
  L'identifiant unique de l'enseignement.
  """
  id: Int!
}

"""
select columns of table "ec.enseignement"
"""
enum ec_enseignement_select_column {
  """
  column name
  """
  annee

  """
  column name
  """
  annee_cycle

  """
  column name
  """
  description

  """
  column name
  """
  ens_id_import

  """
  column name
  """
  formation_id_import

  """
  column name
  """
  groupes

  """
  column name
  """
  groupes_ouverts

  """
  column name
  """
  heures

  """
  column name
  """
  heures_ouvertes

  """
  column name
  """
  id

  """
  column name
  """
  mention_id

  """
  column name
  """
  nom

  """
  column name
  """
  nom_court

  """
  column name
  """
  nom_import

  """
  column name
  """
  parcours_id

  """
  column name
  """
  parent_id

  """
  column name
  """
  regle_priorite

  """
  column name
  """
  semestre

  """
  column name
  """
  type

  """
  column name
  """
  visible
}

"""
select "ec_enseignement_aggregate_bool_exp_bool_and_arguments_columns" columns of table "ec.enseignement"
"""
enum ec_enseignement_select_column_ec_enseignement_aggregate_bool_exp_bool_and_arguments_columns {
  """
  column name
  """
  visible
}

"""
select "ec_enseignement_aggregate_bool_exp_bool_or_arguments_columns" columns of table "ec.enseignement"
"""
enum ec_enseignement_select_column_ec_enseignement_aggregate_bool_exp_bool_or_arguments_columns {
  """
  column name
  """
  visible
}

"""
input type for updating data in table "ec.enseignement"
"""
input ec_enseignement_set_input {
  """
  L'année de l'enseignement.
  """
  annee: Int

  """
  Une description de l'enseignement.
  """
  description: String
  ens_id_import: String
  formation_id_import: String

  """
  Le nombre de groupes.
  """
  groupes: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: Int

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: Float

  """
  L'identifiant unique de l'enseignement.
  """
  id: Int

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: Int

  """
  Le nom de l'enseignement.
  """
  nom: String

  """
  Le nom abrégé (optionnel)
  """
  nom_court: String
  nom_import: String

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: Int

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Int

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: Int

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: Int

  """
  Le type d'enseignement.
  """
  type: String

  """
  Indique si l'enseignement correspondant est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate stddev on columns
"""
type ec_enseignement_stddev_fields {
  """
  L'année de l'enseignement.
  """
  annee: Float

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: Float

  """
  Le nombre de groupes.
  """
  groupes: Float

  """
  Le nombre de groupes ouverts, et à défaut le nombre de groupes.
  """
  groupes_corriges: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: Float

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe, et à défaut le nombre d'heures d'enseignement.
  """
  heures_corrigees: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: Float

  """
  L'identifiant unique de l'enseignement.
  """
  id: Float

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: Float

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: Float

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Float

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: Float

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: Float
}

"""
order by stddev() on columns of table "ec.enseignement"
"""
input ec_enseignement_stddev_order_by {
  """
  L'année de l'enseignement.
  """
  annee: order_by

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: order_by

  """
  Le nombre de groupes.
  """
  groupes: order_by

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: order_by

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: order_by

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: order_by

  """
  L'identifiant unique de l'enseignement.
  """
  id: order_by

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: order_by

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: order_by

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: order_by

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: order_by

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: order_by
}

"""
aggregate stddev_pop on columns
"""
type ec_enseignement_stddev_pop_fields {
  """
  L'année de l'enseignement.
  """
  annee: Float

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: Float

  """
  Le nombre de groupes.
  """
  groupes: Float

  """
  Le nombre de groupes ouverts, et à défaut le nombre de groupes.
  """
  groupes_corriges: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: Float

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe, et à défaut le nombre d'heures d'enseignement.
  """
  heures_corrigees: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: Float

  """
  L'identifiant unique de l'enseignement.
  """
  id: Float

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: Float

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: Float

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Float

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: Float

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: Float
}

"""
order by stddev_pop() on columns of table "ec.enseignement"
"""
input ec_enseignement_stddev_pop_order_by {
  """
  L'année de l'enseignement.
  """
  annee: order_by

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: order_by

  """
  Le nombre de groupes.
  """
  groupes: order_by

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: order_by

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: order_by

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: order_by

  """
  L'identifiant unique de l'enseignement.
  """
  id: order_by

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: order_by

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: order_by

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: order_by

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: order_by

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: order_by
}

"""
aggregate stddev_samp on columns
"""
type ec_enseignement_stddev_samp_fields {
  """
  L'année de l'enseignement.
  """
  annee: Float

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: Float

  """
  Le nombre de groupes.
  """
  groupes: Float

  """
  Le nombre de groupes ouverts, et à défaut le nombre de groupes.
  """
  groupes_corriges: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: Float

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe, et à défaut le nombre d'heures d'enseignement.
  """
  heures_corrigees: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: Float

  """
  L'identifiant unique de l'enseignement.
  """
  id: Float

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: Float

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: Float

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Float

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: Float

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: Float
}

"""
order by stddev_samp() on columns of table "ec.enseignement"
"""
input ec_enseignement_stddev_samp_order_by {
  """
  L'année de l'enseignement.
  """
  annee: order_by

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: order_by

  """
  Le nombre de groupes.
  """
  groupes: order_by

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: order_by

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: order_by

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: order_by

  """
  L'identifiant unique de l'enseignement.
  """
  id: order_by

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: order_by

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: order_by

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: order_by

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: order_by

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: order_by
}

"""
Streaming cursor of the table "ec_enseignement"
"""
input ec_enseignement_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: ec_enseignement_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input ec_enseignement_stream_cursor_value_input {
  """
  L'année de l'enseignement.
  """
  annee: Int

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: Int

  """
  Une description de l'enseignement.
  """
  description: String
  ens_id_import: String
  formation_id_import: String

  """
  Le nombre de groupes.
  """
  groupes: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: Int

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: Float

  """
  L'identifiant unique de l'enseignement.
  """
  id: Int

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: Int

  """
  Le nom de l'enseignement.
  """
  nom: String

  """
  Le nom abrégé (optionnel)
  """
  nom_court: String
  nom_import: String

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: Int

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Int

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: Int

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: Int

  """
  Le type d'enseignement.
  """
  type: String

  """
  Indique si l'enseignement correspondant est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate sum on columns
"""
type ec_enseignement_sum_fields {
  """
  L'année de l'enseignement.
  """
  annee: Int

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: Int

  """
  Le nombre de groupes.
  """
  groupes: Int

  """
  Le nombre de groupes ouverts, et à défaut le nombre de groupes.
  """
  groupes_corriges: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: Int

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe, et à défaut le nombre d'heures d'enseignement.
  """
  heures_corrigees: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: Float

  """
  L'identifiant unique de l'enseignement.
  """
  id: Int

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: Int

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: Int

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Int

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: Int

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: Int
}

"""
order by sum() on columns of table "ec.enseignement"
"""
input ec_enseignement_sum_order_by {
  """
  L'année de l'enseignement.
  """
  annee: order_by

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: order_by

  """
  Le nombre de groupes.
  """
  groupes: order_by

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: order_by

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: order_by

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: order_by

  """
  L'identifiant unique de l'enseignement.
  """
  id: order_by

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: order_by

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: order_by

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: order_by

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: order_by

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: order_by
}

"""
update columns of table "ec.enseignement"
"""
enum ec_enseignement_update_column {
  """
  column name
  """
  annee

  """
  column name
  """
  description

  """
  column name
  """
  ens_id_import

  """
  column name
  """
  formation_id_import

  """
  column name
  """
  groupes

  """
  column name
  """
  groupes_ouverts

  """
  column name
  """
  heures

  """
  column name
  """
  heures_ouvertes

  """
  column name
  """
  id

  """
  column name
  """
  mention_id

  """
  column name
  """
  nom

  """
  column name
  """
  nom_court

  """
  column name
  """
  nom_import

  """
  column name
  """
  parcours_id

  """
  column name
  """
  parent_id

  """
  column name
  """
  regle_priorite

  """
  column name
  """
  semestre

  """
  column name
  """
  type

  """
  column name
  """
  visible
}

input ec_enseignement_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: ec_enseignement_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: ec_enseignement_set_input

  """
  filter the rows which have to be updated
  """
  where: ec_enseignement_bool_exp!
}

"""
aggregate var_pop on columns
"""
type ec_enseignement_var_pop_fields {
  """
  L'année de l'enseignement.
  """
  annee: Float

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: Float

  """
  Le nombre de groupes.
  """
  groupes: Float

  """
  Le nombre de groupes ouverts, et à défaut le nombre de groupes.
  """
  groupes_corriges: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: Float

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe, et à défaut le nombre d'heures d'enseignement.
  """
  heures_corrigees: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: Float

  """
  L'identifiant unique de l'enseignement.
  """
  id: Float

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: Float

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: Float

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Float

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: Float

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: Float
}

"""
order by var_pop() on columns of table "ec.enseignement"
"""
input ec_enseignement_var_pop_order_by {
  """
  L'année de l'enseignement.
  """
  annee: order_by

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: order_by

  """
  Le nombre de groupes.
  """
  groupes: order_by

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: order_by

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: order_by

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: order_by

  """
  L'identifiant unique de l'enseignement.
  """
  id: order_by

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: order_by

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: order_by

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: order_by

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: order_by

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: order_by
}

"""
aggregate var_samp on columns
"""
type ec_enseignement_var_samp_fields {
  """
  L'année de l'enseignement.
  """
  annee: Float

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: Float

  """
  Le nombre de groupes.
  """
  groupes: Float

  """
  Le nombre de groupes ouverts, et à défaut le nombre de groupes.
  """
  groupes_corriges: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: Float

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe, et à défaut le nombre d'heures d'enseignement.
  """
  heures_corrigees: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: Float

  """
  L'identifiant unique de l'enseignement.
  """
  id: Float

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: Float

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: Float

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Float

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: Float

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: Float
}

"""
order by var_samp() on columns of table "ec.enseignement"
"""
input ec_enseignement_var_samp_order_by {
  """
  L'année de l'enseignement.
  """
  annee: order_by

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: order_by

  """
  Le nombre de groupes.
  """
  groupes: order_by

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: order_by

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: order_by

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: order_by

  """
  L'identifiant unique de l'enseignement.
  """
  id: order_by

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: order_by

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: order_by

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: order_by

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: order_by

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: order_by
}

"""
aggregate variance on columns
"""
type ec_enseignement_variance_fields {
  """
  L'année de l'enseignement.
  """
  annee: Float

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: Float

  """
  Le nombre de groupes.
  """
  groupes: Float

  """
  Le nombre de groupes ouverts, et à défaut le nombre de groupes.
  """
  groupes_corriges: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: Float

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe, et à défaut le nombre d'heures d'enseignement.
  """
  heures_corrigees: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: Float

  """
  L'identifiant unique de l'enseignement.
  """
  id: Float

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: Float

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: Float

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Float

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: Float

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: Float
}

"""
order by variance() on columns of table "ec.enseignement"
"""
input ec_enseignement_variance_order_by {
  """
  L'année de l'enseignement.
  """
  annee: order_by

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: order_by

  """
  Le nombre de groupes.
  """
  groupes: order_by

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: order_by

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: order_by

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: order_by

  """
  L'identifiant unique de l'enseignement.
  """
  id: order_by

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: order_by

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: order_by

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: order_by

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: order_by

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: order_by
}

"""
Table contenant les intervenants.
"""
type ec_intervenant {
  """
  Indique si l'intervenant correspondant est actif, c'est-à-dire s'il intervient dans l'année en cours.
  """
  actif: Boolean!

  """
  Le service de base en heures EQTD de l'intervenant (optionnel).
  """
  alias: String

  """
  An array relationship
  """
  demandes(
    """
    distinct select on columns
    """
    distinct_on: [ec_demande_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_demande_order_by!]

    """
    filter the rows returned
    """
    where: ec_demande_bool_exp
  ): [ec_demande!]!

  """
  An aggregate relationship
  """
  demandes_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_demande_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_demande_order_by!]

    """
    filter the rows returned
    """
    where: ec_demande_bool_exp
  ): ec_demande_aggregate!

  """
  An array relationship
  """
  messages(
    """
    distinct select on columns
    """
    distinct_on: [ec_message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_message_order_by!]

    """
    filter the rows returned
    """
    where: ec_message_bool_exp
  ): [ec_message!]!

  """
  An aggregate relationship
  """
  messages_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_message_order_by!]

    """
    filter the rows returned
    """
    where: ec_message_bool_exp
  ): ec_message_aggregate!

  """
  An array relationship
  """
  modifications_service(
    """
    distinct select on columns
    """
    distinct_on: [ec_modification_service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_modification_service_order_by!]

    """
    filter the rows returned
    """
    where: ec_modification_service_bool_exp
  ): [ec_modification_service!]!

  """
  An aggregate relationship
  """
  modifications_service_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_modification_service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_modification_service_order_by!]

    """
    filter the rows returned
    """
    where: ec_modification_service_bool_exp
  ): ec_modification_service_aggregate!

  """
  Le nom de l'intervenant.
  """
  nom: String!

  """
  Le prénom de l'intervenant.
  """
  prenom: String!

  """
  An array relationship
  """
  priorites(
    """
    distinct select on columns
    """
    distinct_on: [ec_priorite_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_priorite_order_by!]

    """
    filter the rows returned
    """
    where: ec_priorite_bool_exp
  ): [ec_priorite!]!

  """
  An aggregate relationship
  """
  priorites_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_priorite_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_priorite_order_by!]

    """
    filter the rows returned
    """
    where: ec_priorite_bool_exp
  ): ec_priorite_aggregate!

  """
  An array relationship
  """
  responsables(
    """
    distinct select on columns
    """
    distinct_on: [ec_responsable_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_responsable_order_by!]

    """
    filter the rows returned
    """
    where: ec_responsable_bool_exp
  ): [ec_responsable!]!

  """
  An aggregate relationship
  """
  responsables_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_responsable_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_responsable_order_by!]

    """
    filter the rows returned
    """
    where: ec_responsable_bool_exp
  ): ec_responsable_aggregate!
  service: Float

  """
  An array relationship
  """
  services(
    """
    distinct select on columns
    """
    distinct_on: [ec_service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_service_order_by!]

    """
    filter the rows returned
    """
    where: ec_service_bool_exp
  ): [ec_service!]!

  """
  An aggregate relationship
  """
  services_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_service_order_by!]

    """
    filter the rows returned
    """
    where: ec_service_bool_exp
  ): ec_service_aggregate!

  """
  L'identifiant unique de l'intervenant.
  """
  uid: String!

  """
  Indique si l'intervenant correspondant est visible par les utilisateurs.
  """
  visible: Boolean!
}

"""
aggregated selection of "ec.intervenant"
"""
type ec_intervenant_aggregate {
  aggregate: ec_intervenant_aggregate_fields
  nodes: [ec_intervenant!]!
}

"""
aggregate fields of "ec.intervenant"
"""
type ec_intervenant_aggregate_fields {
  avg: ec_intervenant_avg_fields
  count(columns: [ec_intervenant_select_column!], distinct: Boolean): Int!
  max: ec_intervenant_max_fields
  min: ec_intervenant_min_fields
  stddev: ec_intervenant_stddev_fields
  stddev_pop: ec_intervenant_stddev_pop_fields
  stddev_samp: ec_intervenant_stddev_samp_fields
  sum: ec_intervenant_sum_fields
  var_pop: ec_intervenant_var_pop_fields
  var_samp: ec_intervenant_var_samp_fields
  variance: ec_intervenant_variance_fields
}

"""
aggregate avg on columns
"""
type ec_intervenant_avg_fields {
  service: Float
}

"""
Boolean expression to filter rows from the table "ec.intervenant". All fields are combined with a logical 'AND'.
"""
input ec_intervenant_bool_exp {
  _and: [ec_intervenant_bool_exp!]
  _not: ec_intervenant_bool_exp
  _or: [ec_intervenant_bool_exp!]
  actif: Boolean_comparison_exp
  alias: String_comparison_exp
  demandes: ec_demande_bool_exp
  demandes_aggregate: ec_demande_aggregate_bool_exp
  messages: ec_message_bool_exp
  messages_aggregate: ec_message_aggregate_bool_exp
  modifications_service: ec_modification_service_bool_exp
  modifications_service_aggregate: ec_modification_service_aggregate_bool_exp
  nom: String_comparison_exp
  prenom: String_comparison_exp
  priorites: ec_priorite_bool_exp
  priorites_aggregate: ec_priorite_aggregate_bool_exp
  responsables: ec_responsable_bool_exp
  responsables_aggregate: ec_responsable_aggregate_bool_exp
  service: Float_comparison_exp
  services: ec_service_bool_exp
  services_aggregate: ec_service_aggregate_bool_exp
  uid: String_comparison_exp
  visible: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "ec.intervenant"
"""
enum ec_intervenant_constraint {
  """
  unique or primary key constraint on columns "uid"
  """
  intervenant_pkey
}

"""
input type for incrementing numeric columns in table "ec.intervenant"
"""
input ec_intervenant_inc_input {
  service: Float
}

"""
input type for inserting data into table "ec.intervenant"
"""
input ec_intervenant_insert_input {
  """
  Indique si l'intervenant correspondant est actif, c'est-à-dire s'il intervient dans l'année en cours.
  """
  actif: Boolean

  """
  Le service de base en heures EQTD de l'intervenant (optionnel).
  """
  alias: String
  demandes: ec_demande_arr_rel_insert_input
  messages: ec_message_arr_rel_insert_input
  modifications_service: ec_modification_service_arr_rel_insert_input

  """
  Le nom de l'intervenant.
  """
  nom: String

  """
  Le prénom de l'intervenant.
  """
  prenom: String
  priorites: ec_priorite_arr_rel_insert_input
  responsables: ec_responsable_arr_rel_insert_input
  service: Float
  services: ec_service_arr_rel_insert_input

  """
  L'identifiant unique de l'intervenant.
  """
  uid: String

  """
  Indique si l'intervenant correspondant est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate max on columns
"""
type ec_intervenant_max_fields {
  """
  Le service de base en heures EQTD de l'intervenant (optionnel).
  """
  alias: String

  """
  Le nom de l'intervenant.
  """
  nom: String

  """
  Le prénom de l'intervenant.
  """
  prenom: String
  service: Float

  """
  L'identifiant unique de l'intervenant.
  """
  uid: String
}

"""
aggregate min on columns
"""
type ec_intervenant_min_fields {
  """
  Le service de base en heures EQTD de l'intervenant (optionnel).
  """
  alias: String

  """
  Le nom de l'intervenant.
  """
  nom: String

  """
  Le prénom de l'intervenant.
  """
  prenom: String
  service: Float

  """
  L'identifiant unique de l'intervenant.
  """
  uid: String
}

"""
response of any mutation on the table "ec.intervenant"
"""
type ec_intervenant_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [ec_intervenant!]!
}

"""
input type for inserting object relation for remote table "ec.intervenant"
"""
input ec_intervenant_obj_rel_insert_input {
  data: ec_intervenant_insert_input!

  """
  upsert condition
  """
  on_conflict: ec_intervenant_on_conflict
}

"""
on_conflict condition type for table "ec.intervenant"
"""
input ec_intervenant_on_conflict {
  constraint: ec_intervenant_constraint!
  update_columns: [ec_intervenant_update_column!]! = []
  where: ec_intervenant_bool_exp
}

"""
Ordering options when selecting data from "ec.intervenant".
"""
input ec_intervenant_order_by {
  actif: order_by
  alias: order_by
  demandes_aggregate: ec_demande_aggregate_order_by
  messages_aggregate: ec_message_aggregate_order_by
  modifications_service_aggregate: ec_modification_service_aggregate_order_by
  nom: order_by
  prenom: order_by
  priorites_aggregate: ec_priorite_aggregate_order_by
  responsables_aggregate: ec_responsable_aggregate_order_by
  service: order_by
  services_aggregate: ec_service_aggregate_order_by
  uid: order_by
  visible: order_by
}

"""
primary key columns input for table: ec.intervenant
"""
input ec_intervenant_pk_columns_input {
  """
  L'identifiant unique de l'intervenant.
  """
  uid: String!
}

"""
select columns of table "ec.intervenant"
"""
enum ec_intervenant_select_column {
  """
  column name
  """
  actif

  """
  column name
  """
  alias

  """
  column name
  """
  nom

  """
  column name
  """
  prenom

  """
  column name
  """
  service

  """
  column name
  """
  uid

  """
  column name
  """
  visible
}

"""
input type for updating data in table "ec.intervenant"
"""
input ec_intervenant_set_input {
  """
  Indique si l'intervenant correspondant est actif, c'est-à-dire s'il intervient dans l'année en cours.
  """
  actif: Boolean

  """
  Le service de base en heures EQTD de l'intervenant (optionnel).
  """
  alias: String

  """
  Le nom de l'intervenant.
  """
  nom: String

  """
  Le prénom de l'intervenant.
  """
  prenom: String
  service: Float

  """
  L'identifiant unique de l'intervenant.
  """
  uid: String

  """
  Indique si l'intervenant correspondant est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate stddev on columns
"""
type ec_intervenant_stddev_fields {
  service: Float
}

"""
aggregate stddev_pop on columns
"""
type ec_intervenant_stddev_pop_fields {
  service: Float
}

"""
aggregate stddev_samp on columns
"""
type ec_intervenant_stddev_samp_fields {
  service: Float
}

"""
Streaming cursor of the table "ec_intervenant"
"""
input ec_intervenant_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: ec_intervenant_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input ec_intervenant_stream_cursor_value_input {
  """
  Indique si l'intervenant correspondant est actif, c'est-à-dire s'il intervient dans l'année en cours.
  """
  actif: Boolean

  """
  Le service de base en heures EQTD de l'intervenant (optionnel).
  """
  alias: String

  """
  Le nom de l'intervenant.
  """
  nom: String

  """
  Le prénom de l'intervenant.
  """
  prenom: String
  service: Float

  """
  L'identifiant unique de l'intervenant.
  """
  uid: String

  """
  Indique si l'intervenant correspondant est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate sum on columns
"""
type ec_intervenant_sum_fields {
  service: Float
}

"""
update columns of table "ec.intervenant"
"""
enum ec_intervenant_update_column {
  """
  column name
  """
  actif

  """
  column name
  """
  alias

  """
  column name
  """
  nom

  """
  column name
  """
  prenom

  """
  column name
  """
  service

  """
  column name
  """
  uid

  """
  column name
  """
  visible
}

input ec_intervenant_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: ec_intervenant_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: ec_intervenant_set_input

  """
  filter the rows which have to be updated
  """
  where: ec_intervenant_bool_exp!
}

"""
aggregate var_pop on columns
"""
type ec_intervenant_var_pop_fields {
  service: Float
}

"""
aggregate var_samp on columns
"""
type ec_intervenant_var_samp_fields {
  service: Float
}

"""
aggregate variance on columns
"""
type ec_intervenant_variance_fields {
  service: Float
}

"""
Table contenant les différentes mentions.
"""
type ec_mention {
  """
  An object relationship
  """
  cursus: ec_cursus!
  cursus_id: Int!

  """
  An array relationship
  """
  enseignements(
    """
    distinct select on columns
    """
    distinct_on: [ec_enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_enseignement_order_by!]

    """
    filter the rows returned
    """
    where: ec_enseignement_bool_exp
  ): [ec_enseignement!]!

  """
  An aggregate relationship
  """
  enseignements_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_enseignement_order_by!]

    """
    filter the rows returned
    """
    where: ec_enseignement_bool_exp
  ): ec_enseignement_aggregate!

  """
  L'identifiant unique de la mention.
  """
  id: Int!

  """
  Le nom de la mention (unique).
  """
  nom: String!

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String
  nom_import: String

  """
  An array relationship
  """
  parcours(
    """
    distinct select on columns
    """
    distinct_on: [ec_parcours_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_parcours_order_by!]

    """
    filter the rows returned
    """
    where: ec_parcours_bool_exp
  ): [ec_parcours!]!

  """
  An aggregate relationship
  """
  parcours_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_parcours_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_parcours_order_by!]

    """
    filter the rows returned
    """
    where: ec_parcours_bool_exp
  ): ec_parcours_aggregate!

  """
  An array relationship
  """
  responsables(
    """
    distinct select on columns
    """
    distinct_on: [ec_responsable_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_responsable_order_by!]

    """
    filter the rows returned
    """
    where: ec_responsable_bool_exp
  ): [ec_responsable!]!

  """
  An aggregate relationship
  """
  responsables_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_responsable_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_responsable_order_by!]

    """
    filter the rows returned
    """
    where: ec_responsable_bool_exp
  ): ec_responsable_aggregate!

  """
  Indique si la mention correspondante est visible par les utilisateurs.
  """
  visible: Boolean!
}

"""
aggregated selection of "ec.mention"
"""
type ec_mention_aggregate {
  aggregate: ec_mention_aggregate_fields
  nodes: [ec_mention!]!
}

input ec_mention_aggregate_bool_exp {
  bool_and: ec_mention_aggregate_bool_exp_bool_and
  bool_or: ec_mention_aggregate_bool_exp_bool_or
  count: ec_mention_aggregate_bool_exp_count
}

input ec_mention_aggregate_bool_exp_bool_and {
  arguments: ec_mention_select_column_ec_mention_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: ec_mention_bool_exp
  predicate: Boolean_comparison_exp!
}

input ec_mention_aggregate_bool_exp_bool_or {
  arguments: ec_mention_select_column_ec_mention_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: ec_mention_bool_exp
  predicate: Boolean_comparison_exp!
}

input ec_mention_aggregate_bool_exp_count {
  arguments: [ec_mention_select_column!]
  distinct: Boolean
  filter: ec_mention_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "ec.mention"
"""
type ec_mention_aggregate_fields {
  avg: ec_mention_avg_fields
  count(columns: [ec_mention_select_column!], distinct: Boolean): Int!
  max: ec_mention_max_fields
  min: ec_mention_min_fields
  stddev: ec_mention_stddev_fields
  stddev_pop: ec_mention_stddev_pop_fields
  stddev_samp: ec_mention_stddev_samp_fields
  sum: ec_mention_sum_fields
  var_pop: ec_mention_var_pop_fields
  var_samp: ec_mention_var_samp_fields
  variance: ec_mention_variance_fields
}

"""
order by aggregate values of table "ec.mention"
"""
input ec_mention_aggregate_order_by {
  avg: ec_mention_avg_order_by
  count: order_by
  max: ec_mention_max_order_by
  min: ec_mention_min_order_by
  stddev: ec_mention_stddev_order_by
  stddev_pop: ec_mention_stddev_pop_order_by
  stddev_samp: ec_mention_stddev_samp_order_by
  sum: ec_mention_sum_order_by
  var_pop: ec_mention_var_pop_order_by
  var_samp: ec_mention_var_samp_order_by
  variance: ec_mention_variance_order_by
}

"""
input type for inserting array relation for remote table "ec.mention"
"""
input ec_mention_arr_rel_insert_input {
  data: [ec_mention_insert_input!]!

  """
  upsert condition
  """
  on_conflict: ec_mention_on_conflict
}

"""
aggregate avg on columns
"""
type ec_mention_avg_fields {
  cursus_id: Float

  """
  L'identifiant unique de la mention.
  """
  id: Float
}

"""
order by avg() on columns of table "ec.mention"
"""
input ec_mention_avg_order_by {
  cursus_id: order_by

  """
  L'identifiant unique de la mention.
  """
  id: order_by
}

"""
Boolean expression to filter rows from the table "ec.mention". All fields are combined with a logical 'AND'.
"""
input ec_mention_bool_exp {
  _and: [ec_mention_bool_exp!]
  _not: ec_mention_bool_exp
  _or: [ec_mention_bool_exp!]
  cursus: ec_cursus_bool_exp
  cursus_id: Int_comparison_exp
  enseignements: ec_enseignement_bool_exp
  enseignements_aggregate: ec_enseignement_aggregate_bool_exp
  id: Int_comparison_exp
  nom: String_comparison_exp
  nom_court: String_comparison_exp
  nom_import: String_comparison_exp
  parcours: ec_parcours_bool_exp
  parcours_aggregate: ec_parcours_aggregate_bool_exp
  responsables: ec_responsable_bool_exp
  responsables_aggregate: ec_responsable_aggregate_bool_exp
  visible: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "ec.mention"
"""
enum ec_mention_constraint {
  """
  unique or primary key constraint on columns "cursus_id", "nom"
  """
  mention_cursus_id_nom_key

  """
  unique or primary key constraint on columns "id"
  """
  mention_pkey
}

"""
input type for incrementing numeric columns in table "ec.mention"
"""
input ec_mention_inc_input {
  cursus_id: Int

  """
  L'identifiant unique de la mention.
  """
  id: Int
}

"""
input type for inserting data into table "ec.mention"
"""
input ec_mention_insert_input {
  cursus: ec_cursus_obj_rel_insert_input
  cursus_id: Int
  enseignements: ec_enseignement_arr_rel_insert_input

  """
  L'identifiant unique de la mention.
  """
  id: Int

  """
  Le nom de la mention (unique).
  """
  nom: String

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String
  nom_import: String
  parcours: ec_parcours_arr_rel_insert_input
  responsables: ec_responsable_arr_rel_insert_input

  """
  Indique si la mention correspondante est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate max on columns
"""
type ec_mention_max_fields {
  cursus_id: Int

  """
  L'identifiant unique de la mention.
  """
  id: Int

  """
  Le nom de la mention (unique).
  """
  nom: String

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String
  nom_import: String
}

"""
order by max() on columns of table "ec.mention"
"""
input ec_mention_max_order_by {
  cursus_id: order_by

  """
  L'identifiant unique de la mention.
  """
  id: order_by

  """
  Le nom de la mention (unique).
  """
  nom: order_by

  """
  Le nom abrégé (optionnel).
  """
  nom_court: order_by
  nom_import: order_by
}

"""
aggregate min on columns
"""
type ec_mention_min_fields {
  cursus_id: Int

  """
  L'identifiant unique de la mention.
  """
  id: Int

  """
  Le nom de la mention (unique).
  """
  nom: String

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String
  nom_import: String
}

"""
order by min() on columns of table "ec.mention"
"""
input ec_mention_min_order_by {
  cursus_id: order_by

  """
  L'identifiant unique de la mention.
  """
  id: order_by

  """
  Le nom de la mention (unique).
  """
  nom: order_by

  """
  Le nom abrégé (optionnel).
  """
  nom_court: order_by
  nom_import: order_by
}

"""
response of any mutation on the table "ec.mention"
"""
type ec_mention_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [ec_mention!]!
}

"""
input type for inserting object relation for remote table "ec.mention"
"""
input ec_mention_obj_rel_insert_input {
  data: ec_mention_insert_input!

  """
  upsert condition
  """
  on_conflict: ec_mention_on_conflict
}

"""
on_conflict condition type for table "ec.mention"
"""
input ec_mention_on_conflict {
  constraint: ec_mention_constraint!
  update_columns: [ec_mention_update_column!]! = []
  where: ec_mention_bool_exp
}

"""
Ordering options when selecting data from "ec.mention".
"""
input ec_mention_order_by {
  cursus: ec_cursus_order_by
  cursus_id: order_by
  enseignements_aggregate: ec_enseignement_aggregate_order_by
  id: order_by
  nom: order_by
  nom_court: order_by
  nom_import: order_by
  parcours_aggregate: ec_parcours_aggregate_order_by
  responsables_aggregate: ec_responsable_aggregate_order_by
  visible: order_by
}

"""
primary key columns input for table: ec.mention
"""
input ec_mention_pk_columns_input {
  """
  L'identifiant unique de la mention.
  """
  id: Int!
}

"""
select columns of table "ec.mention"
"""
enum ec_mention_select_column {
  """
  column name
  """
  cursus_id

  """
  column name
  """
  id

  """
  column name
  """
  nom

  """
  column name
  """
  nom_court

  """
  column name
  """
  nom_import

  """
  column name
  """
  visible
}

"""
select "ec_mention_aggregate_bool_exp_bool_and_arguments_columns" columns of table "ec.mention"
"""
enum ec_mention_select_column_ec_mention_aggregate_bool_exp_bool_and_arguments_columns {
  """
  column name
  """
  visible
}

"""
select "ec_mention_aggregate_bool_exp_bool_or_arguments_columns" columns of table "ec.mention"
"""
enum ec_mention_select_column_ec_mention_aggregate_bool_exp_bool_or_arguments_columns {
  """
  column name
  """
  visible
}

"""
input type for updating data in table "ec.mention"
"""
input ec_mention_set_input {
  cursus_id: Int

  """
  L'identifiant unique de la mention.
  """
  id: Int

  """
  Le nom de la mention (unique).
  """
  nom: String

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String
  nom_import: String

  """
  Indique si la mention correspondante est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate stddev on columns
"""
type ec_mention_stddev_fields {
  cursus_id: Float

  """
  L'identifiant unique de la mention.
  """
  id: Float
}

"""
order by stddev() on columns of table "ec.mention"
"""
input ec_mention_stddev_order_by {
  cursus_id: order_by

  """
  L'identifiant unique de la mention.
  """
  id: order_by
}

"""
aggregate stddev_pop on columns
"""
type ec_mention_stddev_pop_fields {
  cursus_id: Float

  """
  L'identifiant unique de la mention.
  """
  id: Float
}

"""
order by stddev_pop() on columns of table "ec.mention"
"""
input ec_mention_stddev_pop_order_by {
  cursus_id: order_by

  """
  L'identifiant unique de la mention.
  """
  id: order_by
}

"""
aggregate stddev_samp on columns
"""
type ec_mention_stddev_samp_fields {
  cursus_id: Float

  """
  L'identifiant unique de la mention.
  """
  id: Float
}

"""
order by stddev_samp() on columns of table "ec.mention"
"""
input ec_mention_stddev_samp_order_by {
  cursus_id: order_by

  """
  L'identifiant unique de la mention.
  """
  id: order_by
}

"""
Streaming cursor of the table "ec_mention"
"""
input ec_mention_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: ec_mention_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input ec_mention_stream_cursor_value_input {
  cursus_id: Int

  """
  L'identifiant unique de la mention.
  """
  id: Int

  """
  Le nom de la mention (unique).
  """
  nom: String

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String
  nom_import: String

  """
  Indique si la mention correspondante est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate sum on columns
"""
type ec_mention_sum_fields {
  cursus_id: Int

  """
  L'identifiant unique de la mention.
  """
  id: Int
}

"""
order by sum() on columns of table "ec.mention"
"""
input ec_mention_sum_order_by {
  cursus_id: order_by

  """
  L'identifiant unique de la mention.
  """
  id: order_by
}

"""
update columns of table "ec.mention"
"""
enum ec_mention_update_column {
  """
  column name
  """
  cursus_id

  """
  column name
  """
  id

  """
  column name
  """
  nom

  """
  column name
  """
  nom_court

  """
  column name
  """
  nom_import

  """
  column name
  """
  visible
}

input ec_mention_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: ec_mention_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: ec_mention_set_input

  """
  filter the rows which have to be updated
  """
  where: ec_mention_bool_exp!
}

"""
aggregate var_pop on columns
"""
type ec_mention_var_pop_fields {
  cursus_id: Float

  """
  L'identifiant unique de la mention.
  """
  id: Float
}

"""
order by var_pop() on columns of table "ec.mention"
"""
input ec_mention_var_pop_order_by {
  cursus_id: order_by

  """
  L'identifiant unique de la mention.
  """
  id: order_by
}

"""
aggregate var_samp on columns
"""
type ec_mention_var_samp_fields {
  cursus_id: Float

  """
  L'identifiant unique de la mention.
  """
  id: Float
}

"""
order by var_samp() on columns of table "ec.mention"
"""
input ec_mention_var_samp_order_by {
  cursus_id: order_by

  """
  L'identifiant unique de la mention.
  """
  id: order_by
}

"""
aggregate variance on columns
"""
type ec_mention_variance_fields {
  cursus_id: Float

  """
  L'identifiant unique de la mention.
  """
  id: Float
}

"""
order by variance() on columns of table "ec.mention"
"""
input ec_mention_variance_order_by {
  cursus_id: order_by

  """
  L'identifiant unique de la mention.
  """
  id: order_by
}

"""
Table contenant les messages enregistrés sur Geyser.
"""
type ec_message {
  """
  L'année du message.
  """
  annee: Int!

  """
  An object relationship
  """
  anneeByAnnee: ec_annee!

  """
  Le contenu du message.
  """
  contenu: String!

  """
  L'identifiant unique du message.
  """
  id: Int!

  """
  An object relationship
  """
  intervenant: ec_intervenant!

  """
  Le type de message.
  """
  type: String!

  """
  An object relationship
  """
  type_message: ec_type_message!

  """
  L'identifiant de l'intervenant concerné.
  """
  uid: String!
}

"""
aggregated selection of "ec.message"
"""
type ec_message_aggregate {
  aggregate: ec_message_aggregate_fields
  nodes: [ec_message!]!
}

input ec_message_aggregate_bool_exp {
  count: ec_message_aggregate_bool_exp_count
}

input ec_message_aggregate_bool_exp_count {
  arguments: [ec_message_select_column!]
  distinct: Boolean
  filter: ec_message_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "ec.message"
"""
type ec_message_aggregate_fields {
  avg: ec_message_avg_fields
  count(columns: [ec_message_select_column!], distinct: Boolean): Int!
  max: ec_message_max_fields
  min: ec_message_min_fields
  stddev: ec_message_stddev_fields
  stddev_pop: ec_message_stddev_pop_fields
  stddev_samp: ec_message_stddev_samp_fields
  sum: ec_message_sum_fields
  var_pop: ec_message_var_pop_fields
  var_samp: ec_message_var_samp_fields
  variance: ec_message_variance_fields
}

"""
order by aggregate values of table "ec.message"
"""
input ec_message_aggregate_order_by {
  avg: ec_message_avg_order_by
  count: order_by
  max: ec_message_max_order_by
  min: ec_message_min_order_by
  stddev: ec_message_stddev_order_by
  stddev_pop: ec_message_stddev_pop_order_by
  stddev_samp: ec_message_stddev_samp_order_by
  sum: ec_message_sum_order_by
  var_pop: ec_message_var_pop_order_by
  var_samp: ec_message_var_samp_order_by
  variance: ec_message_variance_order_by
}

"""
input type for inserting array relation for remote table "ec.message"
"""
input ec_message_arr_rel_insert_input {
  data: [ec_message_insert_input!]!

  """
  upsert condition
  """
  on_conflict: ec_message_on_conflict
}

"""
aggregate avg on columns
"""
type ec_message_avg_fields {
  """
  L'année du message.
  """
  annee: Float

  """
  L'identifiant unique du message.
  """
  id: Float
}

"""
order by avg() on columns of table "ec.message"
"""
input ec_message_avg_order_by {
  """
  L'année du message.
  """
  annee: order_by

  """
  L'identifiant unique du message.
  """
  id: order_by
}

"""
Boolean expression to filter rows from the table "ec.message". All fields are combined with a logical 'AND'.
"""
input ec_message_bool_exp {
  _and: [ec_message_bool_exp!]
  _not: ec_message_bool_exp
  _or: [ec_message_bool_exp!]
  annee: Int_comparison_exp
  anneeByAnnee: ec_annee_bool_exp
  contenu: String_comparison_exp
  id: Int_comparison_exp
  intervenant: ec_intervenant_bool_exp
  type: String_comparison_exp
  type_message: ec_type_message_bool_exp
  uid: String_comparison_exp
}

"""
unique or primary key constraints on table "ec.message"
"""
enum ec_message_constraint {
  """
  unique or primary key constraint on columns "annee", "uid", "type"
  """
  message_annee_uid_type_key

  """
  unique or primary key constraint on columns "id"
  """
  message_pkey
}

"""
input type for incrementing numeric columns in table "ec.message"
"""
input ec_message_inc_input {
  """
  L'année du message.
  """
  annee: Int

  """
  L'identifiant unique du message.
  """
  id: Int
}

"""
input type for inserting data into table "ec.message"
"""
input ec_message_insert_input {
  """
  L'année du message.
  """
  annee: Int
  anneeByAnnee: ec_annee_obj_rel_insert_input

  """
  Le contenu du message.
  """
  contenu: String

  """
  L'identifiant unique du message.
  """
  id: Int
  intervenant: ec_intervenant_obj_rel_insert_input

  """
  Le type de message.
  """
  type: String
  type_message: ec_type_message_obj_rel_insert_input

  """
  L'identifiant de l'intervenant concerné.
  """
  uid: String
}

"""
aggregate max on columns
"""
type ec_message_max_fields {
  """
  L'année du message.
  """
  annee: Int

  """
  Le contenu du message.
  """
  contenu: String

  """
  L'identifiant unique du message.
  """
  id: Int

  """
  Le type de message.
  """
  type: String

  """
  L'identifiant de l'intervenant concerné.
  """
  uid: String
}

"""
order by max() on columns of table "ec.message"
"""
input ec_message_max_order_by {
  """
  L'année du message.
  """
  annee: order_by

  """
  Le contenu du message.
  """
  contenu: order_by

  """
  L'identifiant unique du message.
  """
  id: order_by

  """
  Le type de message.
  """
  type: order_by

  """
  L'identifiant de l'intervenant concerné.
  """
  uid: order_by
}

"""
aggregate min on columns
"""
type ec_message_min_fields {
  """
  L'année du message.
  """
  annee: Int

  """
  Le contenu du message.
  """
  contenu: String

  """
  L'identifiant unique du message.
  """
  id: Int

  """
  Le type de message.
  """
  type: String

  """
  L'identifiant de l'intervenant concerné.
  """
  uid: String
}

"""
order by min() on columns of table "ec.message"
"""
input ec_message_min_order_by {
  """
  L'année du message.
  """
  annee: order_by

  """
  Le contenu du message.
  """
  contenu: order_by

  """
  L'identifiant unique du message.
  """
  id: order_by

  """
  Le type de message.
  """
  type: order_by

  """
  L'identifiant de l'intervenant concerné.
  """
  uid: order_by
}

"""
response of any mutation on the table "ec.message"
"""
type ec_message_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [ec_message!]!
}

"""
on_conflict condition type for table "ec.message"
"""
input ec_message_on_conflict {
  constraint: ec_message_constraint!
  update_columns: [ec_message_update_column!]! = []
  where: ec_message_bool_exp
}

"""
Ordering options when selecting data from "ec.message".
"""
input ec_message_order_by {
  annee: order_by
  anneeByAnnee: ec_annee_order_by
  contenu: order_by
  id: order_by
  intervenant: ec_intervenant_order_by
  type: order_by
  type_message: ec_type_message_order_by
  uid: order_by
}

"""
primary key columns input for table: ec.message
"""
input ec_message_pk_columns_input {
  """
  L'identifiant unique du message.
  """
  id: Int!
}

"""
select columns of table "ec.message"
"""
enum ec_message_select_column {
  """
  column name
  """
  annee

  """
  column name
  """
  contenu

  """
  column name
  """
  id

  """
  column name
  """
  type

  """
  column name
  """
  uid
}

"""
input type for updating data in table "ec.message"
"""
input ec_message_set_input {
  """
  L'année du message.
  """
  annee: Int

  """
  Le contenu du message.
  """
  contenu: String

  """
  L'identifiant unique du message.
  """
  id: Int

  """
  Le type de message.
  """
  type: String

  """
  L'identifiant de l'intervenant concerné.
  """
  uid: String
}

"""
aggregate stddev on columns
"""
type ec_message_stddev_fields {
  """
  L'année du message.
  """
  annee: Float

  """
  L'identifiant unique du message.
  """
  id: Float
}

"""
order by stddev() on columns of table "ec.message"
"""
input ec_message_stddev_order_by {
  """
  L'année du message.
  """
  annee: order_by

  """
  L'identifiant unique du message.
  """
  id: order_by
}

"""
aggregate stddev_pop on columns
"""
type ec_message_stddev_pop_fields {
  """
  L'année du message.
  """
  annee: Float

  """
  L'identifiant unique du message.
  """
  id: Float
}

"""
order by stddev_pop() on columns of table "ec.message"
"""
input ec_message_stddev_pop_order_by {
  """
  L'année du message.
  """
  annee: order_by

  """
  L'identifiant unique du message.
  """
  id: order_by
}

"""
aggregate stddev_samp on columns
"""
type ec_message_stddev_samp_fields {
  """
  L'année du message.
  """
  annee: Float

  """
  L'identifiant unique du message.
  """
  id: Float
}

"""
order by stddev_samp() on columns of table "ec.message"
"""
input ec_message_stddev_samp_order_by {
  """
  L'année du message.
  """
  annee: order_by

  """
  L'identifiant unique du message.
  """
  id: order_by
}

"""
Streaming cursor of the table "ec_message"
"""
input ec_message_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: ec_message_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input ec_message_stream_cursor_value_input {
  """
  L'année du message.
  """
  annee: Int

  """
  Le contenu du message.
  """
  contenu: String

  """
  L'identifiant unique du message.
  """
  id: Int

  """
  Le type de message.
  """
  type: String

  """
  L'identifiant de l'intervenant concerné.
  """
  uid: String
}

"""
aggregate sum on columns
"""
type ec_message_sum_fields {
  """
  L'année du message.
  """
  annee: Int

  """
  L'identifiant unique du message.
  """
  id: Int
}

"""
order by sum() on columns of table "ec.message"
"""
input ec_message_sum_order_by {
  """
  L'année du message.
  """
  annee: order_by

  """
  L'identifiant unique du message.
  """
  id: order_by
}

"""
update columns of table "ec.message"
"""
enum ec_message_update_column {
  """
  column name
  """
  annee

  """
  column name
  """
  contenu

  """
  column name
  """
  id

  """
  column name
  """
  type

  """
  column name
  """
  uid
}

input ec_message_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: ec_message_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: ec_message_set_input

  """
  filter the rows which have to be updated
  """
  where: ec_message_bool_exp!
}

"""
aggregate var_pop on columns
"""
type ec_message_var_pop_fields {
  """
  L'année du message.
  """
  annee: Float

  """
  L'identifiant unique du message.
  """
  id: Float
}

"""
order by var_pop() on columns of table "ec.message"
"""
input ec_message_var_pop_order_by {
  """
  L'année du message.
  """
  annee: order_by

  """
  L'identifiant unique du message.
  """
  id: order_by
}

"""
aggregate var_samp on columns
"""
type ec_message_var_samp_fields {
  """
  L'année du message.
  """
  annee: Float

  """
  L'identifiant unique du message.
  """
  id: Float
}

"""
order by var_samp() on columns of table "ec.message"
"""
input ec_message_var_samp_order_by {
  """
  L'année du message.
  """
  annee: order_by

  """
  L'identifiant unique du message.
  """
  id: order_by
}

"""
aggregate variance on columns
"""
type ec_message_variance_fields {
  """
  L'année du message.
  """
  annee: Float

  """
  L'identifiant unique du message.
  """
  id: Float
}

"""
order by variance() on columns of table "ec.message"
"""
input ec_message_variance_order_by {
  """
  L'année du message.
  """
  annee: order_by

  """
  L'identifiant unique du message.
  """
  id: order_by
}

"""
Table contenant les modifications du service de base d'un intervenant donné pour une année donnée.
"""
type ec_modification_service {
  """
  L'année correspondant au service modifié.
  """
  annee: Int!

  """
  An object relationship
  """
  anneeByAnnee: ec_annee!

  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: Float!

  """
  L'identifiant unique de la modification.
  """
  id: Int!

  """
  An object relationship
  """
  intervenant: ec_intervenant!

  """
  Le type de modification.
  """
  type: String!

  """
  An object relationship
  """
  type_modification: ec_type_modification!

  """
  L'identifiant de l'intervenant correspondant au service modifié.
  """
  uid: String!
}

"""
aggregated selection of "ec.modification_service"
"""
type ec_modification_service_aggregate {
  aggregate: ec_modification_service_aggregate_fields
  nodes: [ec_modification_service!]!
}

input ec_modification_service_aggregate_bool_exp {
  count: ec_modification_service_aggregate_bool_exp_count
}

input ec_modification_service_aggregate_bool_exp_count {
  arguments: [ec_modification_service_select_column!]
  distinct: Boolean
  filter: ec_modification_service_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "ec.modification_service"
"""
type ec_modification_service_aggregate_fields {
  avg: ec_modification_service_avg_fields
  count(
    columns: [ec_modification_service_select_column!]
    distinct: Boolean
  ): Int!
  max: ec_modification_service_max_fields
  min: ec_modification_service_min_fields
  stddev: ec_modification_service_stddev_fields
  stddev_pop: ec_modification_service_stddev_pop_fields
  stddev_samp: ec_modification_service_stddev_samp_fields
  sum: ec_modification_service_sum_fields
  var_pop: ec_modification_service_var_pop_fields
  var_samp: ec_modification_service_var_samp_fields
  variance: ec_modification_service_variance_fields
}

"""
order by aggregate values of table "ec.modification_service"
"""
input ec_modification_service_aggregate_order_by {
  avg: ec_modification_service_avg_order_by
  count: order_by
  max: ec_modification_service_max_order_by
  min: ec_modification_service_min_order_by
  stddev: ec_modification_service_stddev_order_by
  stddev_pop: ec_modification_service_stddev_pop_order_by
  stddev_samp: ec_modification_service_stddev_samp_order_by
  sum: ec_modification_service_sum_order_by
  var_pop: ec_modification_service_var_pop_order_by
  var_samp: ec_modification_service_var_samp_order_by
  variance: ec_modification_service_variance_order_by
}

"""
input type for inserting array relation for remote table "ec.modification_service"
"""
input ec_modification_service_arr_rel_insert_input {
  data: [ec_modification_service_insert_input!]!

  """
  upsert condition
  """
  on_conflict: ec_modification_service_on_conflict
}

"""
aggregate avg on columns
"""
type ec_modification_service_avg_fields {
  """
  L'année correspondant au service modifié.
  """
  annee: Float

  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: Float

  """
  L'identifiant unique de la modification.
  """
  id: Float
}

"""
order by avg() on columns of table "ec.modification_service"
"""
input ec_modification_service_avg_order_by {
  """
  L'année correspondant au service modifié.
  """
  annee: order_by

  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: order_by

  """
  L'identifiant unique de la modification.
  """
  id: order_by
}

"""
Boolean expression to filter rows from the table "ec.modification_service". All fields are combined with a logical 'AND'.
"""
input ec_modification_service_bool_exp {
  _and: [ec_modification_service_bool_exp!]
  _not: ec_modification_service_bool_exp
  _or: [ec_modification_service_bool_exp!]
  annee: Int_comparison_exp
  anneeByAnnee: ec_annee_bool_exp
  heures_eqtd: Float_comparison_exp
  id: Int_comparison_exp
  intervenant: ec_intervenant_bool_exp
  type: String_comparison_exp
  type_modification: ec_type_modification_bool_exp
  uid: String_comparison_exp
}

"""
unique or primary key constraints on table "ec.modification_service"
"""
enum ec_modification_service_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  modification_service_pkey
}

"""
input type for incrementing numeric columns in table "ec.modification_service"
"""
input ec_modification_service_inc_input {
  """
  L'année correspondant au service modifié.
  """
  annee: Int

  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: Float

  """
  L'identifiant unique de la modification.
  """
  id: Int
}

"""
input type for inserting data into table "ec.modification_service"
"""
input ec_modification_service_insert_input {
  """
  L'année correspondant au service modifié.
  """
  annee: Int
  anneeByAnnee: ec_annee_obj_rel_insert_input

  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: Float

  """
  L'identifiant unique de la modification.
  """
  id: Int
  intervenant: ec_intervenant_obj_rel_insert_input

  """
  Le type de modification.
  """
  type: String
  type_modification: ec_type_modification_obj_rel_insert_input

  """
  L'identifiant de l'intervenant correspondant au service modifié.
  """
  uid: String
}

"""
aggregate max on columns
"""
type ec_modification_service_max_fields {
  """
  L'année correspondant au service modifié.
  """
  annee: Int

  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: Float

  """
  L'identifiant unique de la modification.
  """
  id: Int

  """
  Le type de modification.
  """
  type: String

  """
  L'identifiant de l'intervenant correspondant au service modifié.
  """
  uid: String
}

"""
order by max() on columns of table "ec.modification_service"
"""
input ec_modification_service_max_order_by {
  """
  L'année correspondant au service modifié.
  """
  annee: order_by

  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: order_by

  """
  L'identifiant unique de la modification.
  """
  id: order_by

  """
  Le type de modification.
  """
  type: order_by

  """
  L'identifiant de l'intervenant correspondant au service modifié.
  """
  uid: order_by
}

"""
aggregate min on columns
"""
type ec_modification_service_min_fields {
  """
  L'année correspondant au service modifié.
  """
  annee: Int

  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: Float

  """
  L'identifiant unique de la modification.
  """
  id: Int

  """
  Le type de modification.
  """
  type: String

  """
  L'identifiant de l'intervenant correspondant au service modifié.
  """
  uid: String
}

"""
order by min() on columns of table "ec.modification_service"
"""
input ec_modification_service_min_order_by {
  """
  L'année correspondant au service modifié.
  """
  annee: order_by

  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: order_by

  """
  L'identifiant unique de la modification.
  """
  id: order_by

  """
  Le type de modification.
  """
  type: order_by

  """
  L'identifiant de l'intervenant correspondant au service modifié.
  """
  uid: order_by
}

"""
response of any mutation on the table "ec.modification_service"
"""
type ec_modification_service_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [ec_modification_service!]!
}

"""
on_conflict condition type for table "ec.modification_service"
"""
input ec_modification_service_on_conflict {
  constraint: ec_modification_service_constraint!
  update_columns: [ec_modification_service_update_column!]! = []
  where: ec_modification_service_bool_exp
}

"""
Ordering options when selecting data from "ec.modification_service".
"""
input ec_modification_service_order_by {
  annee: order_by
  anneeByAnnee: ec_annee_order_by
  heures_eqtd: order_by
  id: order_by
  intervenant: ec_intervenant_order_by
  type: order_by
  type_modification: ec_type_modification_order_by
  uid: order_by
}

"""
primary key columns input for table: ec.modification_service
"""
input ec_modification_service_pk_columns_input {
  """
  L'identifiant unique de la modification.
  """
  id: Int!
}

"""
select columns of table "ec.modification_service"
"""
enum ec_modification_service_select_column {
  """
  column name
  """
  annee

  """
  column name
  """
  heures_eqtd

  """
  column name
  """
  id

  """
  column name
  """
  type

  """
  column name
  """
  uid
}

"""
input type for updating data in table "ec.modification_service"
"""
input ec_modification_service_set_input {
  """
  L'année correspondant au service modifié.
  """
  annee: Int

  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: Float

  """
  L'identifiant unique de la modification.
  """
  id: Int

  """
  Le type de modification.
  """
  type: String

  """
  L'identifiant de l'intervenant correspondant au service modifié.
  """
  uid: String
}

"""
aggregate stddev on columns
"""
type ec_modification_service_stddev_fields {
  """
  L'année correspondant au service modifié.
  """
  annee: Float

  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: Float

  """
  L'identifiant unique de la modification.
  """
  id: Float
}

"""
order by stddev() on columns of table "ec.modification_service"
"""
input ec_modification_service_stddev_order_by {
  """
  L'année correspondant au service modifié.
  """
  annee: order_by

  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: order_by

  """
  L'identifiant unique de la modification.
  """
  id: order_by
}

"""
aggregate stddev_pop on columns
"""
type ec_modification_service_stddev_pop_fields {
  """
  L'année correspondant au service modifié.
  """
  annee: Float

  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: Float

  """
  L'identifiant unique de la modification.
  """
  id: Float
}

"""
order by stddev_pop() on columns of table "ec.modification_service"
"""
input ec_modification_service_stddev_pop_order_by {
  """
  L'année correspondant au service modifié.
  """
  annee: order_by

  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: order_by

  """
  L'identifiant unique de la modification.
  """
  id: order_by
}

"""
aggregate stddev_samp on columns
"""
type ec_modification_service_stddev_samp_fields {
  """
  L'année correspondant au service modifié.
  """
  annee: Float

  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: Float

  """
  L'identifiant unique de la modification.
  """
  id: Float
}

"""
order by stddev_samp() on columns of table "ec.modification_service"
"""
input ec_modification_service_stddev_samp_order_by {
  """
  L'année correspondant au service modifié.
  """
  annee: order_by

  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: order_by

  """
  L'identifiant unique de la modification.
  """
  id: order_by
}

"""
Streaming cursor of the table "ec_modification_service"
"""
input ec_modification_service_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: ec_modification_service_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input ec_modification_service_stream_cursor_value_input {
  """
  L'année correspondant au service modifié.
  """
  annee: Int

  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: Float

  """
  L'identifiant unique de la modification.
  """
  id: Int

  """
  Le type de modification.
  """
  type: String

  """
  L'identifiant de l'intervenant correspondant au service modifié.
  """
  uid: String
}

"""
aggregate sum on columns
"""
type ec_modification_service_sum_fields {
  """
  L'année correspondant au service modifié.
  """
  annee: Int

  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: Float

  """
  L'identifiant unique de la modification.
  """
  id: Int
}

"""
order by sum() on columns of table "ec.modification_service"
"""
input ec_modification_service_sum_order_by {
  """
  L'année correspondant au service modifié.
  """
  annee: order_by

  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: order_by

  """
  L'identifiant unique de la modification.
  """
  id: order_by
}

"""
update columns of table "ec.modification_service"
"""
enum ec_modification_service_update_column {
  """
  column name
  """
  annee

  """
  column name
  """
  heures_eqtd

  """
  column name
  """
  id

  """
  column name
  """
  type

  """
  column name
  """
  uid
}

input ec_modification_service_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: ec_modification_service_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: ec_modification_service_set_input

  """
  filter the rows which have to be updated
  """
  where: ec_modification_service_bool_exp!
}

"""
aggregate var_pop on columns
"""
type ec_modification_service_var_pop_fields {
  """
  L'année correspondant au service modifié.
  """
  annee: Float

  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: Float

  """
  L'identifiant unique de la modification.
  """
  id: Float
}

"""
order by var_pop() on columns of table "ec.modification_service"
"""
input ec_modification_service_var_pop_order_by {
  """
  L'année correspondant au service modifié.
  """
  annee: order_by

  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: order_by

  """
  L'identifiant unique de la modification.
  """
  id: order_by
}

"""
aggregate var_samp on columns
"""
type ec_modification_service_var_samp_fields {
  """
  L'année correspondant au service modifié.
  """
  annee: Float

  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: Float

  """
  L'identifiant unique de la modification.
  """
  id: Float
}

"""
order by var_samp() on columns of table "ec.modification_service"
"""
input ec_modification_service_var_samp_order_by {
  """
  L'année correspondant au service modifié.
  """
  annee: order_by

  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: order_by

  """
  L'identifiant unique de la modification.
  """
  id: order_by
}

"""
aggregate variance on columns
"""
type ec_modification_service_variance_fields {
  """
  L'année correspondant au service modifié.
  """
  annee: Float

  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: Float

  """
  L'identifiant unique de la modification.
  """
  id: Float
}

"""
order by variance() on columns of table "ec.modification_service"
"""
input ec_modification_service_variance_order_by {
  """
  L'année correspondant au service modifié.
  """
  annee: order_by

  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: order_by

  """
  L'identifiant unique de la modification.
  """
  id: order_by
}

"""
Table contenant les différents parcours.
"""
type ec_parcours {
  """
  An array relationship
  """
  enseignements(
    """
    distinct select on columns
    """
    distinct_on: [ec_enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_enseignement_order_by!]

    """
    filter the rows returned
    """
    where: ec_enseignement_bool_exp
  ): [ec_enseignement!]!

  """
  An aggregate relationship
  """
  enseignements_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_enseignement_order_by!]

    """
    filter the rows returned
    """
    where: ec_enseignement_bool_exp
  ): ec_enseignement_aggregate!

  """
  L'identifiant unique du parcours.
  """
  id: Int!

  """
  An object relationship
  """
  mention: ec_mention!
  mention_id: Int!

  """
  Le nom du parcours (unique).
  """
  nom: String!

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String
  nom_import: String

  """
  An array relationship
  """
  responsables(
    """
    distinct select on columns
    """
    distinct_on: [ec_responsable_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_responsable_order_by!]

    """
    filter the rows returned
    """
    where: ec_responsable_bool_exp
  ): [ec_responsable!]!

  """
  An aggregate relationship
  """
  responsables_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_responsable_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_responsable_order_by!]

    """
    filter the rows returned
    """
    where: ec_responsable_bool_exp
  ): ec_responsable_aggregate!

  """
  Indique si le parcours correspondant est visible par les utilisateurs.
  """
  visible: Boolean!
}

"""
aggregated selection of "ec.parcours"
"""
type ec_parcours_aggregate {
  aggregate: ec_parcours_aggregate_fields
  nodes: [ec_parcours!]!
}

input ec_parcours_aggregate_bool_exp {
  bool_and: ec_parcours_aggregate_bool_exp_bool_and
  bool_or: ec_parcours_aggregate_bool_exp_bool_or
  count: ec_parcours_aggregate_bool_exp_count
}

input ec_parcours_aggregate_bool_exp_bool_and {
  arguments: ec_parcours_select_column_ec_parcours_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: ec_parcours_bool_exp
  predicate: Boolean_comparison_exp!
}

input ec_parcours_aggregate_bool_exp_bool_or {
  arguments: ec_parcours_select_column_ec_parcours_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: ec_parcours_bool_exp
  predicate: Boolean_comparison_exp!
}

input ec_parcours_aggregate_bool_exp_count {
  arguments: [ec_parcours_select_column!]
  distinct: Boolean
  filter: ec_parcours_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "ec.parcours"
"""
type ec_parcours_aggregate_fields {
  avg: ec_parcours_avg_fields
  count(columns: [ec_parcours_select_column!], distinct: Boolean): Int!
  max: ec_parcours_max_fields
  min: ec_parcours_min_fields
  stddev: ec_parcours_stddev_fields
  stddev_pop: ec_parcours_stddev_pop_fields
  stddev_samp: ec_parcours_stddev_samp_fields
  sum: ec_parcours_sum_fields
  var_pop: ec_parcours_var_pop_fields
  var_samp: ec_parcours_var_samp_fields
  variance: ec_parcours_variance_fields
}

"""
order by aggregate values of table "ec.parcours"
"""
input ec_parcours_aggregate_order_by {
  avg: ec_parcours_avg_order_by
  count: order_by
  max: ec_parcours_max_order_by
  min: ec_parcours_min_order_by
  stddev: ec_parcours_stddev_order_by
  stddev_pop: ec_parcours_stddev_pop_order_by
  stddev_samp: ec_parcours_stddev_samp_order_by
  sum: ec_parcours_sum_order_by
  var_pop: ec_parcours_var_pop_order_by
  var_samp: ec_parcours_var_samp_order_by
  variance: ec_parcours_variance_order_by
}

"""
input type for inserting array relation for remote table "ec.parcours"
"""
input ec_parcours_arr_rel_insert_input {
  data: [ec_parcours_insert_input!]!

  """
  upsert condition
  """
  on_conflict: ec_parcours_on_conflict
}

"""
aggregate avg on columns
"""
type ec_parcours_avg_fields {
  """
  L'identifiant unique du parcours.
  """
  id: Float
  mention_id: Float
}

"""
order by avg() on columns of table "ec.parcours"
"""
input ec_parcours_avg_order_by {
  """
  L'identifiant unique du parcours.
  """
  id: order_by
  mention_id: order_by
}

"""
Boolean expression to filter rows from the table "ec.parcours". All fields are combined with a logical 'AND'.
"""
input ec_parcours_bool_exp {
  _and: [ec_parcours_bool_exp!]
  _not: ec_parcours_bool_exp
  _or: [ec_parcours_bool_exp!]
  enseignements: ec_enseignement_bool_exp
  enseignements_aggregate: ec_enseignement_aggregate_bool_exp
  id: Int_comparison_exp
  mention: ec_mention_bool_exp
  mention_id: Int_comparison_exp
  nom: String_comparison_exp
  nom_court: String_comparison_exp
  nom_import: String_comparison_exp
  responsables: ec_responsable_bool_exp
  responsables_aggregate: ec_responsable_aggregate_bool_exp
  visible: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "ec.parcours"
"""
enum ec_parcours_constraint {
  """
  unique or primary key constraint on columns "mention_id", "nom"
  """
  parcours_mention_id_nom_key

  """
  unique or primary key constraint on columns "id"
  """
  parcours_pkey
}

"""
input type for incrementing numeric columns in table "ec.parcours"
"""
input ec_parcours_inc_input {
  """
  L'identifiant unique du parcours.
  """
  id: Int
  mention_id: Int
}

"""
input type for inserting data into table "ec.parcours"
"""
input ec_parcours_insert_input {
  enseignements: ec_enseignement_arr_rel_insert_input

  """
  L'identifiant unique du parcours.
  """
  id: Int
  mention: ec_mention_obj_rel_insert_input
  mention_id: Int

  """
  Le nom du parcours (unique).
  """
  nom: String

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String
  nom_import: String
  responsables: ec_responsable_arr_rel_insert_input

  """
  Indique si le parcours correspondant est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate max on columns
"""
type ec_parcours_max_fields {
  """
  L'identifiant unique du parcours.
  """
  id: Int
  mention_id: Int

  """
  Le nom du parcours (unique).
  """
  nom: String

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String
  nom_import: String
}

"""
order by max() on columns of table "ec.parcours"
"""
input ec_parcours_max_order_by {
  """
  L'identifiant unique du parcours.
  """
  id: order_by
  mention_id: order_by

  """
  Le nom du parcours (unique).
  """
  nom: order_by

  """
  Le nom abrégé (optionnel).
  """
  nom_court: order_by
  nom_import: order_by
}

"""
aggregate min on columns
"""
type ec_parcours_min_fields {
  """
  L'identifiant unique du parcours.
  """
  id: Int
  mention_id: Int

  """
  Le nom du parcours (unique).
  """
  nom: String

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String
  nom_import: String
}

"""
order by min() on columns of table "ec.parcours"
"""
input ec_parcours_min_order_by {
  """
  L'identifiant unique du parcours.
  """
  id: order_by
  mention_id: order_by

  """
  Le nom du parcours (unique).
  """
  nom: order_by

  """
  Le nom abrégé (optionnel).
  """
  nom_court: order_by
  nom_import: order_by
}

"""
response of any mutation on the table "ec.parcours"
"""
type ec_parcours_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [ec_parcours!]!
}

"""
input type for inserting object relation for remote table "ec.parcours"
"""
input ec_parcours_obj_rel_insert_input {
  data: ec_parcours_insert_input!

  """
  upsert condition
  """
  on_conflict: ec_parcours_on_conflict
}

"""
on_conflict condition type for table "ec.parcours"
"""
input ec_parcours_on_conflict {
  constraint: ec_parcours_constraint!
  update_columns: [ec_parcours_update_column!]! = []
  where: ec_parcours_bool_exp
}

"""
Ordering options when selecting data from "ec.parcours".
"""
input ec_parcours_order_by {
  enseignements_aggregate: ec_enseignement_aggregate_order_by
  id: order_by
  mention: ec_mention_order_by
  mention_id: order_by
  nom: order_by
  nom_court: order_by
  nom_import: order_by
  responsables_aggregate: ec_responsable_aggregate_order_by
  visible: order_by
}

"""
primary key columns input for table: ec.parcours
"""
input ec_parcours_pk_columns_input {
  """
  L'identifiant unique du parcours.
  """
  id: Int!
}

"""
select columns of table "ec.parcours"
"""
enum ec_parcours_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  mention_id

  """
  column name
  """
  nom

  """
  column name
  """
  nom_court

  """
  column name
  """
  nom_import

  """
  column name
  """
  visible
}

"""
select "ec_parcours_aggregate_bool_exp_bool_and_arguments_columns" columns of table "ec.parcours"
"""
enum ec_parcours_select_column_ec_parcours_aggregate_bool_exp_bool_and_arguments_columns {
  """
  column name
  """
  visible
}

"""
select "ec_parcours_aggregate_bool_exp_bool_or_arguments_columns" columns of table "ec.parcours"
"""
enum ec_parcours_select_column_ec_parcours_aggregate_bool_exp_bool_or_arguments_columns {
  """
  column name
  """
  visible
}

"""
input type for updating data in table "ec.parcours"
"""
input ec_parcours_set_input {
  """
  L'identifiant unique du parcours.
  """
  id: Int
  mention_id: Int

  """
  Le nom du parcours (unique).
  """
  nom: String

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String
  nom_import: String

  """
  Indique si le parcours correspondant est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate stddev on columns
"""
type ec_parcours_stddev_fields {
  """
  L'identifiant unique du parcours.
  """
  id: Float
  mention_id: Float
}

"""
order by stddev() on columns of table "ec.parcours"
"""
input ec_parcours_stddev_order_by {
  """
  L'identifiant unique du parcours.
  """
  id: order_by
  mention_id: order_by
}

"""
aggregate stddev_pop on columns
"""
type ec_parcours_stddev_pop_fields {
  """
  L'identifiant unique du parcours.
  """
  id: Float
  mention_id: Float
}

"""
order by stddev_pop() on columns of table "ec.parcours"
"""
input ec_parcours_stddev_pop_order_by {
  """
  L'identifiant unique du parcours.
  """
  id: order_by
  mention_id: order_by
}

"""
aggregate stddev_samp on columns
"""
type ec_parcours_stddev_samp_fields {
  """
  L'identifiant unique du parcours.
  """
  id: Float
  mention_id: Float
}

"""
order by stddev_samp() on columns of table "ec.parcours"
"""
input ec_parcours_stddev_samp_order_by {
  """
  L'identifiant unique du parcours.
  """
  id: order_by
  mention_id: order_by
}

"""
Streaming cursor of the table "ec_parcours"
"""
input ec_parcours_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: ec_parcours_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input ec_parcours_stream_cursor_value_input {
  """
  L'identifiant unique du parcours.
  """
  id: Int
  mention_id: Int

  """
  Le nom du parcours (unique).
  """
  nom: String

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String
  nom_import: String

  """
  Indique si le parcours correspondant est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate sum on columns
"""
type ec_parcours_sum_fields {
  """
  L'identifiant unique du parcours.
  """
  id: Int
  mention_id: Int
}

"""
order by sum() on columns of table "ec.parcours"
"""
input ec_parcours_sum_order_by {
  """
  L'identifiant unique du parcours.
  """
  id: order_by
  mention_id: order_by
}

"""
update columns of table "ec.parcours"
"""
enum ec_parcours_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  mention_id

  """
  column name
  """
  nom

  """
  column name
  """
  nom_court

  """
  column name
  """
  nom_import

  """
  column name
  """
  visible
}

input ec_parcours_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: ec_parcours_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: ec_parcours_set_input

  """
  filter the rows which have to be updated
  """
  where: ec_parcours_bool_exp!
}

"""
aggregate var_pop on columns
"""
type ec_parcours_var_pop_fields {
  """
  L'identifiant unique du parcours.
  """
  id: Float
  mention_id: Float
}

"""
order by var_pop() on columns of table "ec.parcours"
"""
input ec_parcours_var_pop_order_by {
  """
  L'identifiant unique du parcours.
  """
  id: order_by
  mention_id: order_by
}

"""
aggregate var_samp on columns
"""
type ec_parcours_var_samp_fields {
  """
  L'identifiant unique du parcours.
  """
  id: Float
  mention_id: Float
}

"""
order by var_samp() on columns of table "ec.parcours"
"""
input ec_parcours_var_samp_order_by {
  """
  L'identifiant unique du parcours.
  """
  id: order_by
  mention_id: order_by
}

"""
aggregate variance on columns
"""
type ec_parcours_variance_fields {
  """
  L'identifiant unique du parcours.
  """
  id: Float
  mention_id: Float
}

"""
order by variance() on columns of table "ec.parcours"
"""
input ec_parcours_variance_order_by {
  """
  L'identifiant unique du parcours.
  """
  id: order_by
  mention_id: order_by
}

"""
Table contenant les différentes phases (voeux, commission et consultation). D'autres phases pourront être ajoutées par la suite.
"""
type ec_phase {
  """
  Une brève description.
  """
  description: String

  """
  Indique si la phase correspondante est la phase en cours (TRUE) ou non (NULL). Une seule phase peut être en cours à la fois.
  """
  en_cours: Boolean

  """
  Le nom de la phase (unique).
  """
  value: String!

  """
  Indique si la phase correspondante est visible par les utilisateurs.
  """
  visible: Boolean!
}

"""
aggregated selection of "ec.phase"
"""
type ec_phase_aggregate {
  aggregate: ec_phase_aggregate_fields
  nodes: [ec_phase!]!
}

"""
aggregate fields of "ec.phase"
"""
type ec_phase_aggregate_fields {
  count(columns: [ec_phase_select_column!], distinct: Boolean): Int!
  max: ec_phase_max_fields
  min: ec_phase_min_fields
}

"""
Boolean expression to filter rows from the table "ec.phase". All fields are combined with a logical 'AND'.
"""
input ec_phase_bool_exp {
  _and: [ec_phase_bool_exp!]
  _not: ec_phase_bool_exp
  _or: [ec_phase_bool_exp!]
  description: String_comparison_exp
  en_cours: Boolean_comparison_exp
  value: String_comparison_exp
  visible: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "ec.phase"
"""
enum ec_phase_constraint {
  """
  unique or primary key constraint on columns "en_cours"
  """
  phase_en_cours_key

  """
  unique or primary key constraint on columns "value"
  """
  phase_pkey
}

"""
input type for inserting data into table "ec.phase"
"""
input ec_phase_insert_input {
  """
  Une brève description.
  """
  description: String

  """
  Indique si la phase correspondante est la phase en cours (TRUE) ou non (NULL). Une seule phase peut être en cours à la fois.
  """
  en_cours: Boolean

  """
  Le nom de la phase (unique).
  """
  value: String

  """
  Indique si la phase correspondante est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate max on columns
"""
type ec_phase_max_fields {
  """
  Une brève description.
  """
  description: String

  """
  Le nom de la phase (unique).
  """
  value: String
}

"""
aggregate min on columns
"""
type ec_phase_min_fields {
  """
  Une brève description.
  """
  description: String

  """
  Le nom de la phase (unique).
  """
  value: String
}

"""
response of any mutation on the table "ec.phase"
"""
type ec_phase_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [ec_phase!]!
}

"""
on_conflict condition type for table "ec.phase"
"""
input ec_phase_on_conflict {
  constraint: ec_phase_constraint!
  update_columns: [ec_phase_update_column!]! = []
  where: ec_phase_bool_exp
}

"""
Ordering options when selecting data from "ec.phase".
"""
input ec_phase_order_by {
  description: order_by
  en_cours: order_by
  value: order_by
  visible: order_by
}

"""
primary key columns input for table: ec.phase
"""
input ec_phase_pk_columns_input {
  """
  Le nom de la phase (unique).
  """
  value: String!
}

"""
select columns of table "ec.phase"
"""
enum ec_phase_select_column {
  """
  column name
  """
  description

  """
  column name
  """
  en_cours

  """
  column name
  """
  value

  """
  column name
  """
  visible
}

"""
input type for updating data in table "ec.phase"
"""
input ec_phase_set_input {
  """
  Une brève description.
  """
  description: String

  """
  Indique si la phase correspondante est la phase en cours (TRUE) ou non (NULL). Une seule phase peut être en cours à la fois.
  """
  en_cours: Boolean

  """
  Le nom de la phase (unique).
  """
  value: String

  """
  Indique si la phase correspondante est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
Streaming cursor of the table "ec_phase"
"""
input ec_phase_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: ec_phase_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input ec_phase_stream_cursor_value_input {
  """
  Une brève description.
  """
  description: String

  """
  Indique si la phase correspondante est la phase en cours (TRUE) ou non (NULL). Une seule phase peut être en cours à la fois.
  """
  en_cours: Boolean

  """
  Le nom de la phase (unique).
  """
  value: String

  """
  Indique si la phase correspondante est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
update columns of table "ec.phase"
"""
enum ec_phase_update_column {
  """
  column name
  """
  description

  """
  column name
  """
  en_cours

  """
  column name
  """
  value

  """
  column name
  """
  visible
}

input ec_phase_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: ec_phase_set_input

  """
  filter the rows which have to be updated
  """
  where: ec_phase_bool_exp!
}

"""
Table contenant les informations relatives à l'ancienneté et la priorité des intervenants sur les enseignements.
"""
type ec_priorite {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: Int

  """
  L'identifiant d'un enseignement.
  """
  ens_id: Int!

  """
  An object relationship
  """
  enseignement: ec_enseignement!
  id: Int!

  """
  An object relationship
  """
  intervenant: ec_intervenant!

  """
  Indique si l'intervenant est prioritaire sur l'enseignement.
  """
  prioritaire: Boolean

  """
  L'identifiant d'un intervenant.
  """
  uid: String!
}

"""
aggregated selection of "ec.priorite"
"""
type ec_priorite_aggregate {
  aggregate: ec_priorite_aggregate_fields
  nodes: [ec_priorite!]!
}

input ec_priorite_aggregate_bool_exp {
  bool_and: ec_priorite_aggregate_bool_exp_bool_and
  bool_or: ec_priorite_aggregate_bool_exp_bool_or
  count: ec_priorite_aggregate_bool_exp_count
}

input ec_priorite_aggregate_bool_exp_bool_and {
  arguments: ec_priorite_select_column_ec_priorite_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: ec_priorite_bool_exp
  predicate: Boolean_comparison_exp!
}

input ec_priorite_aggregate_bool_exp_bool_or {
  arguments: ec_priorite_select_column_ec_priorite_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: ec_priorite_bool_exp
  predicate: Boolean_comparison_exp!
}

input ec_priorite_aggregate_bool_exp_count {
  arguments: [ec_priorite_select_column!]
  distinct: Boolean
  filter: ec_priorite_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "ec.priorite"
"""
type ec_priorite_aggregate_fields {
  avg: ec_priorite_avg_fields
  count(columns: [ec_priorite_select_column!], distinct: Boolean): Int!
  max: ec_priorite_max_fields
  min: ec_priorite_min_fields
  stddev: ec_priorite_stddev_fields
  stddev_pop: ec_priorite_stddev_pop_fields
  stddev_samp: ec_priorite_stddev_samp_fields
  sum: ec_priorite_sum_fields
  var_pop: ec_priorite_var_pop_fields
  var_samp: ec_priorite_var_samp_fields
  variance: ec_priorite_variance_fields
}

"""
order by aggregate values of table "ec.priorite"
"""
input ec_priorite_aggregate_order_by {
  avg: ec_priorite_avg_order_by
  count: order_by
  max: ec_priorite_max_order_by
  min: ec_priorite_min_order_by
  stddev: ec_priorite_stddev_order_by
  stddev_pop: ec_priorite_stddev_pop_order_by
  stddev_samp: ec_priorite_stddev_samp_order_by
  sum: ec_priorite_sum_order_by
  var_pop: ec_priorite_var_pop_order_by
  var_samp: ec_priorite_var_samp_order_by
  variance: ec_priorite_variance_order_by
}

"""
input type for inserting array relation for remote table "ec.priorite"
"""
input ec_priorite_arr_rel_insert_input {
  data: [ec_priorite_insert_input!]!

  """
  upsert condition
  """
  on_conflict: ec_priorite_on_conflict
}

"""
aggregate avg on columns
"""
type ec_priorite_avg_fields {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: Float

  """
  L'identifiant d'un enseignement.
  """
  ens_id: Float
  id: Float
}

"""
order by avg() on columns of table "ec.priorite"
"""
input ec_priorite_avg_order_by {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: order_by

  """
  L'identifiant d'un enseignement.
  """
  ens_id: order_by
  id: order_by
}

"""
Boolean expression to filter rows from the table "ec.priorite". All fields are combined with a logical 'AND'.
"""
input ec_priorite_bool_exp {
  _and: [ec_priorite_bool_exp!]
  _not: ec_priorite_bool_exp
  _or: [ec_priorite_bool_exp!]
  anciennete: Int_comparison_exp
  ens_id: Int_comparison_exp
  enseignement: ec_enseignement_bool_exp
  id: Int_comparison_exp
  intervenant: ec_intervenant_bool_exp
  prioritaire: Boolean_comparison_exp
  uid: String_comparison_exp
}

"""
unique or primary key constraints on table "ec.priorite"
"""
enum ec_priorite_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  priorite_pkey

  """
  unique or primary key constraint on columns "uid", "ens_id"
  """
  priorite_uid_ens_id_key
}

"""
input type for incrementing numeric columns in table "ec.priorite"
"""
input ec_priorite_inc_input {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: Int

  """
  L'identifiant d'un enseignement.
  """
  ens_id: Int
  id: Int
}

"""
input type for inserting data into table "ec.priorite"
"""
input ec_priorite_insert_input {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: Int

  """
  L'identifiant d'un enseignement.
  """
  ens_id: Int
  enseignement: ec_enseignement_obj_rel_insert_input
  id: Int
  intervenant: ec_intervenant_obj_rel_insert_input

  """
  Indique si l'intervenant est prioritaire sur l'enseignement.
  """
  prioritaire: Boolean

  """
  L'identifiant d'un intervenant.
  """
  uid: String
}

"""
aggregate max on columns
"""
type ec_priorite_max_fields {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: Int

  """
  L'identifiant d'un enseignement.
  """
  ens_id: Int
  id: Int

  """
  L'identifiant d'un intervenant.
  """
  uid: String
}

"""
order by max() on columns of table "ec.priorite"
"""
input ec_priorite_max_order_by {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: order_by

  """
  L'identifiant d'un enseignement.
  """
  ens_id: order_by
  id: order_by

  """
  L'identifiant d'un intervenant.
  """
  uid: order_by
}

"""
aggregate min on columns
"""
type ec_priorite_min_fields {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: Int

  """
  L'identifiant d'un enseignement.
  """
  ens_id: Int
  id: Int

  """
  L'identifiant d'un intervenant.
  """
  uid: String
}

"""
order by min() on columns of table "ec.priorite"
"""
input ec_priorite_min_order_by {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: order_by

  """
  L'identifiant d'un enseignement.
  """
  ens_id: order_by
  id: order_by

  """
  L'identifiant d'un intervenant.
  """
  uid: order_by
}

"""
response of any mutation on the table "ec.priorite"
"""
type ec_priorite_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [ec_priorite!]!
}

"""
on_conflict condition type for table "ec.priorite"
"""
input ec_priorite_on_conflict {
  constraint: ec_priorite_constraint!
  update_columns: [ec_priorite_update_column!]! = []
  where: ec_priorite_bool_exp
}

"""
Ordering options when selecting data from "ec.priorite".
"""
input ec_priorite_order_by {
  anciennete: order_by
  ens_id: order_by
  enseignement: ec_enseignement_order_by
  id: order_by
  intervenant: ec_intervenant_order_by
  prioritaire: order_by
  uid: order_by
}

"""
primary key columns input for table: ec.priorite
"""
input ec_priorite_pk_columns_input {
  id: Int!
}

"""
select columns of table "ec.priorite"
"""
enum ec_priorite_select_column {
  """
  column name
  """
  anciennete

  """
  column name
  """
  ens_id

  """
  column name
  """
  id

  """
  column name
  """
  prioritaire

  """
  column name
  """
  uid
}

"""
select "ec_priorite_aggregate_bool_exp_bool_and_arguments_columns" columns of table "ec.priorite"
"""
enum ec_priorite_select_column_ec_priorite_aggregate_bool_exp_bool_and_arguments_columns {
  """
  column name
  """
  prioritaire
}

"""
select "ec_priorite_aggregate_bool_exp_bool_or_arguments_columns" columns of table "ec.priorite"
"""
enum ec_priorite_select_column_ec_priorite_aggregate_bool_exp_bool_or_arguments_columns {
  """
  column name
  """
  prioritaire
}

"""
input type for updating data in table "ec.priorite"
"""
input ec_priorite_set_input {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: Int

  """
  L'identifiant d'un enseignement.
  """
  ens_id: Int
  id: Int

  """
  Indique si l'intervenant est prioritaire sur l'enseignement.
  """
  prioritaire: Boolean

  """
  L'identifiant d'un intervenant.
  """
  uid: String
}

"""
aggregate stddev on columns
"""
type ec_priorite_stddev_fields {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: Float

  """
  L'identifiant d'un enseignement.
  """
  ens_id: Float
  id: Float
}

"""
order by stddev() on columns of table "ec.priorite"
"""
input ec_priorite_stddev_order_by {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: order_by

  """
  L'identifiant d'un enseignement.
  """
  ens_id: order_by
  id: order_by
}

"""
aggregate stddev_pop on columns
"""
type ec_priorite_stddev_pop_fields {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: Float

  """
  L'identifiant d'un enseignement.
  """
  ens_id: Float
  id: Float
}

"""
order by stddev_pop() on columns of table "ec.priorite"
"""
input ec_priorite_stddev_pop_order_by {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: order_by

  """
  L'identifiant d'un enseignement.
  """
  ens_id: order_by
  id: order_by
}

"""
aggregate stddev_samp on columns
"""
type ec_priorite_stddev_samp_fields {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: Float

  """
  L'identifiant d'un enseignement.
  """
  ens_id: Float
  id: Float
}

"""
order by stddev_samp() on columns of table "ec.priorite"
"""
input ec_priorite_stddev_samp_order_by {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: order_by

  """
  L'identifiant d'un enseignement.
  """
  ens_id: order_by
  id: order_by
}

"""
Streaming cursor of the table "ec_priorite"
"""
input ec_priorite_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: ec_priorite_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input ec_priorite_stream_cursor_value_input {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: Int

  """
  L'identifiant d'un enseignement.
  """
  ens_id: Int
  id: Int

  """
  Indique si l'intervenant est prioritaire sur l'enseignement.
  """
  prioritaire: Boolean

  """
  L'identifiant d'un intervenant.
  """
  uid: String
}

"""
aggregate sum on columns
"""
type ec_priorite_sum_fields {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: Int

  """
  L'identifiant d'un enseignement.
  """
  ens_id: Int
  id: Int
}

"""
order by sum() on columns of table "ec.priorite"
"""
input ec_priorite_sum_order_by {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: order_by

  """
  L'identifiant d'un enseignement.
  """
  ens_id: order_by
  id: order_by
}

"""
update columns of table "ec.priorite"
"""
enum ec_priorite_update_column {
  """
  column name
  """
  anciennete

  """
  column name
  """
  ens_id

  """
  column name
  """
  id

  """
  column name
  """
  prioritaire

  """
  column name
  """
  uid
}

input ec_priorite_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: ec_priorite_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: ec_priorite_set_input

  """
  filter the rows which have to be updated
  """
  where: ec_priorite_bool_exp!
}

"""
aggregate var_pop on columns
"""
type ec_priorite_var_pop_fields {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: Float

  """
  L'identifiant d'un enseignement.
  """
  ens_id: Float
  id: Float
}

"""
order by var_pop() on columns of table "ec.priorite"
"""
input ec_priorite_var_pop_order_by {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: order_by

  """
  L'identifiant d'un enseignement.
  """
  ens_id: order_by
  id: order_by
}

"""
aggregate var_samp on columns
"""
type ec_priorite_var_samp_fields {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: Float

  """
  L'identifiant d'un enseignement.
  """
  ens_id: Float
  id: Float
}

"""
order by var_samp() on columns of table "ec.priorite"
"""
input ec_priorite_var_samp_order_by {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: order_by

  """
  L'identifiant d'un enseignement.
  """
  ens_id: order_by
  id: order_by
}

"""
aggregate variance on columns
"""
type ec_priorite_variance_fields {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: Float

  """
  L'identifiant d'un enseignement.
  """
  ens_id: Float
  id: Float
}

"""
order by variance() on columns of table "ec.priorite"
"""
input ec_priorite_variance_order_by {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: order_by

  """
  L'identifiant d'un enseignement.
  """
  ens_id: order_by
  id: order_by
}

"""
Table contenant les responsables d'une mention, d'un parcours ou d'un enseignement. Chaque ligne correspond à un et un seul de ces trois types de responsabilité.
"""
type ec_responsable {
  """
  Informations supplémentaires (optionnel, par exemple pour préciser l'année dans le cas d'une responsabilité de parcours ou de mention).
  """
  commentaire: String

  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: Int

  """
  An object relationship
  """
  enseignement: ec_enseignement
  id: Int!

  """
  An object relationship
  """
  intervenant: ec_intervenant!

  """
  An object relationship
  """
  mention: ec_mention

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: Int

  """
  An object relationship
  """
  parcours: ec_parcours

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: Int

  """
  L'identifiant de l'intervenant responsable.
  """
  uid: String!
}

"""
aggregated selection of "ec.responsable"
"""
type ec_responsable_aggregate {
  aggregate: ec_responsable_aggregate_fields
  nodes: [ec_responsable!]!
}

input ec_responsable_aggregate_bool_exp {
  count: ec_responsable_aggregate_bool_exp_count
}

input ec_responsable_aggregate_bool_exp_count {
  arguments: [ec_responsable_select_column!]
  distinct: Boolean
  filter: ec_responsable_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "ec.responsable"
"""
type ec_responsable_aggregate_fields {
  avg: ec_responsable_avg_fields
  count(columns: [ec_responsable_select_column!], distinct: Boolean): Int!
  max: ec_responsable_max_fields
  min: ec_responsable_min_fields
  stddev: ec_responsable_stddev_fields
  stddev_pop: ec_responsable_stddev_pop_fields
  stddev_samp: ec_responsable_stddev_samp_fields
  sum: ec_responsable_sum_fields
  var_pop: ec_responsable_var_pop_fields
  var_samp: ec_responsable_var_samp_fields
  variance: ec_responsable_variance_fields
}

"""
order by aggregate values of table "ec.responsable"
"""
input ec_responsable_aggregate_order_by {
  avg: ec_responsable_avg_order_by
  count: order_by
  max: ec_responsable_max_order_by
  min: ec_responsable_min_order_by
  stddev: ec_responsable_stddev_order_by
  stddev_pop: ec_responsable_stddev_pop_order_by
  stddev_samp: ec_responsable_stddev_samp_order_by
  sum: ec_responsable_sum_order_by
  var_pop: ec_responsable_var_pop_order_by
  var_samp: ec_responsable_var_samp_order_by
  variance: ec_responsable_variance_order_by
}

"""
input type for inserting array relation for remote table "ec.responsable"
"""
input ec_responsable_arr_rel_insert_input {
  data: [ec_responsable_insert_input!]!

  """
  upsert condition
  """
  on_conflict: ec_responsable_on_conflict
}

"""
aggregate avg on columns
"""
type ec_responsable_avg_fields {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: Float
  id: Float

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: Float

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: Float
}

"""
order by avg() on columns of table "ec.responsable"
"""
input ec_responsable_avg_order_by {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: order_by
  id: order_by

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: order_by

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: order_by
}

"""
Boolean expression to filter rows from the table "ec.responsable". All fields are combined with a logical 'AND'.
"""
input ec_responsable_bool_exp {
  _and: [ec_responsable_bool_exp!]
  _not: ec_responsable_bool_exp
  _or: [ec_responsable_bool_exp!]
  commentaire: String_comparison_exp
  ens_id: Int_comparison_exp
  enseignement: ec_enseignement_bool_exp
  id: Int_comparison_exp
  intervenant: ec_intervenant_bool_exp
  mention: ec_mention_bool_exp
  mention_id: Int_comparison_exp
  parcours: ec_parcours_bool_exp
  parcours_id: Int_comparison_exp
  uid: String_comparison_exp
}

"""
unique or primary key constraints on table "ec.responsable"
"""
enum ec_responsable_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  responsable_pkey

  """
  unique or primary key constraint on columns "uid", "parcours_id", "mention_id", "ens_id"
  """
  responsable_uid_ens_id_parcours_id_mention_id_key
}

"""
input type for incrementing numeric columns in table "ec.responsable"
"""
input ec_responsable_inc_input {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: Int
  id: Int

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: Int

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: Int
}

"""
input type for inserting data into table "ec.responsable"
"""
input ec_responsable_insert_input {
  """
  Informations supplémentaires (optionnel, par exemple pour préciser l'année dans le cas d'une responsabilité de parcours ou de mention).
  """
  commentaire: String

  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: Int
  enseignement: ec_enseignement_obj_rel_insert_input
  id: Int
  intervenant: ec_intervenant_obj_rel_insert_input
  mention: ec_mention_obj_rel_insert_input

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: Int
  parcours: ec_parcours_obj_rel_insert_input

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: Int

  """
  L'identifiant de l'intervenant responsable.
  """
  uid: String
}

"""
aggregate max on columns
"""
type ec_responsable_max_fields {
  """
  Informations supplémentaires (optionnel, par exemple pour préciser l'année dans le cas d'une responsabilité de parcours ou de mention).
  """
  commentaire: String

  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: Int
  id: Int

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: Int

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: Int

  """
  L'identifiant de l'intervenant responsable.
  """
  uid: String
}

"""
order by max() on columns of table "ec.responsable"
"""
input ec_responsable_max_order_by {
  """
  Informations supplémentaires (optionnel, par exemple pour préciser l'année dans le cas d'une responsabilité de parcours ou de mention).
  """
  commentaire: order_by

  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: order_by
  id: order_by

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: order_by

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: order_by

  """
  L'identifiant de l'intervenant responsable.
  """
  uid: order_by
}

"""
aggregate min on columns
"""
type ec_responsable_min_fields {
  """
  Informations supplémentaires (optionnel, par exemple pour préciser l'année dans le cas d'une responsabilité de parcours ou de mention).
  """
  commentaire: String

  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: Int
  id: Int

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: Int

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: Int

  """
  L'identifiant de l'intervenant responsable.
  """
  uid: String
}

"""
order by min() on columns of table "ec.responsable"
"""
input ec_responsable_min_order_by {
  """
  Informations supplémentaires (optionnel, par exemple pour préciser l'année dans le cas d'une responsabilité de parcours ou de mention).
  """
  commentaire: order_by

  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: order_by
  id: order_by

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: order_by

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: order_by

  """
  L'identifiant de l'intervenant responsable.
  """
  uid: order_by
}

"""
response of any mutation on the table "ec.responsable"
"""
type ec_responsable_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [ec_responsable!]!
}

"""
on_conflict condition type for table "ec.responsable"
"""
input ec_responsable_on_conflict {
  constraint: ec_responsable_constraint!
  update_columns: [ec_responsable_update_column!]! = []
  where: ec_responsable_bool_exp
}

"""
Ordering options when selecting data from "ec.responsable".
"""
input ec_responsable_order_by {
  commentaire: order_by
  ens_id: order_by
  enseignement: ec_enseignement_order_by
  id: order_by
  intervenant: ec_intervenant_order_by
  mention: ec_mention_order_by
  mention_id: order_by
  parcours: ec_parcours_order_by
  parcours_id: order_by
  uid: order_by
}

"""
primary key columns input for table: ec.responsable
"""
input ec_responsable_pk_columns_input {
  id: Int!
}

"""
select columns of table "ec.responsable"
"""
enum ec_responsable_select_column {
  """
  column name
  """
  commentaire

  """
  column name
  """
  ens_id

  """
  column name
  """
  id

  """
  column name
  """
  mention_id

  """
  column name
  """
  parcours_id

  """
  column name
  """
  uid
}

"""
input type for updating data in table "ec.responsable"
"""
input ec_responsable_set_input {
  """
  Informations supplémentaires (optionnel, par exemple pour préciser l'année dans le cas d'une responsabilité de parcours ou de mention).
  """
  commentaire: String

  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: Int
  id: Int

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: Int

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: Int

  """
  L'identifiant de l'intervenant responsable.
  """
  uid: String
}

"""
aggregate stddev on columns
"""
type ec_responsable_stddev_fields {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: Float
  id: Float

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: Float

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: Float
}

"""
order by stddev() on columns of table "ec.responsable"
"""
input ec_responsable_stddev_order_by {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: order_by
  id: order_by

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: order_by

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: order_by
}

"""
aggregate stddev_pop on columns
"""
type ec_responsable_stddev_pop_fields {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: Float
  id: Float

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: Float

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: Float
}

"""
order by stddev_pop() on columns of table "ec.responsable"
"""
input ec_responsable_stddev_pop_order_by {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: order_by
  id: order_by

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: order_by

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: order_by
}

"""
aggregate stddev_samp on columns
"""
type ec_responsable_stddev_samp_fields {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: Float
  id: Float

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: Float

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: Float
}

"""
order by stddev_samp() on columns of table "ec.responsable"
"""
input ec_responsable_stddev_samp_order_by {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: order_by
  id: order_by

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: order_by

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: order_by
}

"""
Streaming cursor of the table "ec_responsable"
"""
input ec_responsable_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: ec_responsable_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input ec_responsable_stream_cursor_value_input {
  """
  Informations supplémentaires (optionnel, par exemple pour préciser l'année dans le cas d'une responsabilité de parcours ou de mention).
  """
  commentaire: String

  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: Int
  id: Int

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: Int

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: Int

  """
  L'identifiant de l'intervenant responsable.
  """
  uid: String
}

"""
aggregate sum on columns
"""
type ec_responsable_sum_fields {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: Int
  id: Int

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: Int

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: Int
}

"""
order by sum() on columns of table "ec.responsable"
"""
input ec_responsable_sum_order_by {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: order_by
  id: order_by

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: order_by

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: order_by
}

"""
update columns of table "ec.responsable"
"""
enum ec_responsable_update_column {
  """
  column name
  """
  commentaire

  """
  column name
  """
  ens_id

  """
  column name
  """
  id

  """
  column name
  """
  mention_id

  """
  column name
  """
  parcours_id

  """
  column name
  """
  uid
}

input ec_responsable_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: ec_responsable_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: ec_responsable_set_input

  """
  filter the rows which have to be updated
  """
  where: ec_responsable_bool_exp!
}

"""
aggregate var_pop on columns
"""
type ec_responsable_var_pop_fields {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: Float
  id: Float

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: Float

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: Float
}

"""
order by var_pop() on columns of table "ec.responsable"
"""
input ec_responsable_var_pop_order_by {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: order_by
  id: order_by

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: order_by

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: order_by
}

"""
aggregate var_samp on columns
"""
type ec_responsable_var_samp_fields {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: Float
  id: Float

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: Float

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: Float
}

"""
order by var_samp() on columns of table "ec.responsable"
"""
input ec_responsable_var_samp_order_by {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: order_by
  id: order_by

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: order_by

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: order_by
}

"""
aggregate variance on columns
"""
type ec_responsable_variance_fields {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: Float
  id: Float

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: Float

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: Float
}

"""
order by variance() on columns of table "ec.responsable"
"""
input ec_responsable_variance_order_by {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: order_by
  id: order_by

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: order_by

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: order_by
}

"""
Table contenant les services de base, c'est-à-dire le nombre d'heures EQTD qu'un intervenant donné doit réaliser lors d'une année donnée avant modifications éventuelles.
"""
type ec_service {
  """
  L'année correspondant au service.
  """
  annee: Int!

  """
  An object relationship
  """
  anneeByAnnee: ec_annee!

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: Float!

  """
  L'identifiant unique du service.
  """
  id: Int!

  """
  An object relationship
  """
  intervenant: ec_intervenant!

  """
  L'identifiant de l'intervenant correspond au service.
  """
  uid: String!
}

"""
aggregated selection of "ec.service"
"""
type ec_service_aggregate {
  aggregate: ec_service_aggregate_fields
  nodes: [ec_service!]!
}

input ec_service_aggregate_bool_exp {
  count: ec_service_aggregate_bool_exp_count
}

input ec_service_aggregate_bool_exp_count {
  arguments: [ec_service_select_column!]
  distinct: Boolean
  filter: ec_service_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "ec.service"
"""
type ec_service_aggregate_fields {
  avg: ec_service_avg_fields
  count(columns: [ec_service_select_column!], distinct: Boolean): Int!
  max: ec_service_max_fields
  min: ec_service_min_fields
  stddev: ec_service_stddev_fields
  stddev_pop: ec_service_stddev_pop_fields
  stddev_samp: ec_service_stddev_samp_fields
  sum: ec_service_sum_fields
  var_pop: ec_service_var_pop_fields
  var_samp: ec_service_var_samp_fields
  variance: ec_service_variance_fields
}

"""
order by aggregate values of table "ec.service"
"""
input ec_service_aggregate_order_by {
  avg: ec_service_avg_order_by
  count: order_by
  max: ec_service_max_order_by
  min: ec_service_min_order_by
  stddev: ec_service_stddev_order_by
  stddev_pop: ec_service_stddev_pop_order_by
  stddev_samp: ec_service_stddev_samp_order_by
  sum: ec_service_sum_order_by
  var_pop: ec_service_var_pop_order_by
  var_samp: ec_service_var_samp_order_by
  variance: ec_service_variance_order_by
}

"""
input type for inserting array relation for remote table "ec.service"
"""
input ec_service_arr_rel_insert_input {
  data: [ec_service_insert_input!]!

  """
  upsert condition
  """
  on_conflict: ec_service_on_conflict
}

"""
aggregate avg on columns
"""
type ec_service_avg_fields {
  """
  L'année correspondant au service.
  """
  annee: Float

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: Float

  """
  L'identifiant unique du service.
  """
  id: Float
}

"""
order by avg() on columns of table "ec.service"
"""
input ec_service_avg_order_by {
  """
  L'année correspondant au service.
  """
  annee: order_by

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: order_by

  """
  L'identifiant unique du service.
  """
  id: order_by
}

"""
Boolean expression to filter rows from the table "ec.service". All fields are combined with a logical 'AND'.
"""
input ec_service_bool_exp {
  _and: [ec_service_bool_exp!]
  _not: ec_service_bool_exp
  _or: [ec_service_bool_exp!]
  annee: Int_comparison_exp
  anneeByAnnee: ec_annee_bool_exp
  heures_eqtd: Float_comparison_exp
  id: Int_comparison_exp
  intervenant: ec_intervenant_bool_exp
  uid: String_comparison_exp
}

"""
unique or primary key constraints on table "ec.service"
"""
enum ec_service_constraint {
  """
  unique or primary key constraint on columns "annee", "uid"
  """
  service_annee_uid_key

  """
  unique or primary key constraint on columns "id"
  """
  service_pkey
}

"""
input type for incrementing numeric columns in table "ec.service"
"""
input ec_service_inc_input {
  """
  L'année correspondant au service.
  """
  annee: Int

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: Float

  """
  L'identifiant unique du service.
  """
  id: Int
}

"""
input type for inserting data into table "ec.service"
"""
input ec_service_insert_input {
  """
  L'année correspondant au service.
  """
  annee: Int
  anneeByAnnee: ec_annee_obj_rel_insert_input

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: Float

  """
  L'identifiant unique du service.
  """
  id: Int
  intervenant: ec_intervenant_obj_rel_insert_input

  """
  L'identifiant de l'intervenant correspond au service.
  """
  uid: String
}

"""
aggregate max on columns
"""
type ec_service_max_fields {
  """
  L'année correspondant au service.
  """
  annee: Int

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: Float

  """
  L'identifiant unique du service.
  """
  id: Int

  """
  L'identifiant de l'intervenant correspond au service.
  """
  uid: String
}

"""
order by max() on columns of table "ec.service"
"""
input ec_service_max_order_by {
  """
  L'année correspondant au service.
  """
  annee: order_by

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: order_by

  """
  L'identifiant unique du service.
  """
  id: order_by

  """
  L'identifiant de l'intervenant correspond au service.
  """
  uid: order_by
}

"""
aggregate min on columns
"""
type ec_service_min_fields {
  """
  L'année correspondant au service.
  """
  annee: Int

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: Float

  """
  L'identifiant unique du service.
  """
  id: Int

  """
  L'identifiant de l'intervenant correspond au service.
  """
  uid: String
}

"""
order by min() on columns of table "ec.service"
"""
input ec_service_min_order_by {
  """
  L'année correspondant au service.
  """
  annee: order_by

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: order_by

  """
  L'identifiant unique du service.
  """
  id: order_by

  """
  L'identifiant de l'intervenant correspond au service.
  """
  uid: order_by
}

"""
response of any mutation on the table "ec.service"
"""
type ec_service_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [ec_service!]!
}

"""
on_conflict condition type for table "ec.service"
"""
input ec_service_on_conflict {
  constraint: ec_service_constraint!
  update_columns: [ec_service_update_column!]! = []
  where: ec_service_bool_exp
}

"""
Ordering options when selecting data from "ec.service".
"""
input ec_service_order_by {
  annee: order_by
  anneeByAnnee: ec_annee_order_by
  heures_eqtd: order_by
  id: order_by
  intervenant: ec_intervenant_order_by
  uid: order_by
}

"""
primary key columns input for table: ec.service
"""
input ec_service_pk_columns_input {
  """
  L'identifiant unique du service.
  """
  id: Int!
}

"""
select columns of table "ec.service"
"""
enum ec_service_select_column {
  """
  column name
  """
  annee

  """
  column name
  """
  heures_eqtd

  """
  column name
  """
  id

  """
  column name
  """
  uid
}

"""
input type for updating data in table "ec.service"
"""
input ec_service_set_input {
  """
  L'année correspondant au service.
  """
  annee: Int

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: Float

  """
  L'identifiant unique du service.
  """
  id: Int

  """
  L'identifiant de l'intervenant correspond au service.
  """
  uid: String
}

"""
aggregate stddev on columns
"""
type ec_service_stddev_fields {
  """
  L'année correspondant au service.
  """
  annee: Float

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: Float

  """
  L'identifiant unique du service.
  """
  id: Float
}

"""
order by stddev() on columns of table "ec.service"
"""
input ec_service_stddev_order_by {
  """
  L'année correspondant au service.
  """
  annee: order_by

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: order_by

  """
  L'identifiant unique du service.
  """
  id: order_by
}

"""
aggregate stddev_pop on columns
"""
type ec_service_stddev_pop_fields {
  """
  L'année correspondant au service.
  """
  annee: Float

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: Float

  """
  L'identifiant unique du service.
  """
  id: Float
}

"""
order by stddev_pop() on columns of table "ec.service"
"""
input ec_service_stddev_pop_order_by {
  """
  L'année correspondant au service.
  """
  annee: order_by

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: order_by

  """
  L'identifiant unique du service.
  """
  id: order_by
}

"""
aggregate stddev_samp on columns
"""
type ec_service_stddev_samp_fields {
  """
  L'année correspondant au service.
  """
  annee: Float

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: Float

  """
  L'identifiant unique du service.
  """
  id: Float
}

"""
order by stddev_samp() on columns of table "ec.service"
"""
input ec_service_stddev_samp_order_by {
  """
  L'année correspondant au service.
  """
  annee: order_by

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: order_by

  """
  L'identifiant unique du service.
  """
  id: order_by
}

"""
Streaming cursor of the table "ec_service"
"""
input ec_service_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: ec_service_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input ec_service_stream_cursor_value_input {
  """
  L'année correspondant au service.
  """
  annee: Int

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: Float

  """
  L'identifiant unique du service.
  """
  id: Int

  """
  L'identifiant de l'intervenant correspond au service.
  """
  uid: String
}

"""
aggregate sum on columns
"""
type ec_service_sum_fields {
  """
  L'année correspondant au service.
  """
  annee: Int

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: Float

  """
  L'identifiant unique du service.
  """
  id: Int
}

"""
order by sum() on columns of table "ec.service"
"""
input ec_service_sum_order_by {
  """
  L'année correspondant au service.
  """
  annee: order_by

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: order_by

  """
  L'identifiant unique du service.
  """
  id: order_by
}

"""
update columns of table "ec.service"
"""
enum ec_service_update_column {
  """
  column name
  """
  annee

  """
  column name
  """
  heures_eqtd

  """
  column name
  """
  id

  """
  column name
  """
  uid
}

input ec_service_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: ec_service_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: ec_service_set_input

  """
  filter the rows which have to be updated
  """
  where: ec_service_bool_exp!
}

"""
aggregate var_pop on columns
"""
type ec_service_var_pop_fields {
  """
  L'année correspondant au service.
  """
  annee: Float

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: Float

  """
  L'identifiant unique du service.
  """
  id: Float
}

"""
order by var_pop() on columns of table "ec.service"
"""
input ec_service_var_pop_order_by {
  """
  L'année correspondant au service.
  """
  annee: order_by

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: order_by

  """
  L'identifiant unique du service.
  """
  id: order_by
}

"""
aggregate var_samp on columns
"""
type ec_service_var_samp_fields {
  """
  L'année correspondant au service.
  """
  annee: Float

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: Float

  """
  L'identifiant unique du service.
  """
  id: Float
}

"""
order by var_samp() on columns of table "ec.service"
"""
input ec_service_var_samp_order_by {
  """
  L'année correspondant au service.
  """
  annee: order_by

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: order_by

  """
  L'identifiant unique du service.
  """
  id: order_by
}

"""
aggregate variance on columns
"""
type ec_service_variance_fields {
  """
  L'année correspondant au service.
  """
  annee: Float

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: Float

  """
  L'identifiant unique du service.
  """
  id: Float
}

"""
order by variance() on columns of table "ec.service"
"""
input ec_service_variance_order_by {
  """
  L'année correspondant au service.
  """
  annee: order_by

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: order_by

  """
  L'identifiant unique du service.
  """
  id: order_by
}

"""
Table contenant les différents types de demande (principale, secondaire, attribution).
"""
type ec_type_demande {
  """
  An array relationship
  """
  demandes(
    """
    distinct select on columns
    """
    distinct_on: [ec_demande_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_demande_order_by!]

    """
    filter the rows returned
    """
    where: ec_demande_bool_exp
  ): [ec_demande!]!

  """
  An aggregate relationship
  """
  demandes_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_demande_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_demande_order_by!]

    """
    filter the rows returned
    """
    where: ec_demande_bool_exp
  ): ec_demande_aggregate!
  description: String

  """
  Le type de demande (unique).
  """
  value: String!
}

"""
aggregated selection of "ec.type_demande"
"""
type ec_type_demande_aggregate {
  aggregate: ec_type_demande_aggregate_fields
  nodes: [ec_type_demande!]!
}

"""
aggregate fields of "ec.type_demande"
"""
type ec_type_demande_aggregate_fields {
  count(columns: [ec_type_demande_select_column!], distinct: Boolean): Int!
  max: ec_type_demande_max_fields
  min: ec_type_demande_min_fields
}

"""
Boolean expression to filter rows from the table "ec.type_demande". All fields are combined with a logical 'AND'.
"""
input ec_type_demande_bool_exp {
  _and: [ec_type_demande_bool_exp!]
  _not: ec_type_demande_bool_exp
  _or: [ec_type_demande_bool_exp!]
  demandes: ec_demande_bool_exp
  demandes_aggregate: ec_demande_aggregate_bool_exp
  description: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "ec.type_demande"
"""
enum ec_type_demande_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  type_demande_pkey
}

"""
input type for inserting data into table "ec.type_demande"
"""
input ec_type_demande_insert_input {
  demandes: ec_demande_arr_rel_insert_input
  description: String

  """
  Le type de demande (unique).
  """
  value: String
}

"""
aggregate max on columns
"""
type ec_type_demande_max_fields {
  description: String

  """
  Le type de demande (unique).
  """
  value: String
}

"""
aggregate min on columns
"""
type ec_type_demande_min_fields {
  description: String

  """
  Le type de demande (unique).
  """
  value: String
}

"""
response of any mutation on the table "ec.type_demande"
"""
type ec_type_demande_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [ec_type_demande!]!
}

"""
input type for inserting object relation for remote table "ec.type_demande"
"""
input ec_type_demande_obj_rel_insert_input {
  data: ec_type_demande_insert_input!

  """
  upsert condition
  """
  on_conflict: ec_type_demande_on_conflict
}

"""
on_conflict condition type for table "ec.type_demande"
"""
input ec_type_demande_on_conflict {
  constraint: ec_type_demande_constraint!
  update_columns: [ec_type_demande_update_column!]! = []
  where: ec_type_demande_bool_exp
}

"""
Ordering options when selecting data from "ec.type_demande".
"""
input ec_type_demande_order_by {
  demandes_aggregate: ec_demande_aggregate_order_by
  description: order_by
  value: order_by
}

"""
primary key columns input for table: ec.type_demande
"""
input ec_type_demande_pk_columns_input {
  """
  Le type de demande (unique).
  """
  value: String!
}

"""
select columns of table "ec.type_demande"
"""
enum ec_type_demande_select_column {
  """
  column name
  """
  description

  """
  column name
  """
  value
}

"""
input type for updating data in table "ec.type_demande"
"""
input ec_type_demande_set_input {
  description: String

  """
  Le type de demande (unique).
  """
  value: String
}

"""
Streaming cursor of the table "ec_type_demande"
"""
input ec_type_demande_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: ec_type_demande_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input ec_type_demande_stream_cursor_value_input {
  description: String

  """
  Le type de demande (unique).
  """
  value: String
}

"""
update columns of table "ec.type_demande"
"""
enum ec_type_demande_update_column {
  """
  column name
  """
  description

  """
  column name
  """
  value
}

input ec_type_demande_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: ec_type_demande_set_input

  """
  filter the rows which have to be updated
  """
  where: ec_type_demande_bool_exp!
}

"""
Table contenant les différents types d'enseignement (CM, TD, etc.).
"""
type ec_type_enseignement {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float!

  """
  An array relationship
  """
  enseignements(
    """
    distinct select on columns
    """
    distinct_on: [ec_enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_enseignement_order_by!]

    """
    filter the rows returned
    """
    where: ec_enseignement_bool_exp
  ): [ec_enseignement!]!

  """
  An aggregate relationship
  """
  enseignements_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_enseignement_order_by!]

    """
    filter the rows returned
    """
    where: ec_enseignement_bool_exp
  ): ec_enseignement_aggregate!

  """
  Le type d'enseignement (unique).
  """
  label: String!

  """
  Le nom abrégé (optionnel).
  """
  label_court: String
}

"""
aggregated selection of "ec.type_enseignement"
"""
type ec_type_enseignement_aggregate {
  aggregate: ec_type_enseignement_aggregate_fields
  nodes: [ec_type_enseignement!]!
}

"""
aggregate fields of "ec.type_enseignement"
"""
type ec_type_enseignement_aggregate_fields {
  avg: ec_type_enseignement_avg_fields
  count(columns: [ec_type_enseignement_select_column!], distinct: Boolean): Int!
  max: ec_type_enseignement_max_fields
  min: ec_type_enseignement_min_fields
  stddev: ec_type_enseignement_stddev_fields
  stddev_pop: ec_type_enseignement_stddev_pop_fields
  stddev_samp: ec_type_enseignement_stddev_samp_fields
  sum: ec_type_enseignement_sum_fields
  var_pop: ec_type_enseignement_var_pop_fields
  var_samp: ec_type_enseignement_var_samp_fields
  variance: ec_type_enseignement_variance_fields
}

"""
aggregate avg on columns
"""
type ec_type_enseignement_avg_fields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""
Boolean expression to filter rows from the table "ec.type_enseignement". All fields are combined with a logical 'AND'.
"""
input ec_type_enseignement_bool_exp {
  _and: [ec_type_enseignement_bool_exp!]
  _not: ec_type_enseignement_bool_exp
  _or: [ec_type_enseignement_bool_exp!]
  coefficient: Float_comparison_exp
  enseignements: ec_enseignement_bool_exp
  enseignements_aggregate: ec_enseignement_aggregate_bool_exp
  label: String_comparison_exp
  label_court: String_comparison_exp
}

"""
unique or primary key constraints on table "ec.type_enseignement"
"""
enum ec_type_enseignement_constraint {
  """
  unique or primary key constraint on columns "label"
  """
  type_enseignement_pkey
}

"""
input type for incrementing numeric columns in table "ec.type_enseignement"
"""
input ec_type_enseignement_inc_input {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""
input type for inserting data into table "ec.type_enseignement"
"""
input ec_type_enseignement_insert_input {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
  enseignements: ec_enseignement_arr_rel_insert_input

  """
  Le type d'enseignement (unique).
  """
  label: String

  """
  Le nom abrégé (optionnel).
  """
  label_court: String
}

"""
aggregate max on columns
"""
type ec_type_enseignement_max_fields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float

  """
  Le type d'enseignement (unique).
  """
  label: String

  """
  Le nom abrégé (optionnel).
  """
  label_court: String
}

"""
aggregate min on columns
"""
type ec_type_enseignement_min_fields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float

  """
  Le type d'enseignement (unique).
  """
  label: String

  """
  Le nom abrégé (optionnel).
  """
  label_court: String
}

"""
response of any mutation on the table "ec.type_enseignement"
"""
type ec_type_enseignement_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [ec_type_enseignement!]!
}

"""
input type for inserting object relation for remote table "ec.type_enseignement"
"""
input ec_type_enseignement_obj_rel_insert_input {
  data: ec_type_enseignement_insert_input!

  """
  upsert condition
  """
  on_conflict: ec_type_enseignement_on_conflict
}

"""
on_conflict condition type for table "ec.type_enseignement"
"""
input ec_type_enseignement_on_conflict {
  constraint: ec_type_enseignement_constraint!
  update_columns: [ec_type_enseignement_update_column!]! = []
  where: ec_type_enseignement_bool_exp
}

"""
Ordering options when selecting data from "ec.type_enseignement".
"""
input ec_type_enseignement_order_by {
  coefficient: order_by
  enseignements_aggregate: ec_enseignement_aggregate_order_by
  label: order_by
  label_court: order_by
}

"""
primary key columns input for table: ec.type_enseignement
"""
input ec_type_enseignement_pk_columns_input {
  """
  Le type d'enseignement (unique).
  """
  label: String!
}

"""
select columns of table "ec.type_enseignement"
"""
enum ec_type_enseignement_select_column {
  """
  column name
  """
  coefficient

  """
  column name
  """
  label

  """
  column name
  """
  label_court
}

"""
input type for updating data in table "ec.type_enseignement"
"""
input ec_type_enseignement_set_input {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float

  """
  Le type d'enseignement (unique).
  """
  label: String

  """
  Le nom abrégé (optionnel).
  """
  label_court: String
}

"""
aggregate stddev on columns
"""
type ec_type_enseignement_stddev_fields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""
aggregate stddev_pop on columns
"""
type ec_type_enseignement_stddev_pop_fields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""
aggregate stddev_samp on columns
"""
type ec_type_enseignement_stddev_samp_fields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""
Streaming cursor of the table "ec_type_enseignement"
"""
input ec_type_enseignement_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: ec_type_enseignement_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input ec_type_enseignement_stream_cursor_value_input {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float

  """
  Le type d'enseignement (unique).
  """
  label: String

  """
  Le nom abrégé (optionnel).
  """
  label_court: String
}

"""
aggregate sum on columns
"""
type ec_type_enseignement_sum_fields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""
update columns of table "ec.type_enseignement"
"""
enum ec_type_enseignement_update_column {
  """
  column name
  """
  coefficient

  """
  column name
  """
  label

  """
  column name
  """
  label_court
}

input ec_type_enseignement_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: ec_type_enseignement_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: ec_type_enseignement_set_input

  """
  filter the rows which have to be updated
  """
  where: ec_type_enseignement_bool_exp!
}

"""
aggregate var_pop on columns
"""
type ec_type_enseignement_var_pop_fields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""
aggregate var_samp on columns
"""
type ec_type_enseignement_var_samp_fields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""
aggregate variance on columns
"""
type ec_type_enseignement_variance_fields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""
Table contenant les différents types de messages enregistrés sur Geyser.
"""
type ec_type_message {
  """
  Une brève description.
  """
  description: String

  """
  An array relationship
  """
  messages(
    """
    distinct select on columns
    """
    distinct_on: [ec_message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_message_order_by!]

    """
    filter the rows returned
    """
    where: ec_message_bool_exp
  ): [ec_message!]!

  """
  An aggregate relationship
  """
  messages_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_message_order_by!]

    """
    filter the rows returned
    """
    where: ec_message_bool_exp
  ): ec_message_aggregate!

  """
  Le type de message (unique).
  """
  value: String!
}

"""
aggregated selection of "ec.type_message"
"""
type ec_type_message_aggregate {
  aggregate: ec_type_message_aggregate_fields
  nodes: [ec_type_message!]!
}

"""
aggregate fields of "ec.type_message"
"""
type ec_type_message_aggregate_fields {
  count(columns: [ec_type_message_select_column!], distinct: Boolean): Int!
  max: ec_type_message_max_fields
  min: ec_type_message_min_fields
}

"""
Boolean expression to filter rows from the table "ec.type_message". All fields are combined with a logical 'AND'.
"""
input ec_type_message_bool_exp {
  _and: [ec_type_message_bool_exp!]
  _not: ec_type_message_bool_exp
  _or: [ec_type_message_bool_exp!]
  description: String_comparison_exp
  messages: ec_message_bool_exp
  messages_aggregate: ec_message_aggregate_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "ec.type_message"
"""
enum ec_type_message_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  type_message_pkey
}

"""
input type for inserting data into table "ec.type_message"
"""
input ec_type_message_insert_input {
  """
  Une brève description.
  """
  description: String
  messages: ec_message_arr_rel_insert_input

  """
  Le type de message (unique).
  """
  value: String
}

"""
aggregate max on columns
"""
type ec_type_message_max_fields {
  """
  Une brève description.
  """
  description: String

  """
  Le type de message (unique).
  """
  value: String
}

"""
aggregate min on columns
"""
type ec_type_message_min_fields {
  """
  Une brève description.
  """
  description: String

  """
  Le type de message (unique).
  """
  value: String
}

"""
response of any mutation on the table "ec.type_message"
"""
type ec_type_message_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [ec_type_message!]!
}

"""
input type for inserting object relation for remote table "ec.type_message"
"""
input ec_type_message_obj_rel_insert_input {
  data: ec_type_message_insert_input!

  """
  upsert condition
  """
  on_conflict: ec_type_message_on_conflict
}

"""
on_conflict condition type for table "ec.type_message"
"""
input ec_type_message_on_conflict {
  constraint: ec_type_message_constraint!
  update_columns: [ec_type_message_update_column!]! = []
  where: ec_type_message_bool_exp
}

"""
Ordering options when selecting data from "ec.type_message".
"""
input ec_type_message_order_by {
  description: order_by
  messages_aggregate: ec_message_aggregate_order_by
  value: order_by
}

"""
primary key columns input for table: ec.type_message
"""
input ec_type_message_pk_columns_input {
  """
  Le type de message (unique).
  """
  value: String!
}

"""
select columns of table "ec.type_message"
"""
enum ec_type_message_select_column {
  """
  column name
  """
  description

  """
  column name
  """
  value
}

"""
input type for updating data in table "ec.type_message"
"""
input ec_type_message_set_input {
  """
  Une brève description.
  """
  description: String

  """
  Le type de message (unique).
  """
  value: String
}

"""
Streaming cursor of the table "ec_type_message"
"""
input ec_type_message_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: ec_type_message_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input ec_type_message_stream_cursor_value_input {
  """
  Une brève description.
  """
  description: String

  """
  Le type de message (unique).
  """
  value: String
}

"""
update columns of table "ec.type_message"
"""
enum ec_type_message_update_column {
  """
  column name
  """
  description

  """
  column name
  """
  value
}

input ec_type_message_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: ec_type_message_set_input

  """
  filter the rows which have to be updated
  """
  where: ec_type_message_bool_exp!
}

"""
Table contenant les différents types de modification de service.
"""
type ec_type_modification {
  """
  Une brève description.
  """
  description: String

  """
  Le type de modification (unique).
  """
  label: String!

  """
  An array relationship
  """
  modifications_service(
    """
    distinct select on columns
    """
    distinct_on: [ec_modification_service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_modification_service_order_by!]

    """
    filter the rows returned
    """
    where: ec_modification_service_bool_exp
  ): [ec_modification_service!]!

  """
  An aggregate relationship
  """
  modifications_service_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_modification_service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_modification_service_order_by!]

    """
    filter the rows returned
    """
    where: ec_modification_service_bool_exp
  ): ec_modification_service_aggregate!
}

"""
aggregated selection of "ec.type_modification"
"""
type ec_type_modification_aggregate {
  aggregate: ec_type_modification_aggregate_fields
  nodes: [ec_type_modification!]!
}

"""
aggregate fields of "ec.type_modification"
"""
type ec_type_modification_aggregate_fields {
  count(columns: [ec_type_modification_select_column!], distinct: Boolean): Int!
  max: ec_type_modification_max_fields
  min: ec_type_modification_min_fields
}

"""
Boolean expression to filter rows from the table "ec.type_modification". All fields are combined with a logical 'AND'.
"""
input ec_type_modification_bool_exp {
  _and: [ec_type_modification_bool_exp!]
  _not: ec_type_modification_bool_exp
  _or: [ec_type_modification_bool_exp!]
  description: String_comparison_exp
  label: String_comparison_exp
  modifications_service: ec_modification_service_bool_exp
  modifications_service_aggregate: ec_modification_service_aggregate_bool_exp
}

"""
unique or primary key constraints on table "ec.type_modification"
"""
enum ec_type_modification_constraint {
  """
  unique or primary key constraint on columns "label"
  """
  type_modification_pkey
}

"""
input type for inserting data into table "ec.type_modification"
"""
input ec_type_modification_insert_input {
  """
  Une brève description.
  """
  description: String

  """
  Le type de modification (unique).
  """
  label: String
  modifications_service: ec_modification_service_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type ec_type_modification_max_fields {
  """
  Une brève description.
  """
  description: String

  """
  Le type de modification (unique).
  """
  label: String
}

"""
aggregate min on columns
"""
type ec_type_modification_min_fields {
  """
  Une brève description.
  """
  description: String

  """
  Le type de modification (unique).
  """
  label: String
}

"""
response of any mutation on the table "ec.type_modification"
"""
type ec_type_modification_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [ec_type_modification!]!
}

"""
input type for inserting object relation for remote table "ec.type_modification"
"""
input ec_type_modification_obj_rel_insert_input {
  data: ec_type_modification_insert_input!

  """
  upsert condition
  """
  on_conflict: ec_type_modification_on_conflict
}

"""
on_conflict condition type for table "ec.type_modification"
"""
input ec_type_modification_on_conflict {
  constraint: ec_type_modification_constraint!
  update_columns: [ec_type_modification_update_column!]! = []
  where: ec_type_modification_bool_exp
}

"""
Ordering options when selecting data from "ec.type_modification".
"""
input ec_type_modification_order_by {
  description: order_by
  label: order_by
  modifications_service_aggregate: ec_modification_service_aggregate_order_by
}

"""
primary key columns input for table: ec.type_modification
"""
input ec_type_modification_pk_columns_input {
  """
  Le type de modification (unique).
  """
  label: String!
}

"""
select columns of table "ec.type_modification"
"""
enum ec_type_modification_select_column {
  """
  column name
  """
  description

  """
  column name
  """
  label
}

"""
input type for updating data in table "ec.type_modification"
"""
input ec_type_modification_set_input {
  """
  Une brève description.
  """
  description: String

  """
  Le type de modification (unique).
  """
  label: String
}

"""
Streaming cursor of the table "ec_type_modification"
"""
input ec_type_modification_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: ec_type_modification_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input ec_type_modification_stream_cursor_value_input {
  """
  Une brève description.
  """
  description: String

  """
  Le type de modification (unique).
  """
  label: String
}

"""
update columns of table "ec.type_modification"
"""
enum ec_type_modification_update_column {
  """
  column name
  """
  description

  """
  column name
  """
  label
}

input ec_type_modification_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: ec_type_modification_set_input

  """
  filter the rows which have to be updated
  """
  where: ec_type_modification_bool_exp!
}

"""
mutation root
"""
type mutation_root {
  """
  delete data from the table: "ec.annee"
  """
  delete_ec_annee(
    """
    filter the rows which have to be deleted
    """
    where: ec_annee_bool_exp!
  ): ec_annee_mutation_response

  """
  delete single row from the table: "ec.annee"
  """
  delete_ec_annee_by_pk(
    """
    Le numéro de l'année (unique).
    """
    value: Int!
  ): ec_annee

  """
  delete data from the table: "ec.cursus"
  """
  delete_ec_cursus(
    """
    filter the rows which have to be deleted
    """
    where: ec_cursus_bool_exp!
  ): ec_cursus_mutation_response

  """
  delete single row from the table: "ec.cursus"
  """
  delete_ec_cursus_by_pk(
    """
    L'identifiant unique du cursus.
    """
    id: Int!
  ): ec_cursus

  """
  delete data from the table: "ec.demande"
  """
  delete_ec_demande(
    """
    filter the rows which have to be deleted
    """
    where: ec_demande_bool_exp!
  ): ec_demande_mutation_response

  """
  delete single row from the table: "ec.demande"
  """
  delete_ec_demande_by_pk(id: Int!): ec_demande

  """
  delete data from the table: "ec.enseignement"
  """
  delete_ec_enseignement(
    """
    filter the rows which have to be deleted
    """
    where: ec_enseignement_bool_exp!
  ): ec_enseignement_mutation_response

  """
  delete single row from the table: "ec.enseignement"
  """
  delete_ec_enseignement_by_pk(
    """
    L'identifiant unique de l'enseignement.
    """
    id: Int!
  ): ec_enseignement

  """
  delete data from the table: "ec.intervenant"
  """
  delete_ec_intervenant(
    """
    filter the rows which have to be deleted
    """
    where: ec_intervenant_bool_exp!
  ): ec_intervenant_mutation_response

  """
  delete single row from the table: "ec.intervenant"
  """
  delete_ec_intervenant_by_pk(
    """
    L'identifiant unique de l'intervenant.
    """
    uid: String!
  ): ec_intervenant

  """
  delete data from the table: "ec.mention"
  """
  delete_ec_mention(
    """
    filter the rows which have to be deleted
    """
    where: ec_mention_bool_exp!
  ): ec_mention_mutation_response

  """
  delete single row from the table: "ec.mention"
  """
  delete_ec_mention_by_pk(
    """
    L'identifiant unique de la mention.
    """
    id: Int!
  ): ec_mention

  """
  delete data from the table: "ec.message"
  """
  delete_ec_message(
    """
    filter the rows which have to be deleted
    """
    where: ec_message_bool_exp!
  ): ec_message_mutation_response

  """
  delete single row from the table: "ec.message"
  """
  delete_ec_message_by_pk(
    """
    L'identifiant unique du message.
    """
    id: Int!
  ): ec_message

  """
  delete data from the table: "ec.modification_service"
  """
  delete_ec_modification_service(
    """
    filter the rows which have to be deleted
    """
    where: ec_modification_service_bool_exp!
  ): ec_modification_service_mutation_response

  """
  delete single row from the table: "ec.modification_service"
  """
  delete_ec_modification_service_by_pk(
    """
    L'identifiant unique de la modification.
    """
    id: Int!
  ): ec_modification_service

  """
  delete data from the table: "ec.parcours"
  """
  delete_ec_parcours(
    """
    filter the rows which have to be deleted
    """
    where: ec_parcours_bool_exp!
  ): ec_parcours_mutation_response

  """
  delete single row from the table: "ec.parcours"
  """
  delete_ec_parcours_by_pk(
    """
    L'identifiant unique du parcours.
    """
    id: Int!
  ): ec_parcours

  """
  delete data from the table: "ec.phase"
  """
  delete_ec_phase(
    """
    filter the rows which have to be deleted
    """
    where: ec_phase_bool_exp!
  ): ec_phase_mutation_response

  """
  delete single row from the table: "ec.phase"
  """
  delete_ec_phase_by_pk(
    """
    Le nom de la phase (unique).
    """
    value: String!
  ): ec_phase

  """
  delete data from the table: "ec.priorite"
  """
  delete_ec_priorite(
    """
    filter the rows which have to be deleted
    """
    where: ec_priorite_bool_exp!
  ): ec_priorite_mutation_response

  """
  delete single row from the table: "ec.priorite"
  """
  delete_ec_priorite_by_pk(id: Int!): ec_priorite

  """
  delete data from the table: "ec.responsable"
  """
  delete_ec_responsable(
    """
    filter the rows which have to be deleted
    """
    where: ec_responsable_bool_exp!
  ): ec_responsable_mutation_response

  """
  delete single row from the table: "ec.responsable"
  """
  delete_ec_responsable_by_pk(id: Int!): ec_responsable

  """
  delete data from the table: "ec.service"
  """
  delete_ec_service(
    """
    filter the rows which have to be deleted
    """
    where: ec_service_bool_exp!
  ): ec_service_mutation_response

  """
  delete single row from the table: "ec.service"
  """
  delete_ec_service_by_pk(
    """
    L'identifiant unique du service.
    """
    id: Int!
  ): ec_service

  """
  delete data from the table: "ec.type_demande"
  """
  delete_ec_type_demande(
    """
    filter the rows which have to be deleted
    """
    where: ec_type_demande_bool_exp!
  ): ec_type_demande_mutation_response

  """
  delete single row from the table: "ec.type_demande"
  """
  delete_ec_type_demande_by_pk(
    """
    Le type de demande (unique).
    """
    value: String!
  ): ec_type_demande

  """
  delete data from the table: "ec.type_enseignement"
  """
  delete_ec_type_enseignement(
    """
    filter the rows which have to be deleted
    """
    where: ec_type_enseignement_bool_exp!
  ): ec_type_enseignement_mutation_response

  """
  delete single row from the table: "ec.type_enseignement"
  """
  delete_ec_type_enseignement_by_pk(
    """
    Le type d'enseignement (unique).
    """
    label: String!
  ): ec_type_enseignement

  """
  delete data from the table: "ec.type_message"
  """
  delete_ec_type_message(
    """
    filter the rows which have to be deleted
    """
    where: ec_type_message_bool_exp!
  ): ec_type_message_mutation_response

  """
  delete single row from the table: "ec.type_message"
  """
  delete_ec_type_message_by_pk(
    """
    Le type de message (unique).
    """
    value: String!
  ): ec_type_message

  """
  delete data from the table: "ec.type_modification"
  """
  delete_ec_type_modification(
    """
    filter the rows which have to be deleted
    """
    where: ec_type_modification_bool_exp!
  ): ec_type_modification_mutation_response

  """
  delete single row from the table: "ec.type_modification"
  """
  delete_ec_type_modification_by_pk(
    """
    Le type de modification (unique).
    """
    label: String!
  ): ec_type_modification

  """
  insert data into the table: "ec.annee"
  """
  insert_ec_annee(
    """
    the rows to be inserted
    """
    objects: [ec_annee_insert_input!]!

    """
    upsert condition
    """
    on_conflict: ec_annee_on_conflict
  ): ec_annee_mutation_response

  """
  insert a single row into the table: "ec.annee"
  """
  insert_ec_annee_one(
    """
    the row to be inserted
    """
    object: ec_annee_insert_input!

    """
    upsert condition
    """
    on_conflict: ec_annee_on_conflict
  ): ec_annee

  """
  insert data into the table: "ec.cursus"
  """
  insert_ec_cursus(
    """
    the rows to be inserted
    """
    objects: [ec_cursus_insert_input!]!

    """
    upsert condition
    """
    on_conflict: ec_cursus_on_conflict
  ): ec_cursus_mutation_response

  """
  insert a single row into the table: "ec.cursus"
  """
  insert_ec_cursus_one(
    """
    the row to be inserted
    """
    object: ec_cursus_insert_input!

    """
    upsert condition
    """
    on_conflict: ec_cursus_on_conflict
  ): ec_cursus

  """
  insert data into the table: "ec.demande"
  """
  insert_ec_demande(
    """
    the rows to be inserted
    """
    objects: [ec_demande_insert_input!]!

    """
    upsert condition
    """
    on_conflict: ec_demande_on_conflict
  ): ec_demande_mutation_response

  """
  insert a single row into the table: "ec.demande"
  """
  insert_ec_demande_one(
    """
    the row to be inserted
    """
    object: ec_demande_insert_input!

    """
    upsert condition
    """
    on_conflict: ec_demande_on_conflict
  ): ec_demande

  """
  insert data into the table: "ec.enseignement"
  """
  insert_ec_enseignement(
    """
    the rows to be inserted
    """
    objects: [ec_enseignement_insert_input!]!

    """
    upsert condition
    """
    on_conflict: ec_enseignement_on_conflict
  ): ec_enseignement_mutation_response

  """
  insert a single row into the table: "ec.enseignement"
  """
  insert_ec_enseignement_one(
    """
    the row to be inserted
    """
    object: ec_enseignement_insert_input!

    """
    upsert condition
    """
    on_conflict: ec_enseignement_on_conflict
  ): ec_enseignement

  """
  insert data into the table: "ec.intervenant"
  """
  insert_ec_intervenant(
    """
    the rows to be inserted
    """
    objects: [ec_intervenant_insert_input!]!

    """
    upsert condition
    """
    on_conflict: ec_intervenant_on_conflict
  ): ec_intervenant_mutation_response

  """
  insert a single row into the table: "ec.intervenant"
  """
  insert_ec_intervenant_one(
    """
    the row to be inserted
    """
    object: ec_intervenant_insert_input!

    """
    upsert condition
    """
    on_conflict: ec_intervenant_on_conflict
  ): ec_intervenant

  """
  insert data into the table: "ec.mention"
  """
  insert_ec_mention(
    """
    the rows to be inserted
    """
    objects: [ec_mention_insert_input!]!

    """
    upsert condition
    """
    on_conflict: ec_mention_on_conflict
  ): ec_mention_mutation_response

  """
  insert a single row into the table: "ec.mention"
  """
  insert_ec_mention_one(
    """
    the row to be inserted
    """
    object: ec_mention_insert_input!

    """
    upsert condition
    """
    on_conflict: ec_mention_on_conflict
  ): ec_mention

  """
  insert data into the table: "ec.message"
  """
  insert_ec_message(
    """
    the rows to be inserted
    """
    objects: [ec_message_insert_input!]!

    """
    upsert condition
    """
    on_conflict: ec_message_on_conflict
  ): ec_message_mutation_response

  """
  insert a single row into the table: "ec.message"
  """
  insert_ec_message_one(
    """
    the row to be inserted
    """
    object: ec_message_insert_input!

    """
    upsert condition
    """
    on_conflict: ec_message_on_conflict
  ): ec_message

  """
  insert data into the table: "ec.modification_service"
  """
  insert_ec_modification_service(
    """
    the rows to be inserted
    """
    objects: [ec_modification_service_insert_input!]!

    """
    upsert condition
    """
    on_conflict: ec_modification_service_on_conflict
  ): ec_modification_service_mutation_response

  """
  insert a single row into the table: "ec.modification_service"
  """
  insert_ec_modification_service_one(
    """
    the row to be inserted
    """
    object: ec_modification_service_insert_input!

    """
    upsert condition
    """
    on_conflict: ec_modification_service_on_conflict
  ): ec_modification_service

  """
  insert data into the table: "ec.parcours"
  """
  insert_ec_parcours(
    """
    the rows to be inserted
    """
    objects: [ec_parcours_insert_input!]!

    """
    upsert condition
    """
    on_conflict: ec_parcours_on_conflict
  ): ec_parcours_mutation_response

  """
  insert a single row into the table: "ec.parcours"
  """
  insert_ec_parcours_one(
    """
    the row to be inserted
    """
    object: ec_parcours_insert_input!

    """
    upsert condition
    """
    on_conflict: ec_parcours_on_conflict
  ): ec_parcours

  """
  insert data into the table: "ec.phase"
  """
  insert_ec_phase(
    """
    the rows to be inserted
    """
    objects: [ec_phase_insert_input!]!

    """
    upsert condition
    """
    on_conflict: ec_phase_on_conflict
  ): ec_phase_mutation_response

  """
  insert a single row into the table: "ec.phase"
  """
  insert_ec_phase_one(
    """
    the row to be inserted
    """
    object: ec_phase_insert_input!

    """
    upsert condition
    """
    on_conflict: ec_phase_on_conflict
  ): ec_phase

  """
  insert data into the table: "ec.priorite"
  """
  insert_ec_priorite(
    """
    the rows to be inserted
    """
    objects: [ec_priorite_insert_input!]!

    """
    upsert condition
    """
    on_conflict: ec_priorite_on_conflict
  ): ec_priorite_mutation_response

  """
  insert a single row into the table: "ec.priorite"
  """
  insert_ec_priorite_one(
    """
    the row to be inserted
    """
    object: ec_priorite_insert_input!

    """
    upsert condition
    """
    on_conflict: ec_priorite_on_conflict
  ): ec_priorite

  """
  insert data into the table: "ec.responsable"
  """
  insert_ec_responsable(
    """
    the rows to be inserted
    """
    objects: [ec_responsable_insert_input!]!

    """
    upsert condition
    """
    on_conflict: ec_responsable_on_conflict
  ): ec_responsable_mutation_response

  """
  insert a single row into the table: "ec.responsable"
  """
  insert_ec_responsable_one(
    """
    the row to be inserted
    """
    object: ec_responsable_insert_input!

    """
    upsert condition
    """
    on_conflict: ec_responsable_on_conflict
  ): ec_responsable

  """
  insert data into the table: "ec.service"
  """
  insert_ec_service(
    """
    the rows to be inserted
    """
    objects: [ec_service_insert_input!]!

    """
    upsert condition
    """
    on_conflict: ec_service_on_conflict
  ): ec_service_mutation_response

  """
  insert a single row into the table: "ec.service"
  """
  insert_ec_service_one(
    """
    the row to be inserted
    """
    object: ec_service_insert_input!

    """
    upsert condition
    """
    on_conflict: ec_service_on_conflict
  ): ec_service

  """
  insert data into the table: "ec.type_demande"
  """
  insert_ec_type_demande(
    """
    the rows to be inserted
    """
    objects: [ec_type_demande_insert_input!]!

    """
    upsert condition
    """
    on_conflict: ec_type_demande_on_conflict
  ): ec_type_demande_mutation_response

  """
  insert a single row into the table: "ec.type_demande"
  """
  insert_ec_type_demande_one(
    """
    the row to be inserted
    """
    object: ec_type_demande_insert_input!

    """
    upsert condition
    """
    on_conflict: ec_type_demande_on_conflict
  ): ec_type_demande

  """
  insert data into the table: "ec.type_enseignement"
  """
  insert_ec_type_enseignement(
    """
    the rows to be inserted
    """
    objects: [ec_type_enseignement_insert_input!]!

    """
    upsert condition
    """
    on_conflict: ec_type_enseignement_on_conflict
  ): ec_type_enseignement_mutation_response

  """
  insert a single row into the table: "ec.type_enseignement"
  """
  insert_ec_type_enseignement_one(
    """
    the row to be inserted
    """
    object: ec_type_enseignement_insert_input!

    """
    upsert condition
    """
    on_conflict: ec_type_enseignement_on_conflict
  ): ec_type_enseignement

  """
  insert data into the table: "ec.type_message"
  """
  insert_ec_type_message(
    """
    the rows to be inserted
    """
    objects: [ec_type_message_insert_input!]!

    """
    upsert condition
    """
    on_conflict: ec_type_message_on_conflict
  ): ec_type_message_mutation_response

  """
  insert a single row into the table: "ec.type_message"
  """
  insert_ec_type_message_one(
    """
    the row to be inserted
    """
    object: ec_type_message_insert_input!

    """
    upsert condition
    """
    on_conflict: ec_type_message_on_conflict
  ): ec_type_message

  """
  insert data into the table: "ec.type_modification"
  """
  insert_ec_type_modification(
    """
    the rows to be inserted
    """
    objects: [ec_type_modification_insert_input!]!

    """
    upsert condition
    """
    on_conflict: ec_type_modification_on_conflict
  ): ec_type_modification_mutation_response

  """
  insert a single row into the table: "ec.type_modification"
  """
  insert_ec_type_modification_one(
    """
    the row to be inserted
    """
    object: ec_type_modification_insert_input!

    """
    upsert condition
    """
    on_conflict: ec_type_modification_on_conflict
  ): ec_type_modification

  """
  update data of the table: "ec.annee"
  """
  update_ec_annee(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ec_annee_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_annee_set_input

    """
    filter the rows which have to be updated
    """
    where: ec_annee_bool_exp!
  ): ec_annee_mutation_response

  """
  update single row of the table: "ec.annee"
  """
  update_ec_annee_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ec_annee_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_annee_set_input
    pk_columns: ec_annee_pk_columns_input!
  ): ec_annee

  """
  update multiples rows of table: "ec.annee"
  """
  update_ec_annee_many(
    """
    updates to execute, in order
    """
    updates: [ec_annee_updates!]!
  ): [ec_annee_mutation_response]

  """
  update data of the table: "ec.cursus"
  """
  update_ec_cursus(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ec_cursus_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_cursus_set_input

    """
    filter the rows which have to be updated
    """
    where: ec_cursus_bool_exp!
  ): ec_cursus_mutation_response

  """
  update single row of the table: "ec.cursus"
  """
  update_ec_cursus_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ec_cursus_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_cursus_set_input
    pk_columns: ec_cursus_pk_columns_input!
  ): ec_cursus

  """
  update multiples rows of table: "ec.cursus"
  """
  update_ec_cursus_many(
    """
    updates to execute, in order
    """
    updates: [ec_cursus_updates!]!
  ): [ec_cursus_mutation_response]

  """
  update data of the table: "ec.demande"
  """
  update_ec_demande(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ec_demande_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_demande_set_input

    """
    filter the rows which have to be updated
    """
    where: ec_demande_bool_exp!
  ): ec_demande_mutation_response

  """
  update single row of the table: "ec.demande"
  """
  update_ec_demande_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ec_demande_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_demande_set_input
    pk_columns: ec_demande_pk_columns_input!
  ): ec_demande

  """
  update multiples rows of table: "ec.demande"
  """
  update_ec_demande_many(
    """
    updates to execute, in order
    """
    updates: [ec_demande_updates!]!
  ): [ec_demande_mutation_response]

  """
  update data of the table: "ec.enseignement"
  """
  update_ec_enseignement(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ec_enseignement_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_enseignement_set_input

    """
    filter the rows which have to be updated
    """
    where: ec_enseignement_bool_exp!
  ): ec_enseignement_mutation_response

  """
  update single row of the table: "ec.enseignement"
  """
  update_ec_enseignement_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ec_enseignement_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_enseignement_set_input
    pk_columns: ec_enseignement_pk_columns_input!
  ): ec_enseignement

  """
  update multiples rows of table: "ec.enseignement"
  """
  update_ec_enseignement_many(
    """
    updates to execute, in order
    """
    updates: [ec_enseignement_updates!]!
  ): [ec_enseignement_mutation_response]

  """
  update data of the table: "ec.intervenant"
  """
  update_ec_intervenant(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ec_intervenant_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_intervenant_set_input

    """
    filter the rows which have to be updated
    """
    where: ec_intervenant_bool_exp!
  ): ec_intervenant_mutation_response

  """
  update single row of the table: "ec.intervenant"
  """
  update_ec_intervenant_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ec_intervenant_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_intervenant_set_input
    pk_columns: ec_intervenant_pk_columns_input!
  ): ec_intervenant

  """
  update multiples rows of table: "ec.intervenant"
  """
  update_ec_intervenant_many(
    """
    updates to execute, in order
    """
    updates: [ec_intervenant_updates!]!
  ): [ec_intervenant_mutation_response]

  """
  update data of the table: "ec.mention"
  """
  update_ec_mention(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ec_mention_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_mention_set_input

    """
    filter the rows which have to be updated
    """
    where: ec_mention_bool_exp!
  ): ec_mention_mutation_response

  """
  update single row of the table: "ec.mention"
  """
  update_ec_mention_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ec_mention_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_mention_set_input
    pk_columns: ec_mention_pk_columns_input!
  ): ec_mention

  """
  update multiples rows of table: "ec.mention"
  """
  update_ec_mention_many(
    """
    updates to execute, in order
    """
    updates: [ec_mention_updates!]!
  ): [ec_mention_mutation_response]

  """
  update data of the table: "ec.message"
  """
  update_ec_message(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ec_message_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_message_set_input

    """
    filter the rows which have to be updated
    """
    where: ec_message_bool_exp!
  ): ec_message_mutation_response

  """
  update single row of the table: "ec.message"
  """
  update_ec_message_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ec_message_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_message_set_input
    pk_columns: ec_message_pk_columns_input!
  ): ec_message

  """
  update multiples rows of table: "ec.message"
  """
  update_ec_message_many(
    """
    updates to execute, in order
    """
    updates: [ec_message_updates!]!
  ): [ec_message_mutation_response]

  """
  update data of the table: "ec.modification_service"
  """
  update_ec_modification_service(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ec_modification_service_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_modification_service_set_input

    """
    filter the rows which have to be updated
    """
    where: ec_modification_service_bool_exp!
  ): ec_modification_service_mutation_response

  """
  update single row of the table: "ec.modification_service"
  """
  update_ec_modification_service_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ec_modification_service_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_modification_service_set_input
    pk_columns: ec_modification_service_pk_columns_input!
  ): ec_modification_service

  """
  update multiples rows of table: "ec.modification_service"
  """
  update_ec_modification_service_many(
    """
    updates to execute, in order
    """
    updates: [ec_modification_service_updates!]!
  ): [ec_modification_service_mutation_response]

  """
  update data of the table: "ec.parcours"
  """
  update_ec_parcours(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ec_parcours_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_parcours_set_input

    """
    filter the rows which have to be updated
    """
    where: ec_parcours_bool_exp!
  ): ec_parcours_mutation_response

  """
  update single row of the table: "ec.parcours"
  """
  update_ec_parcours_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ec_parcours_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_parcours_set_input
    pk_columns: ec_parcours_pk_columns_input!
  ): ec_parcours

  """
  update multiples rows of table: "ec.parcours"
  """
  update_ec_parcours_many(
    """
    updates to execute, in order
    """
    updates: [ec_parcours_updates!]!
  ): [ec_parcours_mutation_response]

  """
  update data of the table: "ec.phase"
  """
  update_ec_phase(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_phase_set_input

    """
    filter the rows which have to be updated
    """
    where: ec_phase_bool_exp!
  ): ec_phase_mutation_response

  """
  update single row of the table: "ec.phase"
  """
  update_ec_phase_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_phase_set_input
    pk_columns: ec_phase_pk_columns_input!
  ): ec_phase

  """
  update multiples rows of table: "ec.phase"
  """
  update_ec_phase_many(
    """
    updates to execute, in order
    """
    updates: [ec_phase_updates!]!
  ): [ec_phase_mutation_response]

  """
  update data of the table: "ec.priorite"
  """
  update_ec_priorite(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ec_priorite_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_priorite_set_input

    """
    filter the rows which have to be updated
    """
    where: ec_priorite_bool_exp!
  ): ec_priorite_mutation_response

  """
  update single row of the table: "ec.priorite"
  """
  update_ec_priorite_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ec_priorite_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_priorite_set_input
    pk_columns: ec_priorite_pk_columns_input!
  ): ec_priorite

  """
  update multiples rows of table: "ec.priorite"
  """
  update_ec_priorite_many(
    """
    updates to execute, in order
    """
    updates: [ec_priorite_updates!]!
  ): [ec_priorite_mutation_response]

  """
  update data of the table: "ec.responsable"
  """
  update_ec_responsable(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ec_responsable_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_responsable_set_input

    """
    filter the rows which have to be updated
    """
    where: ec_responsable_bool_exp!
  ): ec_responsable_mutation_response

  """
  update single row of the table: "ec.responsable"
  """
  update_ec_responsable_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ec_responsable_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_responsable_set_input
    pk_columns: ec_responsable_pk_columns_input!
  ): ec_responsable

  """
  update multiples rows of table: "ec.responsable"
  """
  update_ec_responsable_many(
    """
    updates to execute, in order
    """
    updates: [ec_responsable_updates!]!
  ): [ec_responsable_mutation_response]

  """
  update data of the table: "ec.service"
  """
  update_ec_service(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ec_service_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_service_set_input

    """
    filter the rows which have to be updated
    """
    where: ec_service_bool_exp!
  ): ec_service_mutation_response

  """
  update single row of the table: "ec.service"
  """
  update_ec_service_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ec_service_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_service_set_input
    pk_columns: ec_service_pk_columns_input!
  ): ec_service

  """
  update multiples rows of table: "ec.service"
  """
  update_ec_service_many(
    """
    updates to execute, in order
    """
    updates: [ec_service_updates!]!
  ): [ec_service_mutation_response]

  """
  update data of the table: "ec.type_demande"
  """
  update_ec_type_demande(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_type_demande_set_input

    """
    filter the rows which have to be updated
    """
    where: ec_type_demande_bool_exp!
  ): ec_type_demande_mutation_response

  """
  update single row of the table: "ec.type_demande"
  """
  update_ec_type_demande_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_type_demande_set_input
    pk_columns: ec_type_demande_pk_columns_input!
  ): ec_type_demande

  """
  update multiples rows of table: "ec.type_demande"
  """
  update_ec_type_demande_many(
    """
    updates to execute, in order
    """
    updates: [ec_type_demande_updates!]!
  ): [ec_type_demande_mutation_response]

  """
  update data of the table: "ec.type_enseignement"
  """
  update_ec_type_enseignement(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ec_type_enseignement_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_type_enseignement_set_input

    """
    filter the rows which have to be updated
    """
    where: ec_type_enseignement_bool_exp!
  ): ec_type_enseignement_mutation_response

  """
  update single row of the table: "ec.type_enseignement"
  """
  update_ec_type_enseignement_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ec_type_enseignement_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_type_enseignement_set_input
    pk_columns: ec_type_enseignement_pk_columns_input!
  ): ec_type_enseignement

  """
  update multiples rows of table: "ec.type_enseignement"
  """
  update_ec_type_enseignement_many(
    """
    updates to execute, in order
    """
    updates: [ec_type_enseignement_updates!]!
  ): [ec_type_enseignement_mutation_response]

  """
  update data of the table: "ec.type_message"
  """
  update_ec_type_message(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_type_message_set_input

    """
    filter the rows which have to be updated
    """
    where: ec_type_message_bool_exp!
  ): ec_type_message_mutation_response

  """
  update single row of the table: "ec.type_message"
  """
  update_ec_type_message_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_type_message_set_input
    pk_columns: ec_type_message_pk_columns_input!
  ): ec_type_message

  """
  update multiples rows of table: "ec.type_message"
  """
  update_ec_type_message_many(
    """
    updates to execute, in order
    """
    updates: [ec_type_message_updates!]!
  ): [ec_type_message_mutation_response]

  """
  update data of the table: "ec.type_modification"
  """
  update_ec_type_modification(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_type_modification_set_input

    """
    filter the rows which have to be updated
    """
    where: ec_type_modification_bool_exp!
  ): ec_type_modification_mutation_response

  """
  update single row of the table: "ec.type_modification"
  """
  update_ec_type_modification_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: ec_type_modification_set_input
    pk_columns: ec_type_modification_pk_columns_input!
  ): ec_type_modification

  """
  update multiples rows of table: "ec.type_modification"
  """
  update_ec_type_modification_many(
    """
    updates to execute, in order
    """
    updates: [ec_type_modification_updates!]!
  ): [ec_type_modification_mutation_response]
}

"""
column ordering options
"""
enum order_by {
  """
  in ascending order, nulls last
  """
  asc

  """
  in ascending order, nulls first
  """
  asc_nulls_first

  """
  in ascending order, nulls last
  """
  asc_nulls_last

  """
  in descending order, nulls first
  """
  desc

  """
  in descending order, nulls first
  """
  desc_nulls_first

  """
  in descending order, nulls last
  """
  desc_nulls_last
}

type query_root {
  """
  fetch data from the table: "ec.annee"
  """
  ec_annee(
    """
    distinct select on columns
    """
    distinct_on: [ec_annee_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_annee_order_by!]

    """
    filter the rows returned
    """
    where: ec_annee_bool_exp
  ): [ec_annee!]!

  """
  fetch aggregated fields from the table: "ec.annee"
  """
  ec_annee_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_annee_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_annee_order_by!]

    """
    filter the rows returned
    """
    where: ec_annee_bool_exp
  ): ec_annee_aggregate!

  """
  fetch data from the table: "ec.annee" using primary key columns
  """
  ec_annee_by_pk(
    """
    Le numéro de l'année (unique).
    """
    value: Int!
  ): ec_annee

  """
  fetch data from the table: "ec.cursus"
  """
  ec_cursus(
    """
    distinct select on columns
    """
    distinct_on: [ec_cursus_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_cursus_order_by!]

    """
    filter the rows returned
    """
    where: ec_cursus_bool_exp
  ): [ec_cursus!]!

  """
  fetch aggregated fields from the table: "ec.cursus"
  """
  ec_cursus_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_cursus_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_cursus_order_by!]

    """
    filter the rows returned
    """
    where: ec_cursus_bool_exp
  ): ec_cursus_aggregate!

  """
  fetch data from the table: "ec.cursus" using primary key columns
  """
  ec_cursus_by_pk(
    """
    L'identifiant unique du cursus.
    """
    id: Int!
  ): ec_cursus

  """
  fetch data from the table: "ec.demande"
  """
  ec_demande(
    """
    distinct select on columns
    """
    distinct_on: [ec_demande_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_demande_order_by!]

    """
    filter the rows returned
    """
    where: ec_demande_bool_exp
  ): [ec_demande!]!

  """
  fetch aggregated fields from the table: "ec.demande"
  """
  ec_demande_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_demande_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_demande_order_by!]

    """
    filter the rows returned
    """
    where: ec_demande_bool_exp
  ): ec_demande_aggregate!

  """
  fetch data from the table: "ec.demande" using primary key columns
  """
  ec_demande_by_pk(id: Int!): ec_demande

  """
  fetch data from the table: "ec.enseignement"
  """
  ec_enseignement(
    """
    distinct select on columns
    """
    distinct_on: [ec_enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_enseignement_order_by!]

    """
    filter the rows returned
    """
    where: ec_enseignement_bool_exp
  ): [ec_enseignement!]!

  """
  fetch aggregated fields from the table: "ec.enseignement"
  """
  ec_enseignement_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_enseignement_order_by!]

    """
    filter the rows returned
    """
    where: ec_enseignement_bool_exp
  ): ec_enseignement_aggregate!

  """
  fetch data from the table: "ec.enseignement" using primary key columns
  """
  ec_enseignement_by_pk(
    """
    L'identifiant unique de l'enseignement.
    """
    id: Int!
  ): ec_enseignement

  """
  fetch data from the table: "ec.intervenant"
  """
  ec_intervenant(
    """
    distinct select on columns
    """
    distinct_on: [ec_intervenant_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_intervenant_order_by!]

    """
    filter the rows returned
    """
    where: ec_intervenant_bool_exp
  ): [ec_intervenant!]!

  """
  fetch aggregated fields from the table: "ec.intervenant"
  """
  ec_intervenant_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_intervenant_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_intervenant_order_by!]

    """
    filter the rows returned
    """
    where: ec_intervenant_bool_exp
  ): ec_intervenant_aggregate!

  """
  fetch data from the table: "ec.intervenant" using primary key columns
  """
  ec_intervenant_by_pk(
    """
    L'identifiant unique de l'intervenant.
    """
    uid: String!
  ): ec_intervenant

  """
  fetch data from the table: "ec.mention"
  """
  ec_mention(
    """
    distinct select on columns
    """
    distinct_on: [ec_mention_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_mention_order_by!]

    """
    filter the rows returned
    """
    where: ec_mention_bool_exp
  ): [ec_mention!]!

  """
  fetch aggregated fields from the table: "ec.mention"
  """
  ec_mention_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_mention_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_mention_order_by!]

    """
    filter the rows returned
    """
    where: ec_mention_bool_exp
  ): ec_mention_aggregate!

  """
  fetch data from the table: "ec.mention" using primary key columns
  """
  ec_mention_by_pk(
    """
    L'identifiant unique de la mention.
    """
    id: Int!
  ): ec_mention

  """
  fetch data from the table: "ec.message"
  """
  ec_message(
    """
    distinct select on columns
    """
    distinct_on: [ec_message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_message_order_by!]

    """
    filter the rows returned
    """
    where: ec_message_bool_exp
  ): [ec_message!]!

  """
  fetch aggregated fields from the table: "ec.message"
  """
  ec_message_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_message_order_by!]

    """
    filter the rows returned
    """
    where: ec_message_bool_exp
  ): ec_message_aggregate!

  """
  fetch data from the table: "ec.message" using primary key columns
  """
  ec_message_by_pk(
    """
    L'identifiant unique du message.
    """
    id: Int!
  ): ec_message

  """
  fetch data from the table: "ec.modification_service"
  """
  ec_modification_service(
    """
    distinct select on columns
    """
    distinct_on: [ec_modification_service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_modification_service_order_by!]

    """
    filter the rows returned
    """
    where: ec_modification_service_bool_exp
  ): [ec_modification_service!]!

  """
  fetch aggregated fields from the table: "ec.modification_service"
  """
  ec_modification_service_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_modification_service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_modification_service_order_by!]

    """
    filter the rows returned
    """
    where: ec_modification_service_bool_exp
  ): ec_modification_service_aggregate!

  """
  fetch data from the table: "ec.modification_service" using primary key columns
  """
  ec_modification_service_by_pk(
    """
    L'identifiant unique de la modification.
    """
    id: Int!
  ): ec_modification_service

  """
  fetch data from the table: "ec.parcours"
  """
  ec_parcours(
    """
    distinct select on columns
    """
    distinct_on: [ec_parcours_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_parcours_order_by!]

    """
    filter the rows returned
    """
    where: ec_parcours_bool_exp
  ): [ec_parcours!]!

  """
  fetch aggregated fields from the table: "ec.parcours"
  """
  ec_parcours_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_parcours_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_parcours_order_by!]

    """
    filter the rows returned
    """
    where: ec_parcours_bool_exp
  ): ec_parcours_aggregate!

  """
  fetch data from the table: "ec.parcours" using primary key columns
  """
  ec_parcours_by_pk(
    """
    L'identifiant unique du parcours.
    """
    id: Int!
  ): ec_parcours

  """
  fetch data from the table: "ec.phase"
  """
  ec_phase(
    """
    distinct select on columns
    """
    distinct_on: [ec_phase_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_phase_order_by!]

    """
    filter the rows returned
    """
    where: ec_phase_bool_exp
  ): [ec_phase!]!

  """
  fetch aggregated fields from the table: "ec.phase"
  """
  ec_phase_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_phase_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_phase_order_by!]

    """
    filter the rows returned
    """
    where: ec_phase_bool_exp
  ): ec_phase_aggregate!

  """
  fetch data from the table: "ec.phase" using primary key columns
  """
  ec_phase_by_pk(
    """
    Le nom de la phase (unique).
    """
    value: String!
  ): ec_phase

  """
  fetch data from the table: "ec.priorite"
  """
  ec_priorite(
    """
    distinct select on columns
    """
    distinct_on: [ec_priorite_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_priorite_order_by!]

    """
    filter the rows returned
    """
    where: ec_priorite_bool_exp
  ): [ec_priorite!]!

  """
  fetch aggregated fields from the table: "ec.priorite"
  """
  ec_priorite_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_priorite_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_priorite_order_by!]

    """
    filter the rows returned
    """
    where: ec_priorite_bool_exp
  ): ec_priorite_aggregate!

  """
  fetch data from the table: "ec.priorite" using primary key columns
  """
  ec_priorite_by_pk(id: Int!): ec_priorite

  """
  fetch data from the table: "ec.responsable"
  """
  ec_responsable(
    """
    distinct select on columns
    """
    distinct_on: [ec_responsable_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_responsable_order_by!]

    """
    filter the rows returned
    """
    where: ec_responsable_bool_exp
  ): [ec_responsable!]!

  """
  fetch aggregated fields from the table: "ec.responsable"
  """
  ec_responsable_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_responsable_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_responsable_order_by!]

    """
    filter the rows returned
    """
    where: ec_responsable_bool_exp
  ): ec_responsable_aggregate!

  """
  fetch data from the table: "ec.responsable" using primary key columns
  """
  ec_responsable_by_pk(id: Int!): ec_responsable

  """
  fetch data from the table: "ec.service"
  """
  ec_service(
    """
    distinct select on columns
    """
    distinct_on: [ec_service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_service_order_by!]

    """
    filter the rows returned
    """
    where: ec_service_bool_exp
  ): [ec_service!]!

  """
  fetch aggregated fields from the table: "ec.service"
  """
  ec_service_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_service_order_by!]

    """
    filter the rows returned
    """
    where: ec_service_bool_exp
  ): ec_service_aggregate!

  """
  fetch data from the table: "ec.service" using primary key columns
  """
  ec_service_by_pk(
    """
    L'identifiant unique du service.
    """
    id: Int!
  ): ec_service

  """
  fetch data from the table: "ec.type_demande"
  """
  ec_type_demande(
    """
    distinct select on columns
    """
    distinct_on: [ec_type_demande_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_type_demande_order_by!]

    """
    filter the rows returned
    """
    where: ec_type_demande_bool_exp
  ): [ec_type_demande!]!

  """
  fetch aggregated fields from the table: "ec.type_demande"
  """
  ec_type_demande_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_type_demande_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_type_demande_order_by!]

    """
    filter the rows returned
    """
    where: ec_type_demande_bool_exp
  ): ec_type_demande_aggregate!

  """
  fetch data from the table: "ec.type_demande" using primary key columns
  """
  ec_type_demande_by_pk(
    """
    Le type de demande (unique).
    """
    value: String!
  ): ec_type_demande

  """
  fetch data from the table: "ec.type_enseignement"
  """
  ec_type_enseignement(
    """
    distinct select on columns
    """
    distinct_on: [ec_type_enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_type_enseignement_order_by!]

    """
    filter the rows returned
    """
    where: ec_type_enseignement_bool_exp
  ): [ec_type_enseignement!]!

  """
  fetch aggregated fields from the table: "ec.type_enseignement"
  """
  ec_type_enseignement_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_type_enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_type_enseignement_order_by!]

    """
    filter the rows returned
    """
    where: ec_type_enseignement_bool_exp
  ): ec_type_enseignement_aggregate!

  """
  fetch data from the table: "ec.type_enseignement" using primary key columns
  """
  ec_type_enseignement_by_pk(
    """
    Le type d'enseignement (unique).
    """
    label: String!
  ): ec_type_enseignement

  """
  fetch data from the table: "ec.type_message"
  """
  ec_type_message(
    """
    distinct select on columns
    """
    distinct_on: [ec_type_message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_type_message_order_by!]

    """
    filter the rows returned
    """
    where: ec_type_message_bool_exp
  ): [ec_type_message!]!

  """
  fetch aggregated fields from the table: "ec.type_message"
  """
  ec_type_message_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_type_message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_type_message_order_by!]

    """
    filter the rows returned
    """
    where: ec_type_message_bool_exp
  ): ec_type_message_aggregate!

  """
  fetch data from the table: "ec.type_message" using primary key columns
  """
  ec_type_message_by_pk(
    """
    Le type de message (unique).
    """
    value: String!
  ): ec_type_message

  """
  fetch data from the table: "ec.type_modification"
  """
  ec_type_modification(
    """
    distinct select on columns
    """
    distinct_on: [ec_type_modification_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_type_modification_order_by!]

    """
    filter the rows returned
    """
    where: ec_type_modification_bool_exp
  ): [ec_type_modification!]!

  """
  fetch aggregated fields from the table: "ec.type_modification"
  """
  ec_type_modification_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_type_modification_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_type_modification_order_by!]

    """
    filter the rows returned
    """
    where: ec_type_modification_bool_exp
  ): ec_type_modification_aggregate!

  """
  fetch data from the table: "ec.type_modification" using primary key columns
  """
  ec_type_modification_by_pk(
    """
    Le type de modification (unique).
    """
    label: String!
  ): ec_type_modification
}

type subscription_root {
  """
  fetch data from the table: "ec.annee"
  """
  ec_annee(
    """
    distinct select on columns
    """
    distinct_on: [ec_annee_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_annee_order_by!]

    """
    filter the rows returned
    """
    where: ec_annee_bool_exp
  ): [ec_annee!]!

  """
  fetch aggregated fields from the table: "ec.annee"
  """
  ec_annee_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_annee_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_annee_order_by!]

    """
    filter the rows returned
    """
    where: ec_annee_bool_exp
  ): ec_annee_aggregate!

  """
  fetch data from the table: "ec.annee" using primary key columns
  """
  ec_annee_by_pk(
    """
    Le numéro de l'année (unique).
    """
    value: Int!
  ): ec_annee

  """
  fetch data from the table in a streaming manner: "ec.annee"
  """
  ec_annee_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [ec_annee_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: ec_annee_bool_exp
  ): [ec_annee!]!

  """
  fetch data from the table: "ec.cursus"
  """
  ec_cursus(
    """
    distinct select on columns
    """
    distinct_on: [ec_cursus_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_cursus_order_by!]

    """
    filter the rows returned
    """
    where: ec_cursus_bool_exp
  ): [ec_cursus!]!

  """
  fetch aggregated fields from the table: "ec.cursus"
  """
  ec_cursus_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_cursus_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_cursus_order_by!]

    """
    filter the rows returned
    """
    where: ec_cursus_bool_exp
  ): ec_cursus_aggregate!

  """
  fetch data from the table: "ec.cursus" using primary key columns
  """
  ec_cursus_by_pk(
    """
    L'identifiant unique du cursus.
    """
    id: Int!
  ): ec_cursus

  """
  fetch data from the table in a streaming manner: "ec.cursus"
  """
  ec_cursus_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [ec_cursus_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: ec_cursus_bool_exp
  ): [ec_cursus!]!

  """
  fetch data from the table: "ec.demande"
  """
  ec_demande(
    """
    distinct select on columns
    """
    distinct_on: [ec_demande_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_demande_order_by!]

    """
    filter the rows returned
    """
    where: ec_demande_bool_exp
  ): [ec_demande!]!

  """
  fetch aggregated fields from the table: "ec.demande"
  """
  ec_demande_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_demande_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_demande_order_by!]

    """
    filter the rows returned
    """
    where: ec_demande_bool_exp
  ): ec_demande_aggregate!

  """
  fetch data from the table: "ec.demande" using primary key columns
  """
  ec_demande_by_pk(id: Int!): ec_demande

  """
  fetch data from the table in a streaming manner: "ec.demande"
  """
  ec_demande_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [ec_demande_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: ec_demande_bool_exp
  ): [ec_demande!]!

  """
  fetch data from the table: "ec.enseignement"
  """
  ec_enseignement(
    """
    distinct select on columns
    """
    distinct_on: [ec_enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_enseignement_order_by!]

    """
    filter the rows returned
    """
    where: ec_enseignement_bool_exp
  ): [ec_enseignement!]!

  """
  fetch aggregated fields from the table: "ec.enseignement"
  """
  ec_enseignement_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_enseignement_order_by!]

    """
    filter the rows returned
    """
    where: ec_enseignement_bool_exp
  ): ec_enseignement_aggregate!

  """
  fetch data from the table: "ec.enseignement" using primary key columns
  """
  ec_enseignement_by_pk(
    """
    L'identifiant unique de l'enseignement.
    """
    id: Int!
  ): ec_enseignement

  """
  fetch data from the table in a streaming manner: "ec.enseignement"
  """
  ec_enseignement_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [ec_enseignement_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: ec_enseignement_bool_exp
  ): [ec_enseignement!]!

  """
  fetch data from the table: "ec.intervenant"
  """
  ec_intervenant(
    """
    distinct select on columns
    """
    distinct_on: [ec_intervenant_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_intervenant_order_by!]

    """
    filter the rows returned
    """
    where: ec_intervenant_bool_exp
  ): [ec_intervenant!]!

  """
  fetch aggregated fields from the table: "ec.intervenant"
  """
  ec_intervenant_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_intervenant_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_intervenant_order_by!]

    """
    filter the rows returned
    """
    where: ec_intervenant_bool_exp
  ): ec_intervenant_aggregate!

  """
  fetch data from the table: "ec.intervenant" using primary key columns
  """
  ec_intervenant_by_pk(
    """
    L'identifiant unique de l'intervenant.
    """
    uid: String!
  ): ec_intervenant

  """
  fetch data from the table in a streaming manner: "ec.intervenant"
  """
  ec_intervenant_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [ec_intervenant_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: ec_intervenant_bool_exp
  ): [ec_intervenant!]!

  """
  fetch data from the table: "ec.mention"
  """
  ec_mention(
    """
    distinct select on columns
    """
    distinct_on: [ec_mention_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_mention_order_by!]

    """
    filter the rows returned
    """
    where: ec_mention_bool_exp
  ): [ec_mention!]!

  """
  fetch aggregated fields from the table: "ec.mention"
  """
  ec_mention_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_mention_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_mention_order_by!]

    """
    filter the rows returned
    """
    where: ec_mention_bool_exp
  ): ec_mention_aggregate!

  """
  fetch data from the table: "ec.mention" using primary key columns
  """
  ec_mention_by_pk(
    """
    L'identifiant unique de la mention.
    """
    id: Int!
  ): ec_mention

  """
  fetch data from the table in a streaming manner: "ec.mention"
  """
  ec_mention_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [ec_mention_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: ec_mention_bool_exp
  ): [ec_mention!]!

  """
  fetch data from the table: "ec.message"
  """
  ec_message(
    """
    distinct select on columns
    """
    distinct_on: [ec_message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_message_order_by!]

    """
    filter the rows returned
    """
    where: ec_message_bool_exp
  ): [ec_message!]!

  """
  fetch aggregated fields from the table: "ec.message"
  """
  ec_message_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_message_order_by!]

    """
    filter the rows returned
    """
    where: ec_message_bool_exp
  ): ec_message_aggregate!

  """
  fetch data from the table: "ec.message" using primary key columns
  """
  ec_message_by_pk(
    """
    L'identifiant unique du message.
    """
    id: Int!
  ): ec_message

  """
  fetch data from the table in a streaming manner: "ec.message"
  """
  ec_message_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [ec_message_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: ec_message_bool_exp
  ): [ec_message!]!

  """
  fetch data from the table: "ec.modification_service"
  """
  ec_modification_service(
    """
    distinct select on columns
    """
    distinct_on: [ec_modification_service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_modification_service_order_by!]

    """
    filter the rows returned
    """
    where: ec_modification_service_bool_exp
  ): [ec_modification_service!]!

  """
  fetch aggregated fields from the table: "ec.modification_service"
  """
  ec_modification_service_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_modification_service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_modification_service_order_by!]

    """
    filter the rows returned
    """
    where: ec_modification_service_bool_exp
  ): ec_modification_service_aggregate!

  """
  fetch data from the table: "ec.modification_service" using primary key columns
  """
  ec_modification_service_by_pk(
    """
    L'identifiant unique de la modification.
    """
    id: Int!
  ): ec_modification_service

  """
  fetch data from the table in a streaming manner: "ec.modification_service"
  """
  ec_modification_service_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [ec_modification_service_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: ec_modification_service_bool_exp
  ): [ec_modification_service!]!

  """
  fetch data from the table: "ec.parcours"
  """
  ec_parcours(
    """
    distinct select on columns
    """
    distinct_on: [ec_parcours_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_parcours_order_by!]

    """
    filter the rows returned
    """
    where: ec_parcours_bool_exp
  ): [ec_parcours!]!

  """
  fetch aggregated fields from the table: "ec.parcours"
  """
  ec_parcours_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_parcours_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_parcours_order_by!]

    """
    filter the rows returned
    """
    where: ec_parcours_bool_exp
  ): ec_parcours_aggregate!

  """
  fetch data from the table: "ec.parcours" using primary key columns
  """
  ec_parcours_by_pk(
    """
    L'identifiant unique du parcours.
    """
    id: Int!
  ): ec_parcours

  """
  fetch data from the table in a streaming manner: "ec.parcours"
  """
  ec_parcours_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [ec_parcours_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: ec_parcours_bool_exp
  ): [ec_parcours!]!

  """
  fetch data from the table: "ec.phase"
  """
  ec_phase(
    """
    distinct select on columns
    """
    distinct_on: [ec_phase_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_phase_order_by!]

    """
    filter the rows returned
    """
    where: ec_phase_bool_exp
  ): [ec_phase!]!

  """
  fetch aggregated fields from the table: "ec.phase"
  """
  ec_phase_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_phase_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_phase_order_by!]

    """
    filter the rows returned
    """
    where: ec_phase_bool_exp
  ): ec_phase_aggregate!

  """
  fetch data from the table: "ec.phase" using primary key columns
  """
  ec_phase_by_pk(
    """
    Le nom de la phase (unique).
    """
    value: String!
  ): ec_phase

  """
  fetch data from the table in a streaming manner: "ec.phase"
  """
  ec_phase_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [ec_phase_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: ec_phase_bool_exp
  ): [ec_phase!]!

  """
  fetch data from the table: "ec.priorite"
  """
  ec_priorite(
    """
    distinct select on columns
    """
    distinct_on: [ec_priorite_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_priorite_order_by!]

    """
    filter the rows returned
    """
    where: ec_priorite_bool_exp
  ): [ec_priorite!]!

  """
  fetch aggregated fields from the table: "ec.priorite"
  """
  ec_priorite_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_priorite_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_priorite_order_by!]

    """
    filter the rows returned
    """
    where: ec_priorite_bool_exp
  ): ec_priorite_aggregate!

  """
  fetch data from the table: "ec.priorite" using primary key columns
  """
  ec_priorite_by_pk(id: Int!): ec_priorite

  """
  fetch data from the table in a streaming manner: "ec.priorite"
  """
  ec_priorite_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [ec_priorite_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: ec_priorite_bool_exp
  ): [ec_priorite!]!

  """
  fetch data from the table: "ec.responsable"
  """
  ec_responsable(
    """
    distinct select on columns
    """
    distinct_on: [ec_responsable_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_responsable_order_by!]

    """
    filter the rows returned
    """
    where: ec_responsable_bool_exp
  ): [ec_responsable!]!

  """
  fetch aggregated fields from the table: "ec.responsable"
  """
  ec_responsable_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_responsable_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_responsable_order_by!]

    """
    filter the rows returned
    """
    where: ec_responsable_bool_exp
  ): ec_responsable_aggregate!

  """
  fetch data from the table: "ec.responsable" using primary key columns
  """
  ec_responsable_by_pk(id: Int!): ec_responsable

  """
  fetch data from the table in a streaming manner: "ec.responsable"
  """
  ec_responsable_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [ec_responsable_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: ec_responsable_bool_exp
  ): [ec_responsable!]!

  """
  fetch data from the table: "ec.service"
  """
  ec_service(
    """
    distinct select on columns
    """
    distinct_on: [ec_service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_service_order_by!]

    """
    filter the rows returned
    """
    where: ec_service_bool_exp
  ): [ec_service!]!

  """
  fetch aggregated fields from the table: "ec.service"
  """
  ec_service_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_service_order_by!]

    """
    filter the rows returned
    """
    where: ec_service_bool_exp
  ): ec_service_aggregate!

  """
  fetch data from the table: "ec.service" using primary key columns
  """
  ec_service_by_pk(
    """
    L'identifiant unique du service.
    """
    id: Int!
  ): ec_service

  """
  fetch data from the table in a streaming manner: "ec.service"
  """
  ec_service_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [ec_service_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: ec_service_bool_exp
  ): [ec_service!]!

  """
  fetch data from the table: "ec.type_demande"
  """
  ec_type_demande(
    """
    distinct select on columns
    """
    distinct_on: [ec_type_demande_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_type_demande_order_by!]

    """
    filter the rows returned
    """
    where: ec_type_demande_bool_exp
  ): [ec_type_demande!]!

  """
  fetch aggregated fields from the table: "ec.type_demande"
  """
  ec_type_demande_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_type_demande_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_type_demande_order_by!]

    """
    filter the rows returned
    """
    where: ec_type_demande_bool_exp
  ): ec_type_demande_aggregate!

  """
  fetch data from the table: "ec.type_demande" using primary key columns
  """
  ec_type_demande_by_pk(
    """
    Le type de demande (unique).
    """
    value: String!
  ): ec_type_demande

  """
  fetch data from the table in a streaming manner: "ec.type_demande"
  """
  ec_type_demande_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [ec_type_demande_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: ec_type_demande_bool_exp
  ): [ec_type_demande!]!

  """
  fetch data from the table: "ec.type_enseignement"
  """
  ec_type_enseignement(
    """
    distinct select on columns
    """
    distinct_on: [ec_type_enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_type_enseignement_order_by!]

    """
    filter the rows returned
    """
    where: ec_type_enseignement_bool_exp
  ): [ec_type_enseignement!]!

  """
  fetch aggregated fields from the table: "ec.type_enseignement"
  """
  ec_type_enseignement_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_type_enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_type_enseignement_order_by!]

    """
    filter the rows returned
    """
    where: ec_type_enseignement_bool_exp
  ): ec_type_enseignement_aggregate!

  """
  fetch data from the table: "ec.type_enseignement" using primary key columns
  """
  ec_type_enseignement_by_pk(
    """
    Le type d'enseignement (unique).
    """
    label: String!
  ): ec_type_enseignement

  """
  fetch data from the table in a streaming manner: "ec.type_enseignement"
  """
  ec_type_enseignement_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [ec_type_enseignement_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: ec_type_enseignement_bool_exp
  ): [ec_type_enseignement!]!

  """
  fetch data from the table: "ec.type_message"
  """
  ec_type_message(
    """
    distinct select on columns
    """
    distinct_on: [ec_type_message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_type_message_order_by!]

    """
    filter the rows returned
    """
    where: ec_type_message_bool_exp
  ): [ec_type_message!]!

  """
  fetch aggregated fields from the table: "ec.type_message"
  """
  ec_type_message_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_type_message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_type_message_order_by!]

    """
    filter the rows returned
    """
    where: ec_type_message_bool_exp
  ): ec_type_message_aggregate!

  """
  fetch data from the table: "ec.type_message" using primary key columns
  """
  ec_type_message_by_pk(
    """
    Le type de message (unique).
    """
    value: String!
  ): ec_type_message

  """
  fetch data from the table in a streaming manner: "ec.type_message"
  """
  ec_type_message_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [ec_type_message_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: ec_type_message_bool_exp
  ): [ec_type_message!]!

  """
  fetch data from the table: "ec.type_modification"
  """
  ec_type_modification(
    """
    distinct select on columns
    """
    distinct_on: [ec_type_modification_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_type_modification_order_by!]

    """
    filter the rows returned
    """
    where: ec_type_modification_bool_exp
  ): [ec_type_modification!]!

  """
  fetch aggregated fields from the table: "ec.type_modification"
  """
  ec_type_modification_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [ec_type_modification_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [ec_type_modification_order_by!]

    """
    filter the rows returned
    """
    where: ec_type_modification_bool_exp
  ): ec_type_modification_aggregate!

  """
  fetch data from the table: "ec.type_modification" using primary key columns
  """
  ec_type_modification_by_pk(
    """
    Le type de modification (unique).
    """
    label: String!
  ): ec_type_modification

  """
  fetch data from the table in a streaming manner: "ec.type_modification"
  """
  ec_type_modification_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [ec_type_modification_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: ec_type_modification_bool_exp
  ): [ec_type_modification!]!
}
