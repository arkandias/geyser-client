schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""
whether this query should be cached (Hasura Cloud only)
"""
directive @cached(
  """
  refresh the cache entry
  """
  refresh: Boolean! = false

  """
  measured in seconds
  """
  ttl: Int! = 60
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Float". All fields are combined with logical 'AND'.
"""
input Float_comparison_exp {
  _eq: Float
  _gt: Float
  _gte: Float
  _in: [Float!]
  _is_null: Boolean
  _lt: Float
  _lte: Float
  _neq: Float
  _nin: [Float!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """
  does the column match the given case-insensitive pattern
  """
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """
  does the column match the given pattern
  """
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """
  does the column NOT match the given case-insensitive pattern
  """
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """
  does the column NOT match the given pattern
  """
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """
  does the column NOT match the given SQL regular expression
  """
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """
  does the column match the given SQL regular expression
  """
  _similar: String
}

"""
Table contenant les différentes années.
"""
type annee {
  """
  Indique si l'année correspondante est l'année en cours (TRUE) ou non (NULL). Une seule année peut être en cours à la fois.
  """
  en_cours: Boolean

  """
  An array relationship
  """
  enseignements(
    """
    distinct select on columns
    """
    distinct_on: [enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [enseignement_order_by!]

    """
    filter the rows returned
    """
    where: enseignement_bool_exp
  ): [enseignement!]!

  """
  An aggregate relationship
  """
  enseignements_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [enseignement_order_by!]

    """
    filter the rows returned
    """
    where: enseignement_bool_exp
  ): enseignement_aggregate!

  """
  An array relationship
  """
  services(
    """
    distinct select on columns
    """
    distinct_on: [service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [service_order_by!]

    """
    filter the rows returned
    """
    where: service_bool_exp
  ): [service!]!

  """
  An aggregate relationship
  """
  services_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [service_order_by!]

    """
    filter the rows returned
    """
    where: service_bool_exp
  ): service_aggregate!

  """
  Le numéro de l'année (unique).
  """
  value: Int!

  """
  Indique si l'année correspondante est visible par les utilisateurs.
  """
  visible: Boolean!
}

"""
aggregated selection of "annee"
"""
type annee_aggregate {
  aggregate: annee_aggregate_fields
  nodes: [annee!]!
}

"""
aggregate fields of "annee"
"""
type annee_aggregate_fields {
  avg: annee_avg_fields
  count(columns: [annee_select_column!], distinct: Boolean): Int!
  max: annee_max_fields
  min: annee_min_fields
  stddev: annee_stddev_fields
  stddev_pop: annee_stddev_pop_fields
  stddev_samp: annee_stddev_samp_fields
  sum: annee_sum_fields
  var_pop: annee_var_pop_fields
  var_samp: annee_var_samp_fields
  variance: annee_variance_fields
}

"""
aggregate avg on columns
"""
type annee_avg_fields {
  """
  Le numéro de l'année (unique).
  """
  value: Float
}

"""
Boolean expression to filter rows from the table "annee". All fields are combined with a logical 'AND'.
"""
input annee_bool_exp {
  _and: [annee_bool_exp!]
  _not: annee_bool_exp
  _or: [annee_bool_exp!]
  en_cours: Boolean_comparison_exp
  enseignements: enseignement_bool_exp
  enseignements_aggregate: enseignement_aggregate_bool_exp
  services: service_bool_exp
  services_aggregate: service_aggregate_bool_exp
  value: Int_comparison_exp
  visible: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "annee"
"""
enum annee_constraint {
  """
  unique or primary key constraint on columns "en_cours"
  """
  annee_en_cours_key

  """
  unique or primary key constraint on columns "value"
  """
  annee_pkey
}

"""
input type for incrementing numeric columns in table "annee"
"""
input annee_inc_input {
  """
  Le numéro de l'année (unique).
  """
  value: Int
}

"""
input type for inserting data into table "annee"
"""
input annee_insert_input {
  """
  Indique si l'année correspondante est l'année en cours (TRUE) ou non (NULL). Une seule année peut être en cours à la fois.
  """
  en_cours: Boolean
  enseignements: enseignement_arr_rel_insert_input
  services: service_arr_rel_insert_input

  """
  Le numéro de l'année (unique).
  """
  value: Int

  """
  Indique si l'année correspondante est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate max on columns
"""
type annee_max_fields {
  """
  Le numéro de l'année (unique).
  """
  value: Int
}

"""
aggregate min on columns
"""
type annee_min_fields {
  """
  Le numéro de l'année (unique).
  """
  value: Int
}

"""
response of any mutation on the table "annee"
"""
type annee_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [annee!]!
}

"""
input type for inserting object relation for remote table "annee"
"""
input annee_obj_rel_insert_input {
  data: annee_insert_input!

  """
  upsert condition
  """
  on_conflict: annee_on_conflict
}

"""
on_conflict condition type for table "annee"
"""
input annee_on_conflict {
  constraint: annee_constraint!
  update_columns: [annee_update_column!]! = []
  where: annee_bool_exp
}

"""
Ordering options when selecting data from "annee".
"""
input annee_order_by {
  en_cours: order_by
  enseignements_aggregate: enseignement_aggregate_order_by
  services_aggregate: service_aggregate_order_by
  value: order_by
  visible: order_by
}

"""
primary key columns input for table: annee
"""
input annee_pk_columns_input {
  """
  Le numéro de l'année (unique).
  """
  value: Int!
}

"""
select columns of table "annee"
"""
enum annee_select_column {
  """
  column name
  """
  en_cours

  """
  column name
  """
  value

  """
  column name
  """
  visible
}

"""
input type for updating data in table "annee"
"""
input annee_set_input {
  """
  Indique si l'année correspondante est l'année en cours (TRUE) ou non (NULL). Une seule année peut être en cours à la fois.
  """
  en_cours: Boolean

  """
  Le numéro de l'année (unique).
  """
  value: Int

  """
  Indique si l'année correspondante est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate stddev on columns
"""
type annee_stddev_fields {
  """
  Le numéro de l'année (unique).
  """
  value: Float
}

"""
aggregate stddev_pop on columns
"""
type annee_stddev_pop_fields {
  """
  Le numéro de l'année (unique).
  """
  value: Float
}

"""
aggregate stddev_samp on columns
"""
type annee_stddev_samp_fields {
  """
  Le numéro de l'année (unique).
  """
  value: Float
}

"""
Streaming cursor of the table "annee"
"""
input annee_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: annee_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input annee_stream_cursor_value_input {
  """
  Indique si l'année correspondante est l'année en cours (TRUE) ou non (NULL). Une seule année peut être en cours à la fois.
  """
  en_cours: Boolean

  """
  Le numéro de l'année (unique).
  """
  value: Int

  """
  Indique si l'année correspondante est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate sum on columns
"""
type annee_sum_fields {
  """
  Le numéro de l'année (unique).
  """
  value: Int
}

"""
update columns of table "annee"
"""
enum annee_update_column {
  """
  column name
  """
  en_cours

  """
  column name
  """
  value

  """
  column name
  """
  visible
}

input annee_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: annee_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: annee_set_input

  """
  filter the rows which have to be updated
  """
  where: annee_bool_exp!
}

"""
aggregate var_pop on columns
"""
type annee_var_pop_fields {
  """
  Le numéro de l'année (unique).
  """
  value: Float
}

"""
aggregate var_samp on columns
"""
type annee_var_samp_fields {
  """
  Le numéro de l'année (unique).
  """
  value: Float
}

"""
aggregate variance on columns
"""
type annee_variance_fields {
  """
  Le numéro de l'année (unique).
  """
  value: Float
}

"""
ordering argument of a cursor
"""
enum cursor_ordering {
  """
  ascending ordering of the cursor
  """
  ASC

  """
  descending ordering of the cursor
  """
  DESC
}

"""
Table contenant les différents cursus (licence, master, etc.).
"""
type cursus {
  """
  L'identifiant unique du cursus.
  """
  id: Int!

  """
  An array relationship
  """
  mentions(
    """
    distinct select on columns
    """
    distinct_on: [mention_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [mention_order_by!]

    """
    filter the rows returned
    """
    where: mention_bool_exp
  ): [mention!]!

  """
  An aggregate relationship
  """
  mentions_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [mention_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [mention_order_by!]

    """
    filter the rows returned
    """
    where: mention_bool_exp
  ): mention_aggregate!

  """
  Le nom du cursus (unique).
  """
  nom: String!

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String

  """
  Indique si le cursus correspondant est visible par les utilisateurs.
  """
  visible: Boolean!
}

"""
aggregated selection of "cursus"
"""
type cursus_aggregate {
  aggregate: cursus_aggregate_fields
  nodes: [cursus!]!
}

"""
aggregate fields of "cursus"
"""
type cursus_aggregate_fields {
  avg: cursus_avg_fields
  count(columns: [cursus_select_column!], distinct: Boolean): Int!
  max: cursus_max_fields
  min: cursus_min_fields
  stddev: cursus_stddev_fields
  stddev_pop: cursus_stddev_pop_fields
  stddev_samp: cursus_stddev_samp_fields
  sum: cursus_sum_fields
  var_pop: cursus_var_pop_fields
  var_samp: cursus_var_samp_fields
  variance: cursus_variance_fields
}

"""
aggregate avg on columns
"""
type cursus_avg_fields {
  """
  L'identifiant unique du cursus.
  """
  id: Float
}

"""
Boolean expression to filter rows from the table "cursus". All fields are combined with a logical 'AND'.
"""
input cursus_bool_exp {
  _and: [cursus_bool_exp!]
  _not: cursus_bool_exp
  _or: [cursus_bool_exp!]
  id: Int_comparison_exp
  mentions: mention_bool_exp
  mentions_aggregate: mention_aggregate_bool_exp
  nom: String_comparison_exp
  nom_court: String_comparison_exp
  visible: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "cursus"
"""
enum cursus_constraint {
  """
  unique or primary key constraint on columns "nom"
  """
  cursus_nom_key

  """
  unique or primary key constraint on columns "id"
  """
  cursus_pkey
}

"""
input type for incrementing numeric columns in table "cursus"
"""
input cursus_inc_input {
  """
  L'identifiant unique du cursus.
  """
  id: Int
}

"""
input type for inserting data into table "cursus"
"""
input cursus_insert_input {
  """
  L'identifiant unique du cursus.
  """
  id: Int
  mentions: mention_arr_rel_insert_input

  """
  Le nom du cursus (unique).
  """
  nom: String

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String

  """
  Indique si le cursus correspondant est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate max on columns
"""
type cursus_max_fields {
  """
  L'identifiant unique du cursus.
  """
  id: Int

  """
  Le nom du cursus (unique).
  """
  nom: String

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String
}

"""
aggregate min on columns
"""
type cursus_min_fields {
  """
  L'identifiant unique du cursus.
  """
  id: Int

  """
  Le nom du cursus (unique).
  """
  nom: String

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String
}

"""
response of any mutation on the table "cursus"
"""
type cursus_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [cursus!]!
}

"""
input type for inserting object relation for remote table "cursus"
"""
input cursus_obj_rel_insert_input {
  data: cursus_insert_input!

  """
  upsert condition
  """
  on_conflict: cursus_on_conflict
}

"""
on_conflict condition type for table "cursus"
"""
input cursus_on_conflict {
  constraint: cursus_constraint!
  update_columns: [cursus_update_column!]! = []
  where: cursus_bool_exp
}

"""
Ordering options when selecting data from "cursus".
"""
input cursus_order_by {
  id: order_by
  mentions_aggregate: mention_aggregate_order_by
  nom: order_by
  nom_court: order_by
  visible: order_by
}

"""
primary key columns input for table: cursus
"""
input cursus_pk_columns_input {
  """
  L'identifiant unique du cursus.
  """
  id: Int!
}

"""
select columns of table "cursus"
"""
enum cursus_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  nom

  """
  column name
  """
  nom_court

  """
  column name
  """
  visible
}

"""
input type for updating data in table "cursus"
"""
input cursus_set_input {
  """
  L'identifiant unique du cursus.
  """
  id: Int

  """
  Le nom du cursus (unique).
  """
  nom: String

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String

  """
  Indique si le cursus correspondant est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate stddev on columns
"""
type cursus_stddev_fields {
  """
  L'identifiant unique du cursus.
  """
  id: Float
}

"""
aggregate stddev_pop on columns
"""
type cursus_stddev_pop_fields {
  """
  L'identifiant unique du cursus.
  """
  id: Float
}

"""
aggregate stddev_samp on columns
"""
type cursus_stddev_samp_fields {
  """
  L'identifiant unique du cursus.
  """
  id: Float
}

"""
Streaming cursor of the table "cursus"
"""
input cursus_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: cursus_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input cursus_stream_cursor_value_input {
  """
  L'identifiant unique du cursus.
  """
  id: Int

  """
  Le nom du cursus (unique).
  """
  nom: String

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String

  """
  Indique si le cursus correspondant est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate sum on columns
"""
type cursus_sum_fields {
  """
  L'identifiant unique du cursus.
  """
  id: Int
}

"""
update columns of table "cursus"
"""
enum cursus_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  nom

  """
  column name
  """
  nom_court

  """
  column name
  """
  visible
}

input cursus_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: cursus_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: cursus_set_input

  """
  filter the rows which have to be updated
  """
  where: cursus_bool_exp!
}

"""
aggregate var_pop on columns
"""
type cursus_var_pop_fields {
  """
  L'identifiant unique du cursus.
  """
  id: Float
}

"""
aggregate var_samp on columns
"""
type cursus_var_samp_fields {
  """
  L'identifiant unique du cursus.
  """
  id: Float
}

"""
aggregate variance on columns
"""
type cursus_variance_fields {
  """
  L'identifiant unique du cursus.
  """
  id: Float
}

"""
Table contenant les demandes.
"""
type demande {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: Int!

  """
  An object relationship
  """
  enseignement: enseignement!

  """
  Le nombre d'heures demandées.
  """
  heures: Float!

  """
  Fonction qui renvoie, pour une demande donnée, le nombre d'heures EQTD correspondant en utilisant le coefficient multiplicateur du type d'enseignement correspondant.
  """
  heures_eqtd: Float
  id: Int!

  """
  Fonction qui indique, pour une demande donnée, si celle-ci est prioritaire.
  """
  prioritaire: Boolean

  """
  An object relationship
  """
  service: service!
  service_id: Int!

  """
  Le type de demande.
  """
  type: String!

  """
  An object relationship
  """
  typeByType: type_demande!
}

"""
aggregated selection of "demande"
"""
type demande_aggregate {
  aggregate: demande_aggregate_fields
  nodes: [demande!]!
}

input demande_aggregate_bool_exp {
  count: demande_aggregate_bool_exp_count
}

input demande_aggregate_bool_exp_count {
  arguments: [demande_select_column!]
  distinct: Boolean
  filter: demande_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "demande"
"""
type demande_aggregate_fields {
  avg: demande_avg_fields
  count(columns: [demande_select_column!], distinct: Boolean): Int!
  max: demande_max_fields
  min: demande_min_fields
  stddev: demande_stddev_fields
  stddev_pop: demande_stddev_pop_fields
  stddev_samp: demande_stddev_samp_fields
  sum: demande_sum_fields
  var_pop: demande_var_pop_fields
  var_samp: demande_var_samp_fields
  variance: demande_variance_fields
}

"""
order by aggregate values of table "demande"
"""
input demande_aggregate_order_by {
  avg: demande_avg_order_by
  count: order_by
  max: demande_max_order_by
  min: demande_min_order_by
  stddev: demande_stddev_order_by
  stddev_pop: demande_stddev_pop_order_by
  stddev_samp: demande_stddev_samp_order_by
  sum: demande_sum_order_by
  var_pop: demande_var_pop_order_by
  var_samp: demande_var_samp_order_by
  variance: demande_variance_order_by
}

"""
input type for inserting array relation for remote table "demande"
"""
input demande_arr_rel_insert_input {
  data: [demande_insert_input!]!

  """
  upsert condition
  """
  on_conflict: demande_on_conflict
}

"""
aggregate avg on columns
"""
type demande_avg_fields {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: Float

  """
  Le nombre d'heures demandées.
  """
  heures: Float

  """
  Fonction qui renvoie, pour une demande donnée, le nombre d'heures EQTD correspondant en utilisant le coefficient multiplicateur du type d'enseignement correspondant.
  """
  heures_eqtd: Float
  id: Float
  service_id: Float
}

"""
order by avg() on columns of table "demande"
"""
input demande_avg_order_by {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: order_by

  """
  Le nombre d'heures demandées.
  """
  heures: order_by
  id: order_by
  service_id: order_by
}

"""
Boolean expression to filter rows from the table "demande". All fields are combined with a logical 'AND'.
"""
input demande_bool_exp {
  _and: [demande_bool_exp!]
  _not: demande_bool_exp
  _or: [demande_bool_exp!]
  ens_id: Int_comparison_exp
  enseignement: enseignement_bool_exp
  heures: Float_comparison_exp
  heures_eqtd: Float_comparison_exp
  id: Int_comparison_exp
  prioritaire: Boolean_comparison_exp
  service: service_bool_exp
  service_id: Int_comparison_exp
  type: String_comparison_exp
  typeByType: type_demande_bool_exp
}

"""
unique or primary key constraints on table "demande"
"""
enum demande_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  demande_pkey

  """
  unique or primary key constraint on columns "type", "ens_id", "service_id"
  """
  demande_service_id_ens_id_type_key
}

"""
input type for incrementing numeric columns in table "demande"
"""
input demande_inc_input {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: Int

  """
  Le nombre d'heures demandées.
  """
  heures: Float
  id: Int
  service_id: Int
}

"""
input type for inserting data into table "demande"
"""
input demande_insert_input {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: Int
  enseignement: enseignement_obj_rel_insert_input

  """
  Le nombre d'heures demandées.
  """
  heures: Float
  id: Int
  service: service_obj_rel_insert_input
  service_id: Int

  """
  Le type de demande.
  """
  type: String
  typeByType: type_demande_obj_rel_insert_input
}

"""
aggregate max on columns
"""
type demande_max_fields {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: Int

  """
  Le nombre d'heures demandées.
  """
  heures: Float

  """
  Fonction qui renvoie, pour une demande donnée, le nombre d'heures EQTD correspondant en utilisant le coefficient multiplicateur du type d'enseignement correspondant.
  """
  heures_eqtd: Float
  id: Int
  service_id: Int

  """
  Le type de demande.
  """
  type: String
}

"""
order by max() on columns of table "demande"
"""
input demande_max_order_by {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: order_by

  """
  Le nombre d'heures demandées.
  """
  heures: order_by
  id: order_by
  service_id: order_by

  """
  Le type de demande.
  """
  type: order_by
}

"""
aggregate min on columns
"""
type demande_min_fields {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: Int

  """
  Le nombre d'heures demandées.
  """
  heures: Float

  """
  Fonction qui renvoie, pour une demande donnée, le nombre d'heures EQTD correspondant en utilisant le coefficient multiplicateur du type d'enseignement correspondant.
  """
  heures_eqtd: Float
  id: Int
  service_id: Int

  """
  Le type de demande.
  """
  type: String
}

"""
order by min() on columns of table "demande"
"""
input demande_min_order_by {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: order_by

  """
  Le nombre d'heures demandées.
  """
  heures: order_by
  id: order_by
  service_id: order_by

  """
  Le type de demande.
  """
  type: order_by
}

"""
response of any mutation on the table "demande"
"""
type demande_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [demande!]!
}

"""
on_conflict condition type for table "demande"
"""
input demande_on_conflict {
  constraint: demande_constraint!
  update_columns: [demande_update_column!]! = []
  where: demande_bool_exp
}

"""
Ordering options when selecting data from "demande".
"""
input demande_order_by {
  ens_id: order_by
  enseignement: enseignement_order_by
  heures: order_by
  heures_eqtd: order_by
  id: order_by
  prioritaire: order_by
  service: service_order_by
  service_id: order_by
  type: order_by
  typeByType: type_demande_order_by
}

"""
primary key columns input for table: demande
"""
input demande_pk_columns_input {
  id: Int!
}

"""
select columns of table "demande"
"""
enum demande_select_column {
  """
  column name
  """
  ens_id

  """
  column name
  """
  heures

  """
  column name
  """
  id

  """
  column name
  """
  service_id

  """
  column name
  """
  type
}

"""
input type for updating data in table "demande"
"""
input demande_set_input {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: Int

  """
  Le nombre d'heures demandées.
  """
  heures: Float
  id: Int
  service_id: Int

  """
  Le type de demande.
  """
  type: String
}

"""
aggregate stddev on columns
"""
type demande_stddev_fields {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: Float

  """
  Le nombre d'heures demandées.
  """
  heures: Float

  """
  Fonction qui renvoie, pour une demande donnée, le nombre d'heures EQTD correspondant en utilisant le coefficient multiplicateur du type d'enseignement correspondant.
  """
  heures_eqtd: Float
  id: Float
  service_id: Float
}

"""
order by stddev() on columns of table "demande"
"""
input demande_stddev_order_by {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: order_by

  """
  Le nombre d'heures demandées.
  """
  heures: order_by
  id: order_by
  service_id: order_by
}

"""
aggregate stddev_pop on columns
"""
type demande_stddev_pop_fields {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: Float

  """
  Le nombre d'heures demandées.
  """
  heures: Float

  """
  Fonction qui renvoie, pour une demande donnée, le nombre d'heures EQTD correspondant en utilisant le coefficient multiplicateur du type d'enseignement correspondant.
  """
  heures_eqtd: Float
  id: Float
  service_id: Float
}

"""
order by stddev_pop() on columns of table "demande"
"""
input demande_stddev_pop_order_by {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: order_by

  """
  Le nombre d'heures demandées.
  """
  heures: order_by
  id: order_by
  service_id: order_by
}

"""
aggregate stddev_samp on columns
"""
type demande_stddev_samp_fields {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: Float

  """
  Le nombre d'heures demandées.
  """
  heures: Float

  """
  Fonction qui renvoie, pour une demande donnée, le nombre d'heures EQTD correspondant en utilisant le coefficient multiplicateur du type d'enseignement correspondant.
  """
  heures_eqtd: Float
  id: Float
  service_id: Float
}

"""
order by stddev_samp() on columns of table "demande"
"""
input demande_stddev_samp_order_by {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: order_by

  """
  Le nombre d'heures demandées.
  """
  heures: order_by
  id: order_by
  service_id: order_by
}

"""
Streaming cursor of the table "demande"
"""
input demande_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: demande_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input demande_stream_cursor_value_input {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: Int

  """
  Le nombre d'heures demandées.
  """
  heures: Float
  id: Int
  service_id: Int

  """
  Le type de demande.
  """
  type: String
}

"""
aggregate sum on columns
"""
type demande_sum_fields {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: Int

  """
  Le nombre d'heures demandées.
  """
  heures: Float

  """
  Fonction qui renvoie, pour une demande donnée, le nombre d'heures EQTD correspondant en utilisant le coefficient multiplicateur du type d'enseignement correspondant.
  """
  heures_eqtd: Float
  id: Int
  service_id: Int
}

"""
order by sum() on columns of table "demande"
"""
input demande_sum_order_by {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: order_by

  """
  Le nombre d'heures demandées.
  """
  heures: order_by
  id: order_by
  service_id: order_by
}

"""
update columns of table "demande"
"""
enum demande_update_column {
  """
  column name
  """
  ens_id

  """
  column name
  """
  heures

  """
  column name
  """
  id

  """
  column name
  """
  service_id

  """
  column name
  """
  type
}

input demande_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: demande_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: demande_set_input

  """
  filter the rows which have to be updated
  """
  where: demande_bool_exp!
}

"""
aggregate var_pop on columns
"""
type demande_var_pop_fields {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: Float

  """
  Le nombre d'heures demandées.
  """
  heures: Float

  """
  Fonction qui renvoie, pour une demande donnée, le nombre d'heures EQTD correspondant en utilisant le coefficient multiplicateur du type d'enseignement correspondant.
  """
  heures_eqtd: Float
  id: Float
  service_id: Float
}

"""
order by var_pop() on columns of table "demande"
"""
input demande_var_pop_order_by {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: order_by

  """
  Le nombre d'heures demandées.
  """
  heures: order_by
  id: order_by
  service_id: order_by
}

"""
aggregate var_samp on columns
"""
type demande_var_samp_fields {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: Float

  """
  Le nombre d'heures demandées.
  """
  heures: Float

  """
  Fonction qui renvoie, pour une demande donnée, le nombre d'heures EQTD correspondant en utilisant le coefficient multiplicateur du type d'enseignement correspondant.
  """
  heures_eqtd: Float
  id: Float
  service_id: Float
}

"""
order by var_samp() on columns of table "demande"
"""
input demande_var_samp_order_by {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: order_by

  """
  Le nombre d'heures demandées.
  """
  heures: order_by
  id: order_by
  service_id: order_by
}

"""
aggregate variance on columns
"""
type demande_variance_fields {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: Float

  """
  Le nombre d'heures demandées.
  """
  heures: Float

  """
  Fonction qui renvoie, pour une demande donnée, le nombre d'heures EQTD correspondant en utilisant le coefficient multiplicateur du type d'enseignement correspondant.
  """
  heures_eqtd: Float
  id: Float
  service_id: Float
}

"""
order by variance() on columns of table "demande"
"""
input demande_variance_order_by {
  """
  L'identifiant de l'enseignement correspondant à la demande.
  """
  ens_id: order_by

  """
  Le nombre d'heures demandées.
  """
  heures: order_by
  id: order_by
  service_id: order_by
}

"""
Table contenant les enseignements.
"""
type enseignement {
  """
  L'année de l'enseignement.
  """
  annee: Int!

  """
  An object relationship
  """
  anneeByAnnee: annee!

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: Int!

  """
  An array relationship
  """
  demandes(
    """
    distinct select on columns
    """
    distinct_on: [demande_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [demande_order_by!]

    """
    filter the rows returned
    """
    where: demande_bool_exp
  ): [demande!]!

  """
  An aggregate relationship
  """
  demandes_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [demande_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [demande_order_by!]

    """
    filter the rows returned
    """
    where: demande_bool_exp
  ): demande_aggregate!

  """
  Une description de l'enseignement.
  """
  description: String

  """
  An array relationship
  """
  enfants(
    """
    distinct select on columns
    """
    distinct_on: [enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [enseignement_order_by!]

    """
    filter the rows returned
    """
    where: enseignement_bool_exp
  ): [enseignement!]!

  """
  An aggregate relationship
  """
  enfants_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [enseignement_order_by!]

    """
    filter the rows returned
    """
    where: enseignement_bool_exp
  ): enseignement_aggregate!
  ens_id_import: String
  formation_id_import: String

  """
  Le nombre de groupes.
  """
  groupes: Int!

  """
  Le nombre de groupes ouverts, et à défaut le nombre de groupes.
  """
  groupes_corriges: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: Int

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: Float!

  """
  Le nombre d'heures d'enseignement ouvertes par groupe, et à défaut le nombre d'heures d'enseignement.
  """
  heures_corrigees: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: Float

  """
  L'identifiant unique de l'enseignement.
  """
  id: Int!

  """
  An object relationship
  """
  mention: mention!

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: Int!

  """
  Le nom de l'enseignement.
  """
  nom: String!

  """
  Le nom abrégé (optionnel)
  """
  nom_court: String
  nom_import: String

  """
  An object relationship
  """
  parcours: parcours

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: Int

  """
  An object relationship
  """
  parent: enseignement

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Int

  """
  An array relationship
  """
  priorites(
    """
    distinct select on columns
    """
    distinct_on: [priorite_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [priorite_order_by!]

    """
    filter the rows returned
    """
    where: priorite_bool_exp
  ): [priorite!]!

  """
  An aggregate relationship
  """
  priorites_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [priorite_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [priorite_order_by!]

    """
    filter the rows returned
    """
    where: priorite_bool_exp
  ): priorite_aggregate!

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: Int

  """
  An array relationship
  """
  responsables(
    """
    distinct select on columns
    """
    distinct_on: [responsable_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [responsable_order_by!]

    """
    filter the rows returned
    """
    where: responsable_bool_exp
  ): [responsable!]!

  """
  An aggregate relationship
  """
  responsables_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [responsable_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [responsable_order_by!]

    """
    filter the rows returned
    """
    where: responsable_bool_exp
  ): responsable_aggregate!

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: Int!

  """
  Le type d'enseignement.
  """
  type: String!

  """
  An object relationship
  """
  typeByType: type_enseignement!

  """
  Indique si l'enseignement correspondant est visible par les utilisateurs.
  """
  visible: Boolean!
}

"""
aggregated selection of "enseignement"
"""
type enseignement_aggregate {
  aggregate: enseignement_aggregate_fields
  nodes: [enseignement!]!
}

input enseignement_aggregate_bool_exp {
  bool_and: enseignement_aggregate_bool_exp_bool_and
  bool_or: enseignement_aggregate_bool_exp_bool_or
  count: enseignement_aggregate_bool_exp_count
}

input enseignement_aggregate_bool_exp_bool_and {
  arguments: enseignement_select_column_enseignement_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: enseignement_bool_exp
  predicate: Boolean_comparison_exp!
}

input enseignement_aggregate_bool_exp_bool_or {
  arguments: enseignement_select_column_enseignement_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: enseignement_bool_exp
  predicate: Boolean_comparison_exp!
}

input enseignement_aggregate_bool_exp_count {
  arguments: [enseignement_select_column!]
  distinct: Boolean
  filter: enseignement_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "enseignement"
"""
type enseignement_aggregate_fields {
  avg: enseignement_avg_fields
  count(columns: [enseignement_select_column!], distinct: Boolean): Int!
  max: enseignement_max_fields
  min: enseignement_min_fields
  stddev: enseignement_stddev_fields
  stddev_pop: enseignement_stddev_pop_fields
  stddev_samp: enseignement_stddev_samp_fields
  sum: enseignement_sum_fields
  var_pop: enseignement_var_pop_fields
  var_samp: enseignement_var_samp_fields
  variance: enseignement_variance_fields
}

"""
order by aggregate values of table "enseignement"
"""
input enseignement_aggregate_order_by {
  avg: enseignement_avg_order_by
  count: order_by
  max: enseignement_max_order_by
  min: enseignement_min_order_by
  stddev: enseignement_stddev_order_by
  stddev_pop: enseignement_stddev_pop_order_by
  stddev_samp: enseignement_stddev_samp_order_by
  sum: enseignement_sum_order_by
  var_pop: enseignement_var_pop_order_by
  var_samp: enseignement_var_samp_order_by
  variance: enseignement_variance_order_by
}

"""
input type for inserting array relation for remote table "enseignement"
"""
input enseignement_arr_rel_insert_input {
  data: [enseignement_insert_input!]!

  """
  upsert condition
  """
  on_conflict: enseignement_on_conflict
}

"""
aggregate avg on columns
"""
type enseignement_avg_fields {
  """
  L'année de l'enseignement.
  """
  annee: Float

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: Float

  """
  Le nombre de groupes.
  """
  groupes: Float

  """
  Le nombre de groupes ouverts, et à défaut le nombre de groupes.
  """
  groupes_corriges: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: Float

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe, et à défaut le nombre d'heures d'enseignement.
  """
  heures_corrigees: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: Float

  """
  L'identifiant unique de l'enseignement.
  """
  id: Float

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: Float

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: Float

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Float

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: Float

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: Float
}

"""
order by avg() on columns of table "enseignement"
"""
input enseignement_avg_order_by {
  """
  L'année de l'enseignement.
  """
  annee: order_by

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: order_by

  """
  Le nombre de groupes.
  """
  groupes: order_by

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: order_by

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: order_by

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: order_by

  """
  L'identifiant unique de l'enseignement.
  """
  id: order_by

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: order_by

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: order_by

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: order_by

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: order_by

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: order_by
}

"""
Boolean expression to filter rows from the table "enseignement". All fields are combined with a logical 'AND'.
"""
input enseignement_bool_exp {
  _and: [enseignement_bool_exp!]
  _not: enseignement_bool_exp
  _or: [enseignement_bool_exp!]
  annee: Int_comparison_exp
  anneeByAnnee: annee_bool_exp
  annee_cycle: Int_comparison_exp
  demandes: demande_bool_exp
  demandes_aggregate: demande_aggregate_bool_exp
  description: String_comparison_exp
  enfants: enseignement_bool_exp
  enfants_aggregate: enseignement_aggregate_bool_exp
  ens_id_import: String_comparison_exp
  formation_id_import: String_comparison_exp
  groupes: Int_comparison_exp
  groupes_corriges: Int_comparison_exp
  groupes_ouverts: Int_comparison_exp
  heures: Float_comparison_exp
  heures_corrigees: Float_comparison_exp
  heures_ouvertes: Float_comparison_exp
  id: Int_comparison_exp
  mention: mention_bool_exp
  mention_id: Int_comparison_exp
  nom: String_comparison_exp
  nom_court: String_comparison_exp
  nom_import: String_comparison_exp
  parcours: parcours_bool_exp
  parcours_id: Int_comparison_exp
  parent: enseignement_bool_exp
  parent_id: Int_comparison_exp
  priorites: priorite_bool_exp
  priorites_aggregate: priorite_aggregate_bool_exp
  regle_priorite: Int_comparison_exp
  responsables: responsable_bool_exp
  responsables_aggregate: responsable_aggregate_bool_exp
  semestre: Int_comparison_exp
  type: String_comparison_exp
  typeByType: type_enseignement_bool_exp
  visible: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "enseignement"
"""
enum enseignement_constraint {
  """
  unique or primary key constraint on columns "mention_id", "type", "nom", "annee", "parcours_id", "semestre"
  """
  enseignement_annee_mention_id_parcours_id_nom_semestre_type_key

  """
  unique or primary key constraint on columns "ens_id_import"
  """
  enseignement_ens_id_import_key

  """
  unique or primary key constraint on columns "id"
  """
  enseignement_pkey
}

"""
input type for incrementing numeric columns in table "enseignement"
"""
input enseignement_inc_input {
  """
  L'année de l'enseignement.
  """
  annee: Int

  """
  Le nombre de groupes.
  """
  groupes: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: Int

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: Float

  """
  L'identifiant unique de l'enseignement.
  """
  id: Int

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: Int

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: Int

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Int

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: Int

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: Int
}

"""
input type for inserting data into table "enseignement"
"""
input enseignement_insert_input {
  """
  L'année de l'enseignement.
  """
  annee: Int
  anneeByAnnee: annee_obj_rel_insert_input
  demandes: demande_arr_rel_insert_input

  """
  Une description de l'enseignement.
  """
  description: String
  enfants: enseignement_arr_rel_insert_input
  ens_id_import: String
  formation_id_import: String

  """
  Le nombre de groupes.
  """
  groupes: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: Int

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: Float

  """
  L'identifiant unique de l'enseignement.
  """
  id: Int
  mention: mention_obj_rel_insert_input

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: Int

  """
  Le nom de l'enseignement.
  """
  nom: String

  """
  Le nom abrégé (optionnel)
  """
  nom_court: String
  nom_import: String
  parcours: parcours_obj_rel_insert_input

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: Int
  parent: enseignement_obj_rel_insert_input

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Int
  priorites: priorite_arr_rel_insert_input

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: Int
  responsables: responsable_arr_rel_insert_input

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: Int

  """
  Le type d'enseignement.
  """
  type: String
  typeByType: type_enseignement_obj_rel_insert_input

  """
  Indique si l'enseignement correspondant est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate max on columns
"""
type enseignement_max_fields {
  """
  L'année de l'enseignement.
  """
  annee: Int

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: Int

  """
  Une description de l'enseignement.
  """
  description: String
  ens_id_import: String
  formation_id_import: String

  """
  Le nombre de groupes.
  """
  groupes: Int

  """
  Le nombre de groupes ouverts, et à défaut le nombre de groupes.
  """
  groupes_corriges: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: Int

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe, et à défaut le nombre d'heures d'enseignement.
  """
  heures_corrigees: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: Float

  """
  L'identifiant unique de l'enseignement.
  """
  id: Int

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: Int

  """
  Le nom de l'enseignement.
  """
  nom: String

  """
  Le nom abrégé (optionnel)
  """
  nom_court: String
  nom_import: String

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: Int

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Int

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: Int

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: Int

  """
  Le type d'enseignement.
  """
  type: String
}

"""
order by max() on columns of table "enseignement"
"""
input enseignement_max_order_by {
  """
  L'année de l'enseignement.
  """
  annee: order_by

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: order_by

  """
  Une description de l'enseignement.
  """
  description: order_by
  ens_id_import: order_by
  formation_id_import: order_by

  """
  Le nombre de groupes.
  """
  groupes: order_by

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: order_by

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: order_by

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: order_by

  """
  L'identifiant unique de l'enseignement.
  """
  id: order_by

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: order_by

  """
  Le nom de l'enseignement.
  """
  nom: order_by

  """
  Le nom abrégé (optionnel)
  """
  nom_court: order_by
  nom_import: order_by

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: order_by

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: order_by

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: order_by

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: order_by

  """
  Le type d'enseignement.
  """
  type: order_by
}

"""
aggregate min on columns
"""
type enseignement_min_fields {
  """
  L'année de l'enseignement.
  """
  annee: Int

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: Int

  """
  Une description de l'enseignement.
  """
  description: String
  ens_id_import: String
  formation_id_import: String

  """
  Le nombre de groupes.
  """
  groupes: Int

  """
  Le nombre de groupes ouverts, et à défaut le nombre de groupes.
  """
  groupes_corriges: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: Int

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe, et à défaut le nombre d'heures d'enseignement.
  """
  heures_corrigees: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: Float

  """
  L'identifiant unique de l'enseignement.
  """
  id: Int

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: Int

  """
  Le nom de l'enseignement.
  """
  nom: String

  """
  Le nom abrégé (optionnel)
  """
  nom_court: String
  nom_import: String

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: Int

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Int

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: Int

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: Int

  """
  Le type d'enseignement.
  """
  type: String
}

"""
order by min() on columns of table "enseignement"
"""
input enseignement_min_order_by {
  """
  L'année de l'enseignement.
  """
  annee: order_by

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: order_by

  """
  Une description de l'enseignement.
  """
  description: order_by
  ens_id_import: order_by
  formation_id_import: order_by

  """
  Le nombre de groupes.
  """
  groupes: order_by

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: order_by

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: order_by

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: order_by

  """
  L'identifiant unique de l'enseignement.
  """
  id: order_by

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: order_by

  """
  Le nom de l'enseignement.
  """
  nom: order_by

  """
  Le nom abrégé (optionnel)
  """
  nom_court: order_by
  nom_import: order_by

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: order_by

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: order_by

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: order_by

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: order_by

  """
  Le type d'enseignement.
  """
  type: order_by
}

"""
response of any mutation on the table "enseignement"
"""
type enseignement_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [enseignement!]!
}

"""
input type for inserting object relation for remote table "enseignement"
"""
input enseignement_obj_rel_insert_input {
  data: enseignement_insert_input!

  """
  upsert condition
  """
  on_conflict: enseignement_on_conflict
}

"""
on_conflict condition type for table "enseignement"
"""
input enseignement_on_conflict {
  constraint: enseignement_constraint!
  update_columns: [enseignement_update_column!]! = []
  where: enseignement_bool_exp
}

"""
Ordering options when selecting data from "enseignement".
"""
input enseignement_order_by {
  annee: order_by
  anneeByAnnee: annee_order_by
  annee_cycle: order_by
  demandes_aggregate: demande_aggregate_order_by
  description: order_by
  enfants_aggregate: enseignement_aggregate_order_by
  ens_id_import: order_by
  formation_id_import: order_by
  groupes: order_by
  groupes_corriges: order_by
  groupes_ouverts: order_by
  heures: order_by
  heures_corrigees: order_by
  heures_ouvertes: order_by
  id: order_by
  mention: mention_order_by
  mention_id: order_by
  nom: order_by
  nom_court: order_by
  nom_import: order_by
  parcours: parcours_order_by
  parcours_id: order_by
  parent: enseignement_order_by
  parent_id: order_by
  priorites_aggregate: priorite_aggregate_order_by
  regle_priorite: order_by
  responsables_aggregate: responsable_aggregate_order_by
  semestre: order_by
  type: order_by
  typeByType: type_enseignement_order_by
  visible: order_by
}

"""
primary key columns input for table: enseignement
"""
input enseignement_pk_columns_input {
  """
  L'identifiant unique de l'enseignement.
  """
  id: Int!
}

"""
select columns of table "enseignement"
"""
enum enseignement_select_column {
  """
  column name
  """
  annee

  """
  column name
  """
  annee_cycle

  """
  column name
  """
  description

  """
  column name
  """
  ens_id_import

  """
  column name
  """
  formation_id_import

  """
  column name
  """
  groupes

  """
  column name
  """
  groupes_ouverts

  """
  column name
  """
  heures

  """
  column name
  """
  heures_ouvertes

  """
  column name
  """
  id

  """
  column name
  """
  mention_id

  """
  column name
  """
  nom

  """
  column name
  """
  nom_court

  """
  column name
  """
  nom_import

  """
  column name
  """
  parcours_id

  """
  column name
  """
  parent_id

  """
  column name
  """
  regle_priorite

  """
  column name
  """
  semestre

  """
  column name
  """
  type

  """
  column name
  """
  visible
}

"""
select "enseignement_aggregate_bool_exp_bool_and_arguments_columns" columns of table "enseignement"
"""
enum enseignement_select_column_enseignement_aggregate_bool_exp_bool_and_arguments_columns {
  """
  column name
  """
  visible
}

"""
select "enseignement_aggregate_bool_exp_bool_or_arguments_columns" columns of table "enseignement"
"""
enum enseignement_select_column_enseignement_aggregate_bool_exp_bool_or_arguments_columns {
  """
  column name
  """
  visible
}

"""
input type for updating data in table "enseignement"
"""
input enseignement_set_input {
  """
  L'année de l'enseignement.
  """
  annee: Int

  """
  Une description de l'enseignement.
  """
  description: String
  ens_id_import: String
  formation_id_import: String

  """
  Le nombre de groupes.
  """
  groupes: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: Int

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: Float

  """
  L'identifiant unique de l'enseignement.
  """
  id: Int

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: Int

  """
  Le nom de l'enseignement.
  """
  nom: String

  """
  Le nom abrégé (optionnel)
  """
  nom_court: String
  nom_import: String

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: Int

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Int

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: Int

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: Int

  """
  Le type d'enseignement.
  """
  type: String

  """
  Indique si l'enseignement correspondant est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate stddev on columns
"""
type enseignement_stddev_fields {
  """
  L'année de l'enseignement.
  """
  annee: Float

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: Float

  """
  Le nombre de groupes.
  """
  groupes: Float

  """
  Le nombre de groupes ouverts, et à défaut le nombre de groupes.
  """
  groupes_corriges: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: Float

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe, et à défaut le nombre d'heures d'enseignement.
  """
  heures_corrigees: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: Float

  """
  L'identifiant unique de l'enseignement.
  """
  id: Float

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: Float

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: Float

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Float

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: Float

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: Float
}

"""
order by stddev() on columns of table "enseignement"
"""
input enseignement_stddev_order_by {
  """
  L'année de l'enseignement.
  """
  annee: order_by

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: order_by

  """
  Le nombre de groupes.
  """
  groupes: order_by

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: order_by

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: order_by

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: order_by

  """
  L'identifiant unique de l'enseignement.
  """
  id: order_by

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: order_by

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: order_by

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: order_by

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: order_by

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: order_by
}

"""
aggregate stddev_pop on columns
"""
type enseignement_stddev_pop_fields {
  """
  L'année de l'enseignement.
  """
  annee: Float

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: Float

  """
  Le nombre de groupes.
  """
  groupes: Float

  """
  Le nombre de groupes ouverts, et à défaut le nombre de groupes.
  """
  groupes_corriges: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: Float

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe, et à défaut le nombre d'heures d'enseignement.
  """
  heures_corrigees: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: Float

  """
  L'identifiant unique de l'enseignement.
  """
  id: Float

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: Float

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: Float

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Float

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: Float

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: Float
}

"""
order by stddev_pop() on columns of table "enseignement"
"""
input enseignement_stddev_pop_order_by {
  """
  L'année de l'enseignement.
  """
  annee: order_by

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: order_by

  """
  Le nombre de groupes.
  """
  groupes: order_by

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: order_by

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: order_by

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: order_by

  """
  L'identifiant unique de l'enseignement.
  """
  id: order_by

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: order_by

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: order_by

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: order_by

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: order_by

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: order_by
}

"""
aggregate stddev_samp on columns
"""
type enseignement_stddev_samp_fields {
  """
  L'année de l'enseignement.
  """
  annee: Float

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: Float

  """
  Le nombre de groupes.
  """
  groupes: Float

  """
  Le nombre de groupes ouverts, et à défaut le nombre de groupes.
  """
  groupes_corriges: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: Float

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe, et à défaut le nombre d'heures d'enseignement.
  """
  heures_corrigees: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: Float

  """
  L'identifiant unique de l'enseignement.
  """
  id: Float

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: Float

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: Float

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Float

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: Float

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: Float
}

"""
order by stddev_samp() on columns of table "enseignement"
"""
input enseignement_stddev_samp_order_by {
  """
  L'année de l'enseignement.
  """
  annee: order_by

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: order_by

  """
  Le nombre de groupes.
  """
  groupes: order_by

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: order_by

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: order_by

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: order_by

  """
  L'identifiant unique de l'enseignement.
  """
  id: order_by

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: order_by

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: order_by

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: order_by

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: order_by

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: order_by
}

"""
Streaming cursor of the table "enseignement"
"""
input enseignement_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: enseignement_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input enseignement_stream_cursor_value_input {
  """
  L'année de l'enseignement.
  """
  annee: Int

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: Int

  """
  Une description de l'enseignement.
  """
  description: String
  ens_id_import: String
  formation_id_import: String

  """
  Le nombre de groupes.
  """
  groupes: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: Int

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: Float

  """
  L'identifiant unique de l'enseignement.
  """
  id: Int

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: Int

  """
  Le nom de l'enseignement.
  """
  nom: String

  """
  Le nom abrégé (optionnel)
  """
  nom_court: String
  nom_import: String

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: Int

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Int

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: Int

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: Int

  """
  Le type d'enseignement.
  """
  type: String

  """
  Indique si l'enseignement correspondant est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate sum on columns
"""
type enseignement_sum_fields {
  """
  L'année de l'enseignement.
  """
  annee: Int

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: Int

  """
  Le nombre de groupes.
  """
  groupes: Int

  """
  Le nombre de groupes ouverts, et à défaut le nombre de groupes.
  """
  groupes_corriges: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: Int

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe, et à défaut le nombre d'heures d'enseignement.
  """
  heures_corrigees: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: Float

  """
  L'identifiant unique de l'enseignement.
  """
  id: Int

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: Int

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: Int

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Int

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: Int

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: Int
}

"""
order by sum() on columns of table "enseignement"
"""
input enseignement_sum_order_by {
  """
  L'année de l'enseignement.
  """
  annee: order_by

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: order_by

  """
  Le nombre de groupes.
  """
  groupes: order_by

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: order_by

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: order_by

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: order_by

  """
  L'identifiant unique de l'enseignement.
  """
  id: order_by

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: order_by

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: order_by

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: order_by

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: order_by

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: order_by
}

"""
update columns of table "enseignement"
"""
enum enseignement_update_column {
  """
  column name
  """
  annee

  """
  column name
  """
  description

  """
  column name
  """
  ens_id_import

  """
  column name
  """
  formation_id_import

  """
  column name
  """
  groupes

  """
  column name
  """
  groupes_ouverts

  """
  column name
  """
  heures

  """
  column name
  """
  heures_ouvertes

  """
  column name
  """
  id

  """
  column name
  """
  mention_id

  """
  column name
  """
  nom

  """
  column name
  """
  nom_court

  """
  column name
  """
  nom_import

  """
  column name
  """
  parcours_id

  """
  column name
  """
  parent_id

  """
  column name
  """
  regle_priorite

  """
  column name
  """
  semestre

  """
  column name
  """
  type

  """
  column name
  """
  visible
}

input enseignement_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: enseignement_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: enseignement_set_input

  """
  filter the rows which have to be updated
  """
  where: enseignement_bool_exp!
}

"""
aggregate var_pop on columns
"""
type enseignement_var_pop_fields {
  """
  L'année de l'enseignement.
  """
  annee: Float

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: Float

  """
  Le nombre de groupes.
  """
  groupes: Float

  """
  Le nombre de groupes ouverts, et à défaut le nombre de groupes.
  """
  groupes_corriges: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: Float

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe, et à défaut le nombre d'heures d'enseignement.
  """
  heures_corrigees: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: Float

  """
  L'identifiant unique de l'enseignement.
  """
  id: Float

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: Float

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: Float

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Float

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: Float

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: Float
}

"""
order by var_pop() on columns of table "enseignement"
"""
input enseignement_var_pop_order_by {
  """
  L'année de l'enseignement.
  """
  annee: order_by

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: order_by

  """
  Le nombre de groupes.
  """
  groupes: order_by

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: order_by

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: order_by

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: order_by

  """
  L'identifiant unique de l'enseignement.
  """
  id: order_by

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: order_by

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: order_by

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: order_by

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: order_by

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: order_by
}

"""
aggregate var_samp on columns
"""
type enseignement_var_samp_fields {
  """
  L'année de l'enseignement.
  """
  annee: Float

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: Float

  """
  Le nombre de groupes.
  """
  groupes: Float

  """
  Le nombre de groupes ouverts, et à défaut le nombre de groupes.
  """
  groupes_corriges: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: Float

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe, et à défaut le nombre d'heures d'enseignement.
  """
  heures_corrigees: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: Float

  """
  L'identifiant unique de l'enseignement.
  """
  id: Float

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: Float

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: Float

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Float

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: Float

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: Float
}

"""
order by var_samp() on columns of table "enseignement"
"""
input enseignement_var_samp_order_by {
  """
  L'année de l'enseignement.
  """
  annee: order_by

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: order_by

  """
  Le nombre de groupes.
  """
  groupes: order_by

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: order_by

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: order_by

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: order_by

  """
  L'identifiant unique de l'enseignement.
  """
  id: order_by

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: order_by

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: order_by

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: order_by

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: order_by

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: order_by
}

"""
aggregate variance on columns
"""
type enseignement_variance_fields {
  """
  L'année de l'enseignement.
  """
  annee: Float

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: Float

  """
  Le nombre de groupes.
  """
  groupes: Float

  """
  Le nombre de groupes ouverts, et à défaut le nombre de groupes.
  """
  groupes_corriges: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: Float

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe, et à défaut le nombre d'heures d'enseignement.
  """
  heures_corrigees: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: Float

  """
  L'identifiant unique de l'enseignement.
  """
  id: Float

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: Float

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: Float

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: Float

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: Float

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: Float
}

"""
order by variance() on columns of table "enseignement"
"""
input enseignement_variance_order_by {
  """
  L'année de l'enseignement.
  """
  annee: order_by

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  annee_cycle: order_by

  """
  Le nombre de groupes.
  """
  groupes: order_by

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupes_ouverts: order_by

  """
  Le nombre d'heures d'enseignement par groupe.
  """
  heures: order_by

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  heures_ouvertes: order_by

  """
  L'identifiant unique de l'enseignement.
  """
  id: order_by

  """
  L'identifiant de la mention de l'enseignement.
  """
  mention_id: order_by

  """
  L'identifiant du parcours de l'enseignement.
  """
  parcours_id: order_by

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parent_id: order_by

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  regle_priorite: order_by

  """
  Le semestre durant lequel l'enseignement a lieu.
  """
  semestre: order_by
}

"""
Table contenant les intervenants.
"""
type intervenant {
  """
  Indique si l'intervenant correspondant est actif, c'est-à-dire s'il intervient dans l'année en cours.
  """
  actif: Boolean!

  """
  Un alias pour l'intervenant (optionnel).
  """
  alias: String

  """
  Le nom de l'intervenant.
  """
  nom: String!

  """
  Le prénom de l'intervenant.
  """
  prenom: String!

  """
  An array relationship
  """
  priorites(
    """
    distinct select on columns
    """
    distinct_on: [priorite_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [priorite_order_by!]

    """
    filter the rows returned
    """
    where: priorite_bool_exp
  ): [priorite!]!

  """
  An aggregate relationship
  """
  priorites_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [priorite_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [priorite_order_by!]

    """
    filter the rows returned
    """
    where: priorite_bool_exp
  ): priorite_aggregate!

  """
  An array relationship
  """
  responsables(
    """
    distinct select on columns
    """
    distinct_on: [responsable_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [responsable_order_by!]

    """
    filter the rows returned
    """
    where: responsable_bool_exp
  ): [responsable!]!

  """
  An aggregate relationship
  """
  responsables_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [responsable_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [responsable_order_by!]

    """
    filter the rows returned
    """
    where: responsable_bool_exp
  ): responsable_aggregate!

  """
  Le service de base en heures EQTD de l'intervenant (optionnel).
  """
  service: Float

  """
  An array relationship
  """
  services(
    """
    distinct select on columns
    """
    distinct_on: [service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [service_order_by!]

    """
    filter the rows returned
    """
    where: service_bool_exp
  ): [service!]!

  """
  An aggregate relationship
  """
  services_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [service_order_by!]

    """
    filter the rows returned
    """
    where: service_bool_exp
  ): service_aggregate!

  """
  L'identifiant unique de l'intervenant.
  """
  uid: String!

  """
  Indique si l'intervenant correspondant est visible par les utilisateurs.
  """
  visible: Boolean!
}

"""
aggregated selection of "intervenant"
"""
type intervenant_aggregate {
  aggregate: intervenant_aggregate_fields
  nodes: [intervenant!]!
}

"""
aggregate fields of "intervenant"
"""
type intervenant_aggregate_fields {
  avg: intervenant_avg_fields
  count(columns: [intervenant_select_column!], distinct: Boolean): Int!
  max: intervenant_max_fields
  min: intervenant_min_fields
  stddev: intervenant_stddev_fields
  stddev_pop: intervenant_stddev_pop_fields
  stddev_samp: intervenant_stddev_samp_fields
  sum: intervenant_sum_fields
  var_pop: intervenant_var_pop_fields
  var_samp: intervenant_var_samp_fields
  variance: intervenant_variance_fields
}

"""
aggregate avg on columns
"""
type intervenant_avg_fields {
  """
  Le service de base en heures EQTD de l'intervenant (optionnel).
  """
  service: Float
}

"""
Boolean expression to filter rows from the table "intervenant". All fields are combined with a logical 'AND'.
"""
input intervenant_bool_exp {
  _and: [intervenant_bool_exp!]
  _not: intervenant_bool_exp
  _or: [intervenant_bool_exp!]
  actif: Boolean_comparison_exp
  alias: String_comparison_exp
  nom: String_comparison_exp
  prenom: String_comparison_exp
  priorites: priorite_bool_exp
  priorites_aggregate: priorite_aggregate_bool_exp
  responsables: responsable_bool_exp
  responsables_aggregate: responsable_aggregate_bool_exp
  service: Float_comparison_exp
  services: service_bool_exp
  services_aggregate: service_aggregate_bool_exp
  uid: String_comparison_exp
  visible: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "intervenant"
"""
enum intervenant_constraint {
  """
  unique or primary key constraint on columns "uid"
  """
  intervenant_pkey
}

"""
input type for incrementing numeric columns in table "intervenant"
"""
input intervenant_inc_input {
  """
  Le service de base en heures EQTD de l'intervenant (optionnel).
  """
  service: Float
}

"""
input type for inserting data into table "intervenant"
"""
input intervenant_insert_input {
  """
  Indique si l'intervenant correspondant est actif, c'est-à-dire s'il intervient dans l'année en cours.
  """
  actif: Boolean

  """
  Un alias pour l'intervenant (optionnel).
  """
  alias: String

  """
  Le nom de l'intervenant.
  """
  nom: String

  """
  Le prénom de l'intervenant.
  """
  prenom: String
  priorites: priorite_arr_rel_insert_input
  responsables: responsable_arr_rel_insert_input

  """
  Le service de base en heures EQTD de l'intervenant (optionnel).
  """
  service: Float
  services: service_arr_rel_insert_input

  """
  L'identifiant unique de l'intervenant.
  """
  uid: String

  """
  Indique si l'intervenant correspondant est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate max on columns
"""
type intervenant_max_fields {
  """
  Un alias pour l'intervenant (optionnel).
  """
  alias: String

  """
  Le nom de l'intervenant.
  """
  nom: String

  """
  Le prénom de l'intervenant.
  """
  prenom: String

  """
  Le service de base en heures EQTD de l'intervenant (optionnel).
  """
  service: Float

  """
  L'identifiant unique de l'intervenant.
  """
  uid: String
}

"""
aggregate min on columns
"""
type intervenant_min_fields {
  """
  Un alias pour l'intervenant (optionnel).
  """
  alias: String

  """
  Le nom de l'intervenant.
  """
  nom: String

  """
  Le prénom de l'intervenant.
  """
  prenom: String

  """
  Le service de base en heures EQTD de l'intervenant (optionnel).
  """
  service: Float

  """
  L'identifiant unique de l'intervenant.
  """
  uid: String
}

"""
response of any mutation on the table "intervenant"
"""
type intervenant_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [intervenant!]!
}

"""
input type for inserting object relation for remote table "intervenant"
"""
input intervenant_obj_rel_insert_input {
  data: intervenant_insert_input!

  """
  upsert condition
  """
  on_conflict: intervenant_on_conflict
}

"""
on_conflict condition type for table "intervenant"
"""
input intervenant_on_conflict {
  constraint: intervenant_constraint!
  update_columns: [intervenant_update_column!]! = []
  where: intervenant_bool_exp
}

"""
Ordering options when selecting data from "intervenant".
"""
input intervenant_order_by {
  actif: order_by
  alias: order_by
  nom: order_by
  prenom: order_by
  priorites_aggregate: priorite_aggregate_order_by
  responsables_aggregate: responsable_aggregate_order_by
  service: order_by
  services_aggregate: service_aggregate_order_by
  uid: order_by
  visible: order_by
}

"""
primary key columns input for table: intervenant
"""
input intervenant_pk_columns_input {
  """
  L'identifiant unique de l'intervenant.
  """
  uid: String!
}

"""
select columns of table "intervenant"
"""
enum intervenant_select_column {
  """
  column name
  """
  actif

  """
  column name
  """
  alias

  """
  column name
  """
  nom

  """
  column name
  """
  prenom

  """
  column name
  """
  service

  """
  column name
  """
  uid

  """
  column name
  """
  visible
}

"""
input type for updating data in table "intervenant"
"""
input intervenant_set_input {
  """
  Indique si l'intervenant correspondant est actif, c'est-à-dire s'il intervient dans l'année en cours.
  """
  actif: Boolean

  """
  Un alias pour l'intervenant (optionnel).
  """
  alias: String

  """
  Le nom de l'intervenant.
  """
  nom: String

  """
  Le prénom de l'intervenant.
  """
  prenom: String

  """
  Le service de base en heures EQTD de l'intervenant (optionnel).
  """
  service: Float

  """
  L'identifiant unique de l'intervenant.
  """
  uid: String

  """
  Indique si l'intervenant correspondant est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate stddev on columns
"""
type intervenant_stddev_fields {
  """
  Le service de base en heures EQTD de l'intervenant (optionnel).
  """
  service: Float
}

"""
aggregate stddev_pop on columns
"""
type intervenant_stddev_pop_fields {
  """
  Le service de base en heures EQTD de l'intervenant (optionnel).
  """
  service: Float
}

"""
aggregate stddev_samp on columns
"""
type intervenant_stddev_samp_fields {
  """
  Le service de base en heures EQTD de l'intervenant (optionnel).
  """
  service: Float
}

"""
Streaming cursor of the table "intervenant"
"""
input intervenant_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: intervenant_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input intervenant_stream_cursor_value_input {
  """
  Indique si l'intervenant correspondant est actif, c'est-à-dire s'il intervient dans l'année en cours.
  """
  actif: Boolean

  """
  Un alias pour l'intervenant (optionnel).
  """
  alias: String

  """
  Le nom de l'intervenant.
  """
  nom: String

  """
  Le prénom de l'intervenant.
  """
  prenom: String

  """
  Le service de base en heures EQTD de l'intervenant (optionnel).
  """
  service: Float

  """
  L'identifiant unique de l'intervenant.
  """
  uid: String

  """
  Indique si l'intervenant correspondant est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate sum on columns
"""
type intervenant_sum_fields {
  """
  Le service de base en heures EQTD de l'intervenant (optionnel).
  """
  service: Float
}

"""
update columns of table "intervenant"
"""
enum intervenant_update_column {
  """
  column name
  """
  actif

  """
  column name
  """
  alias

  """
  column name
  """
  nom

  """
  column name
  """
  prenom

  """
  column name
  """
  service

  """
  column name
  """
  uid

  """
  column name
  """
  visible
}

input intervenant_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: intervenant_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: intervenant_set_input

  """
  filter the rows which have to be updated
  """
  where: intervenant_bool_exp!
}

"""
aggregate var_pop on columns
"""
type intervenant_var_pop_fields {
  """
  Le service de base en heures EQTD de l'intervenant (optionnel).
  """
  service: Float
}

"""
aggregate var_samp on columns
"""
type intervenant_var_samp_fields {
  """
  Le service de base en heures EQTD de l'intervenant (optionnel).
  """
  service: Float
}

"""
aggregate variance on columns
"""
type intervenant_variance_fields {
  """
  Le service de base en heures EQTD de l'intervenant (optionnel).
  """
  service: Float
}

"""
Table contenant les différentes mentions.
"""
type mention {
  """
  An object relationship
  """
  cursus: cursus!
  cursus_id: Int!

  """
  An array relationship
  """
  enseignements(
    """
    distinct select on columns
    """
    distinct_on: [enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [enseignement_order_by!]

    """
    filter the rows returned
    """
    where: enseignement_bool_exp
  ): [enseignement!]!

  """
  An aggregate relationship
  """
  enseignements_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [enseignement_order_by!]

    """
    filter the rows returned
    """
    where: enseignement_bool_exp
  ): enseignement_aggregate!

  """
  L'identifiant unique de la mention.
  """
  id: Int!

  """
  Le nom de la mention (unique).
  """
  nom: String!

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String
  nom_import: String

  """
  An array relationship
  """
  parcours(
    """
    distinct select on columns
    """
    distinct_on: [parcours_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [parcours_order_by!]

    """
    filter the rows returned
    """
    where: parcours_bool_exp
  ): [parcours!]!

  """
  An aggregate relationship
  """
  parcours_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [parcours_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [parcours_order_by!]

    """
    filter the rows returned
    """
    where: parcours_bool_exp
  ): parcours_aggregate!

  """
  An array relationship
  """
  responsables(
    """
    distinct select on columns
    """
    distinct_on: [responsable_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [responsable_order_by!]

    """
    filter the rows returned
    """
    where: responsable_bool_exp
  ): [responsable!]!

  """
  An aggregate relationship
  """
  responsables_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [responsable_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [responsable_order_by!]

    """
    filter the rows returned
    """
    where: responsable_bool_exp
  ): responsable_aggregate!

  """
  Indique si la mention correspondante est visible par les utilisateurs.
  """
  visible: Boolean!
}

"""
aggregated selection of "mention"
"""
type mention_aggregate {
  aggregate: mention_aggregate_fields
  nodes: [mention!]!
}

input mention_aggregate_bool_exp {
  bool_and: mention_aggregate_bool_exp_bool_and
  bool_or: mention_aggregate_bool_exp_bool_or
  count: mention_aggregate_bool_exp_count
}

input mention_aggregate_bool_exp_bool_and {
  arguments: mention_select_column_mention_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: mention_bool_exp
  predicate: Boolean_comparison_exp!
}

input mention_aggregate_bool_exp_bool_or {
  arguments: mention_select_column_mention_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: mention_bool_exp
  predicate: Boolean_comparison_exp!
}

input mention_aggregate_bool_exp_count {
  arguments: [mention_select_column!]
  distinct: Boolean
  filter: mention_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "mention"
"""
type mention_aggregate_fields {
  avg: mention_avg_fields
  count(columns: [mention_select_column!], distinct: Boolean): Int!
  max: mention_max_fields
  min: mention_min_fields
  stddev: mention_stddev_fields
  stddev_pop: mention_stddev_pop_fields
  stddev_samp: mention_stddev_samp_fields
  sum: mention_sum_fields
  var_pop: mention_var_pop_fields
  var_samp: mention_var_samp_fields
  variance: mention_variance_fields
}

"""
order by aggregate values of table "mention"
"""
input mention_aggregate_order_by {
  avg: mention_avg_order_by
  count: order_by
  max: mention_max_order_by
  min: mention_min_order_by
  stddev: mention_stddev_order_by
  stddev_pop: mention_stddev_pop_order_by
  stddev_samp: mention_stddev_samp_order_by
  sum: mention_sum_order_by
  var_pop: mention_var_pop_order_by
  var_samp: mention_var_samp_order_by
  variance: mention_variance_order_by
}

"""
input type for inserting array relation for remote table "mention"
"""
input mention_arr_rel_insert_input {
  data: [mention_insert_input!]!

  """
  upsert condition
  """
  on_conflict: mention_on_conflict
}

"""
aggregate avg on columns
"""
type mention_avg_fields {
  cursus_id: Float

  """
  L'identifiant unique de la mention.
  """
  id: Float
}

"""
order by avg() on columns of table "mention"
"""
input mention_avg_order_by {
  cursus_id: order_by

  """
  L'identifiant unique de la mention.
  """
  id: order_by
}

"""
Boolean expression to filter rows from the table "mention". All fields are combined with a logical 'AND'.
"""
input mention_bool_exp {
  _and: [mention_bool_exp!]
  _not: mention_bool_exp
  _or: [mention_bool_exp!]
  cursus: cursus_bool_exp
  cursus_id: Int_comparison_exp
  enseignements: enseignement_bool_exp
  enseignements_aggregate: enseignement_aggregate_bool_exp
  id: Int_comparison_exp
  nom: String_comparison_exp
  nom_court: String_comparison_exp
  nom_import: String_comparison_exp
  parcours: parcours_bool_exp
  parcours_aggregate: parcours_aggregate_bool_exp
  responsables: responsable_bool_exp
  responsables_aggregate: responsable_aggregate_bool_exp
  visible: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "mention"
"""
enum mention_constraint {
  """
  unique or primary key constraint on columns "nom", "cursus_id"
  """
  mention_cursus_id_nom_key

  """
  unique or primary key constraint on columns "id"
  """
  mention_pkey
}

"""
input type for incrementing numeric columns in table "mention"
"""
input mention_inc_input {
  cursus_id: Int

  """
  L'identifiant unique de la mention.
  """
  id: Int
}

"""
input type for inserting data into table "mention"
"""
input mention_insert_input {
  cursus: cursus_obj_rel_insert_input
  cursus_id: Int
  enseignements: enseignement_arr_rel_insert_input

  """
  L'identifiant unique de la mention.
  """
  id: Int

  """
  Le nom de la mention (unique).
  """
  nom: String

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String
  nom_import: String
  parcours: parcours_arr_rel_insert_input
  responsables: responsable_arr_rel_insert_input

  """
  Indique si la mention correspondante est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate max on columns
"""
type mention_max_fields {
  cursus_id: Int

  """
  L'identifiant unique de la mention.
  """
  id: Int

  """
  Le nom de la mention (unique).
  """
  nom: String

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String
  nom_import: String
}

"""
order by max() on columns of table "mention"
"""
input mention_max_order_by {
  cursus_id: order_by

  """
  L'identifiant unique de la mention.
  """
  id: order_by

  """
  Le nom de la mention (unique).
  """
  nom: order_by

  """
  Le nom abrégé (optionnel).
  """
  nom_court: order_by
  nom_import: order_by
}

"""
aggregate min on columns
"""
type mention_min_fields {
  cursus_id: Int

  """
  L'identifiant unique de la mention.
  """
  id: Int

  """
  Le nom de la mention (unique).
  """
  nom: String

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String
  nom_import: String
}

"""
order by min() on columns of table "mention"
"""
input mention_min_order_by {
  cursus_id: order_by

  """
  L'identifiant unique de la mention.
  """
  id: order_by

  """
  Le nom de la mention (unique).
  """
  nom: order_by

  """
  Le nom abrégé (optionnel).
  """
  nom_court: order_by
  nom_import: order_by
}

"""
response of any mutation on the table "mention"
"""
type mention_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [mention!]!
}

"""
input type for inserting object relation for remote table "mention"
"""
input mention_obj_rel_insert_input {
  data: mention_insert_input!

  """
  upsert condition
  """
  on_conflict: mention_on_conflict
}

"""
on_conflict condition type for table "mention"
"""
input mention_on_conflict {
  constraint: mention_constraint!
  update_columns: [mention_update_column!]! = []
  where: mention_bool_exp
}

"""
Ordering options when selecting data from "mention".
"""
input mention_order_by {
  cursus: cursus_order_by
  cursus_id: order_by
  enseignements_aggregate: enseignement_aggregate_order_by
  id: order_by
  nom: order_by
  nom_court: order_by
  nom_import: order_by
  parcours_aggregate: parcours_aggregate_order_by
  responsables_aggregate: responsable_aggregate_order_by
  visible: order_by
}

"""
primary key columns input for table: mention
"""
input mention_pk_columns_input {
  """
  L'identifiant unique de la mention.
  """
  id: Int!
}

"""
select columns of table "mention"
"""
enum mention_select_column {
  """
  column name
  """
  cursus_id

  """
  column name
  """
  id

  """
  column name
  """
  nom

  """
  column name
  """
  nom_court

  """
  column name
  """
  nom_import

  """
  column name
  """
  visible
}

"""
select "mention_aggregate_bool_exp_bool_and_arguments_columns" columns of table "mention"
"""
enum mention_select_column_mention_aggregate_bool_exp_bool_and_arguments_columns {
  """
  column name
  """
  visible
}

"""
select "mention_aggregate_bool_exp_bool_or_arguments_columns" columns of table "mention"
"""
enum mention_select_column_mention_aggregate_bool_exp_bool_or_arguments_columns {
  """
  column name
  """
  visible
}

"""
input type for updating data in table "mention"
"""
input mention_set_input {
  cursus_id: Int

  """
  L'identifiant unique de la mention.
  """
  id: Int

  """
  Le nom de la mention (unique).
  """
  nom: String

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String
  nom_import: String

  """
  Indique si la mention correspondante est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate stddev on columns
"""
type mention_stddev_fields {
  cursus_id: Float

  """
  L'identifiant unique de la mention.
  """
  id: Float
}

"""
order by stddev() on columns of table "mention"
"""
input mention_stddev_order_by {
  cursus_id: order_by

  """
  L'identifiant unique de la mention.
  """
  id: order_by
}

"""
aggregate stddev_pop on columns
"""
type mention_stddev_pop_fields {
  cursus_id: Float

  """
  L'identifiant unique de la mention.
  """
  id: Float
}

"""
order by stddev_pop() on columns of table "mention"
"""
input mention_stddev_pop_order_by {
  cursus_id: order_by

  """
  L'identifiant unique de la mention.
  """
  id: order_by
}

"""
aggregate stddev_samp on columns
"""
type mention_stddev_samp_fields {
  cursus_id: Float

  """
  L'identifiant unique de la mention.
  """
  id: Float
}

"""
order by stddev_samp() on columns of table "mention"
"""
input mention_stddev_samp_order_by {
  cursus_id: order_by

  """
  L'identifiant unique de la mention.
  """
  id: order_by
}

"""
Streaming cursor of the table "mention"
"""
input mention_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: mention_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input mention_stream_cursor_value_input {
  cursus_id: Int

  """
  L'identifiant unique de la mention.
  """
  id: Int

  """
  Le nom de la mention (unique).
  """
  nom: String

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String
  nom_import: String

  """
  Indique si la mention correspondante est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate sum on columns
"""
type mention_sum_fields {
  cursus_id: Int

  """
  L'identifiant unique de la mention.
  """
  id: Int
}

"""
order by sum() on columns of table "mention"
"""
input mention_sum_order_by {
  cursus_id: order_by

  """
  L'identifiant unique de la mention.
  """
  id: order_by
}

"""
update columns of table "mention"
"""
enum mention_update_column {
  """
  column name
  """
  cursus_id

  """
  column name
  """
  id

  """
  column name
  """
  nom

  """
  column name
  """
  nom_court

  """
  column name
  """
  nom_import

  """
  column name
  """
  visible
}

input mention_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: mention_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: mention_set_input

  """
  filter the rows which have to be updated
  """
  where: mention_bool_exp!
}

"""
aggregate var_pop on columns
"""
type mention_var_pop_fields {
  cursus_id: Float

  """
  L'identifiant unique de la mention.
  """
  id: Float
}

"""
order by var_pop() on columns of table "mention"
"""
input mention_var_pop_order_by {
  cursus_id: order_by

  """
  L'identifiant unique de la mention.
  """
  id: order_by
}

"""
aggregate var_samp on columns
"""
type mention_var_samp_fields {
  cursus_id: Float

  """
  L'identifiant unique de la mention.
  """
  id: Float
}

"""
order by var_samp() on columns of table "mention"
"""
input mention_var_samp_order_by {
  cursus_id: order_by

  """
  L'identifiant unique de la mention.
  """
  id: order_by
}

"""
aggregate variance on columns
"""
type mention_variance_fields {
  cursus_id: Float

  """
  L'identifiant unique de la mention.
  """
  id: Float
}

"""
order by variance() on columns of table "mention"
"""
input mention_variance_order_by {
  cursus_id: order_by

  """
  L'identifiant unique de la mention.
  """
  id: order_by
}

"""
Table contenant les messages enregistrés sur Geyser.
"""
type message {
  """
  Le contenu du message.
  """
  contenu: String!

  """
  L'identifiant unique du message.
  """
  id: Int!

  """
  An object relationship
  """
  service: service!
  service_id: Int!
}

"""
aggregated selection of "message"
"""
type message_aggregate {
  aggregate: message_aggregate_fields
  nodes: [message!]!
}

input message_aggregate_bool_exp {
  count: message_aggregate_bool_exp_count
}

input message_aggregate_bool_exp_count {
  arguments: [message_select_column!]
  distinct: Boolean
  filter: message_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "message"
"""
type message_aggregate_fields {
  avg: message_avg_fields
  count(columns: [message_select_column!], distinct: Boolean): Int!
  max: message_max_fields
  min: message_min_fields
  stddev: message_stddev_fields
  stddev_pop: message_stddev_pop_fields
  stddev_samp: message_stddev_samp_fields
  sum: message_sum_fields
  var_pop: message_var_pop_fields
  var_samp: message_var_samp_fields
  variance: message_variance_fields
}

"""
order by aggregate values of table "message"
"""
input message_aggregate_order_by {
  avg: message_avg_order_by
  count: order_by
  max: message_max_order_by
  min: message_min_order_by
  stddev: message_stddev_order_by
  stddev_pop: message_stddev_pop_order_by
  stddev_samp: message_stddev_samp_order_by
  sum: message_sum_order_by
  var_pop: message_var_pop_order_by
  var_samp: message_var_samp_order_by
  variance: message_variance_order_by
}

"""
input type for inserting array relation for remote table "message"
"""
input message_arr_rel_insert_input {
  data: [message_insert_input!]!

  """
  upsert condition
  """
  on_conflict: message_on_conflict
}

"""
aggregate avg on columns
"""
type message_avg_fields {
  """
  L'identifiant unique du message.
  """
  id: Float
  service_id: Float
}

"""
order by avg() on columns of table "message"
"""
input message_avg_order_by {
  """
  L'identifiant unique du message.
  """
  id: order_by
  service_id: order_by
}

"""
Boolean expression to filter rows from the table "message". All fields are combined with a logical 'AND'.
"""
input message_bool_exp {
  _and: [message_bool_exp!]
  _not: message_bool_exp
  _or: [message_bool_exp!]
  contenu: String_comparison_exp
  id: Int_comparison_exp
  service: service_bool_exp
  service_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "message"
"""
enum message_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  message_pkey

  """
  unique or primary key constraint on columns "service_id"
  """
  message_service_id_key
}

"""
input type for incrementing numeric columns in table "message"
"""
input message_inc_input {
  """
  L'identifiant unique du message.
  """
  id: Int
  service_id: Int
}

"""
input type for inserting data into table "message"
"""
input message_insert_input {
  """
  Le contenu du message.
  """
  contenu: String

  """
  L'identifiant unique du message.
  """
  id: Int
  service: service_obj_rel_insert_input
  service_id: Int
}

"""
aggregate max on columns
"""
type message_max_fields {
  """
  Le contenu du message.
  """
  contenu: String

  """
  L'identifiant unique du message.
  """
  id: Int
  service_id: Int
}

"""
order by max() on columns of table "message"
"""
input message_max_order_by {
  """
  Le contenu du message.
  """
  contenu: order_by

  """
  L'identifiant unique du message.
  """
  id: order_by
  service_id: order_by
}

"""
aggregate min on columns
"""
type message_min_fields {
  """
  Le contenu du message.
  """
  contenu: String

  """
  L'identifiant unique du message.
  """
  id: Int
  service_id: Int
}

"""
order by min() on columns of table "message"
"""
input message_min_order_by {
  """
  Le contenu du message.
  """
  contenu: order_by

  """
  L'identifiant unique du message.
  """
  id: order_by
  service_id: order_by
}

"""
response of any mutation on the table "message"
"""
type message_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [message!]!
}

"""
on_conflict condition type for table "message"
"""
input message_on_conflict {
  constraint: message_constraint!
  update_columns: [message_update_column!]! = []
  where: message_bool_exp
}

"""
Ordering options when selecting data from "message".
"""
input message_order_by {
  contenu: order_by
  id: order_by
  service: service_order_by
  service_id: order_by
}

"""
primary key columns input for table: message
"""
input message_pk_columns_input {
  """
  L'identifiant unique du message.
  """
  id: Int!
}

"""
select columns of table "message"
"""
enum message_select_column {
  """
  column name
  """
  contenu

  """
  column name
  """
  id

  """
  column name
  """
  service_id
}

"""
input type for updating data in table "message"
"""
input message_set_input {
  """
  Le contenu du message.
  """
  contenu: String

  """
  L'identifiant unique du message.
  """
  id: Int
  service_id: Int
}

"""
aggregate stddev on columns
"""
type message_stddev_fields {
  """
  L'identifiant unique du message.
  """
  id: Float
  service_id: Float
}

"""
order by stddev() on columns of table "message"
"""
input message_stddev_order_by {
  """
  L'identifiant unique du message.
  """
  id: order_by
  service_id: order_by
}

"""
aggregate stddev_pop on columns
"""
type message_stddev_pop_fields {
  """
  L'identifiant unique du message.
  """
  id: Float
  service_id: Float
}

"""
order by stddev_pop() on columns of table "message"
"""
input message_stddev_pop_order_by {
  """
  L'identifiant unique du message.
  """
  id: order_by
  service_id: order_by
}

"""
aggregate stddev_samp on columns
"""
type message_stddev_samp_fields {
  """
  L'identifiant unique du message.
  """
  id: Float
  service_id: Float
}

"""
order by stddev_samp() on columns of table "message"
"""
input message_stddev_samp_order_by {
  """
  L'identifiant unique du message.
  """
  id: order_by
  service_id: order_by
}

"""
Streaming cursor of the table "message"
"""
input message_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: message_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input message_stream_cursor_value_input {
  """
  Le contenu du message.
  """
  contenu: String

  """
  L'identifiant unique du message.
  """
  id: Int
  service_id: Int
}

"""
aggregate sum on columns
"""
type message_sum_fields {
  """
  L'identifiant unique du message.
  """
  id: Int
  service_id: Int
}

"""
order by sum() on columns of table "message"
"""
input message_sum_order_by {
  """
  L'identifiant unique du message.
  """
  id: order_by
  service_id: order_by
}

"""
update columns of table "message"
"""
enum message_update_column {
  """
  column name
  """
  contenu

  """
  column name
  """
  id

  """
  column name
  """
  service_id
}

input message_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: message_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: message_set_input

  """
  filter the rows which have to be updated
  """
  where: message_bool_exp!
}

"""
aggregate var_pop on columns
"""
type message_var_pop_fields {
  """
  L'identifiant unique du message.
  """
  id: Float
  service_id: Float
}

"""
order by var_pop() on columns of table "message"
"""
input message_var_pop_order_by {
  """
  L'identifiant unique du message.
  """
  id: order_by
  service_id: order_by
}

"""
aggregate var_samp on columns
"""
type message_var_samp_fields {
  """
  L'identifiant unique du message.
  """
  id: Float
  service_id: Float
}

"""
order by var_samp() on columns of table "message"
"""
input message_var_samp_order_by {
  """
  L'identifiant unique du message.
  """
  id: order_by
  service_id: order_by
}

"""
aggregate variance on columns
"""
type message_variance_fields {
  """
  L'identifiant unique du message.
  """
  id: Float
  service_id: Float
}

"""
order by variance() on columns of table "message"
"""
input message_variance_order_by {
  """
  L'identifiant unique du message.
  """
  id: order_by
  service_id: order_by
}

"""
Table contenant les modifications du service de base d'un intervenant donné pour une année donnée.
"""
type modification_service {
  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: Float!

  """
  L'identifiant unique de la modification.
  """
  id: Int!

  """
  An object relationship
  """
  service: service!
  service_id: Int!

  """
  Le type de modification.
  """
  type: String!

  """
  An object relationship
  """
  typeByType: type_modification!
}

"""
aggregated selection of "modification_service"
"""
type modification_service_aggregate {
  aggregate: modification_service_aggregate_fields
  nodes: [modification_service!]!
}

input modification_service_aggregate_bool_exp {
  count: modification_service_aggregate_bool_exp_count
}

input modification_service_aggregate_bool_exp_count {
  arguments: [modification_service_select_column!]
  distinct: Boolean
  filter: modification_service_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "modification_service"
"""
type modification_service_aggregate_fields {
  avg: modification_service_avg_fields
  count(columns: [modification_service_select_column!], distinct: Boolean): Int!
  max: modification_service_max_fields
  min: modification_service_min_fields
  stddev: modification_service_stddev_fields
  stddev_pop: modification_service_stddev_pop_fields
  stddev_samp: modification_service_stddev_samp_fields
  sum: modification_service_sum_fields
  var_pop: modification_service_var_pop_fields
  var_samp: modification_service_var_samp_fields
  variance: modification_service_variance_fields
}

"""
order by aggregate values of table "modification_service"
"""
input modification_service_aggregate_order_by {
  avg: modification_service_avg_order_by
  count: order_by
  max: modification_service_max_order_by
  min: modification_service_min_order_by
  stddev: modification_service_stddev_order_by
  stddev_pop: modification_service_stddev_pop_order_by
  stddev_samp: modification_service_stddev_samp_order_by
  sum: modification_service_sum_order_by
  var_pop: modification_service_var_pop_order_by
  var_samp: modification_service_var_samp_order_by
  variance: modification_service_variance_order_by
}

"""
input type for inserting array relation for remote table "modification_service"
"""
input modification_service_arr_rel_insert_input {
  data: [modification_service_insert_input!]!

  """
  upsert condition
  """
  on_conflict: modification_service_on_conflict
}

"""
aggregate avg on columns
"""
type modification_service_avg_fields {
  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: Float

  """
  L'identifiant unique de la modification.
  """
  id: Float
  service_id: Float
}

"""
order by avg() on columns of table "modification_service"
"""
input modification_service_avg_order_by {
  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: order_by

  """
  L'identifiant unique de la modification.
  """
  id: order_by
  service_id: order_by
}

"""
Boolean expression to filter rows from the table "modification_service". All fields are combined with a logical 'AND'.
"""
input modification_service_bool_exp {
  _and: [modification_service_bool_exp!]
  _not: modification_service_bool_exp
  _or: [modification_service_bool_exp!]
  heures_eqtd: Float_comparison_exp
  id: Int_comparison_exp
  service: service_bool_exp
  service_id: Int_comparison_exp
  type: String_comparison_exp
  typeByType: type_modification_bool_exp
}

"""
unique or primary key constraints on table "modification_service"
"""
enum modification_service_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  modification_service_pkey
}

"""
input type for incrementing numeric columns in table "modification_service"
"""
input modification_service_inc_input {
  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: Float

  """
  L'identifiant unique de la modification.
  """
  id: Int
  service_id: Int
}

"""
input type for inserting data into table "modification_service"
"""
input modification_service_insert_input {
  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: Float

  """
  L'identifiant unique de la modification.
  """
  id: Int
  service: service_obj_rel_insert_input
  service_id: Int

  """
  Le type de modification.
  """
  type: String
  typeByType: type_modification_obj_rel_insert_input
}

"""
aggregate max on columns
"""
type modification_service_max_fields {
  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: Float

  """
  L'identifiant unique de la modification.
  """
  id: Int
  service_id: Int

  """
  Le type de modification.
  """
  type: String
}

"""
order by max() on columns of table "modification_service"
"""
input modification_service_max_order_by {
  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: order_by

  """
  L'identifiant unique de la modification.
  """
  id: order_by
  service_id: order_by

  """
  Le type de modification.
  """
  type: order_by
}

"""
aggregate min on columns
"""
type modification_service_min_fields {
  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: Float

  """
  L'identifiant unique de la modification.
  """
  id: Int
  service_id: Int

  """
  Le type de modification.
  """
  type: String
}

"""
order by min() on columns of table "modification_service"
"""
input modification_service_min_order_by {
  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: order_by

  """
  L'identifiant unique de la modification.
  """
  id: order_by
  service_id: order_by

  """
  Le type de modification.
  """
  type: order_by
}

"""
response of any mutation on the table "modification_service"
"""
type modification_service_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [modification_service!]!
}

"""
on_conflict condition type for table "modification_service"
"""
input modification_service_on_conflict {
  constraint: modification_service_constraint!
  update_columns: [modification_service_update_column!]! = []
  where: modification_service_bool_exp
}

"""
Ordering options when selecting data from "modification_service".
"""
input modification_service_order_by {
  heures_eqtd: order_by
  id: order_by
  service: service_order_by
  service_id: order_by
  type: order_by
  typeByType: type_modification_order_by
}

"""
primary key columns input for table: modification_service
"""
input modification_service_pk_columns_input {
  """
  L'identifiant unique de la modification.
  """
  id: Int!
}

"""
select columns of table "modification_service"
"""
enum modification_service_select_column {
  """
  column name
  """
  heures_eqtd

  """
  column name
  """
  id

  """
  column name
  """
  service_id

  """
  column name
  """
  type
}

"""
input type for updating data in table "modification_service"
"""
input modification_service_set_input {
  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: Float

  """
  L'identifiant unique de la modification.
  """
  id: Int
  service_id: Int

  """
  Le type de modification.
  """
  type: String
}

"""
aggregate stddev on columns
"""
type modification_service_stddev_fields {
  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: Float

  """
  L'identifiant unique de la modification.
  """
  id: Float
  service_id: Float
}

"""
order by stddev() on columns of table "modification_service"
"""
input modification_service_stddev_order_by {
  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: order_by

  """
  L'identifiant unique de la modification.
  """
  id: order_by
  service_id: order_by
}

"""
aggregate stddev_pop on columns
"""
type modification_service_stddev_pop_fields {
  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: Float

  """
  L'identifiant unique de la modification.
  """
  id: Float
  service_id: Float
}

"""
order by stddev_pop() on columns of table "modification_service"
"""
input modification_service_stddev_pop_order_by {
  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: order_by

  """
  L'identifiant unique de la modification.
  """
  id: order_by
  service_id: order_by
}

"""
aggregate stddev_samp on columns
"""
type modification_service_stddev_samp_fields {
  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: Float

  """
  L'identifiant unique de la modification.
  """
  id: Float
  service_id: Float
}

"""
order by stddev_samp() on columns of table "modification_service"
"""
input modification_service_stddev_samp_order_by {
  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: order_by

  """
  L'identifiant unique de la modification.
  """
  id: order_by
  service_id: order_by
}

"""
Streaming cursor of the table "modification_service"
"""
input modification_service_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: modification_service_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input modification_service_stream_cursor_value_input {
  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: Float

  """
  L'identifiant unique de la modification.
  """
  id: Int
  service_id: Int

  """
  Le type de modification.
  """
  type: String
}

"""
aggregate sum on columns
"""
type modification_service_sum_fields {
  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: Float

  """
  L'identifiant unique de la modification.
  """
  id: Int
  service_id: Int
}

"""
order by sum() on columns of table "modification_service"
"""
input modification_service_sum_order_by {
  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: order_by

  """
  L'identifiant unique de la modification.
  """
  id: order_by
  service_id: order_by
}

"""
update columns of table "modification_service"
"""
enum modification_service_update_column {
  """
  column name
  """
  heures_eqtd

  """
  column name
  """
  id

  """
  column name
  """
  service_id

  """
  column name
  """
  type
}

input modification_service_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: modification_service_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: modification_service_set_input

  """
  filter the rows which have to be updated
  """
  where: modification_service_bool_exp!
}

"""
aggregate var_pop on columns
"""
type modification_service_var_pop_fields {
  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: Float

  """
  L'identifiant unique de la modification.
  """
  id: Float
  service_id: Float
}

"""
order by var_pop() on columns of table "modification_service"
"""
input modification_service_var_pop_order_by {
  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: order_by

  """
  L'identifiant unique de la modification.
  """
  id: order_by
  service_id: order_by
}

"""
aggregate var_samp on columns
"""
type modification_service_var_samp_fields {
  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: Float

  """
  L'identifiant unique de la modification.
  """
  id: Float
  service_id: Float
}

"""
order by var_samp() on columns of table "modification_service"
"""
input modification_service_var_samp_order_by {
  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: order_by

  """
  L'identifiant unique de la modification.
  """
  id: order_by
  service_id: order_by
}

"""
aggregate variance on columns
"""
type modification_service_variance_fields {
  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: Float

  """
  L'identifiant unique de la modification.
  """
  id: Float
  service_id: Float
}

"""
order by variance() on columns of table "modification_service"
"""
input modification_service_variance_order_by {
  """
  Le nombre d'heures EQTD dont le service est diminué (un nombre négatif correspond donc à une augmentation de service).
  """
  heures_eqtd: order_by

  """
  L'identifiant unique de la modification.
  """
  id: order_by
  service_id: order_by
}

"""
mutation root
"""
type mutation_root {
  """
  delete data from the table: "annee"
  """
  delete_annee(
    """
    filter the rows which have to be deleted
    """
    where: annee_bool_exp!
  ): annee_mutation_response

  """
  delete single row from the table: "annee"
  """
  delete_annee_by_pk(
    """
    Le numéro de l'année (unique).
    """
    value: Int!
  ): annee

  """
  delete data from the table: "cursus"
  """
  delete_cursus(
    """
    filter the rows which have to be deleted
    """
    where: cursus_bool_exp!
  ): cursus_mutation_response

  """
  delete single row from the table: "cursus"
  """
  delete_cursus_by_pk(
    """
    L'identifiant unique du cursus.
    """
    id: Int!
  ): cursus

  """
  delete data from the table: "demande"
  """
  delete_demande(
    """
    filter the rows which have to be deleted
    """
    where: demande_bool_exp!
  ): demande_mutation_response

  """
  delete single row from the table: "demande"
  """
  delete_demande_by_pk(id: Int!): demande

  """
  delete data from the table: "enseignement"
  """
  delete_enseignement(
    """
    filter the rows which have to be deleted
    """
    where: enseignement_bool_exp!
  ): enseignement_mutation_response

  """
  delete single row from the table: "enseignement"
  """
  delete_enseignement_by_pk(
    """
    L'identifiant unique de l'enseignement.
    """
    id: Int!
  ): enseignement

  """
  delete data from the table: "intervenant"
  """
  delete_intervenant(
    """
    filter the rows which have to be deleted
    """
    where: intervenant_bool_exp!
  ): intervenant_mutation_response

  """
  delete single row from the table: "intervenant"
  """
  delete_intervenant_by_pk(
    """
    L'identifiant unique de l'intervenant.
    """
    uid: String!
  ): intervenant

  """
  delete data from the table: "mention"
  """
  delete_mention(
    """
    filter the rows which have to be deleted
    """
    where: mention_bool_exp!
  ): mention_mutation_response

  """
  delete single row from the table: "mention"
  """
  delete_mention_by_pk(
    """
    L'identifiant unique de la mention.
    """
    id: Int!
  ): mention

  """
  delete data from the table: "message"
  """
  delete_message(
    """
    filter the rows which have to be deleted
    """
    where: message_bool_exp!
  ): message_mutation_response

  """
  delete single row from the table: "message"
  """
  delete_message_by_pk(
    """
    L'identifiant unique du message.
    """
    id: Int!
  ): message

  """
  delete data from the table: "modification_service"
  """
  delete_modification_service(
    """
    filter the rows which have to be deleted
    """
    where: modification_service_bool_exp!
  ): modification_service_mutation_response

  """
  delete single row from the table: "modification_service"
  """
  delete_modification_service_by_pk(
    """
    L'identifiant unique de la modification.
    """
    id: Int!
  ): modification_service

  """
  delete data from the table: "parcours"
  """
  delete_parcours(
    """
    filter the rows which have to be deleted
    """
    where: parcours_bool_exp!
  ): parcours_mutation_response

  """
  delete single row from the table: "parcours"
  """
  delete_parcours_by_pk(
    """
    L'identifiant unique du parcours.
    """
    id: Int!
  ): parcours

  """
  delete data from the table: "phase"
  """
  delete_phase(
    """
    filter the rows which have to be deleted
    """
    where: phase_bool_exp!
  ): phase_mutation_response

  """
  delete single row from the table: "phase"
  """
  delete_phase_by_pk(
    """
    Le nom de la phase (unique).
    """
    value: String!
  ): phase

  """
  delete data from the table: "priorite"
  """
  delete_priorite(
    """
    filter the rows which have to be deleted
    """
    where: priorite_bool_exp!
  ): priorite_mutation_response

  """
  delete single row from the table: "priorite"
  """
  delete_priorite_by_pk(id: Int!): priorite

  """
  delete data from the table: "responsable"
  """
  delete_responsable(
    """
    filter the rows which have to be deleted
    """
    where: responsable_bool_exp!
  ): responsable_mutation_response

  """
  delete single row from the table: "responsable"
  """
  delete_responsable_by_pk(id: Int!): responsable

  """
  delete data from the table: "service"
  """
  delete_service(
    """
    filter the rows which have to be deleted
    """
    where: service_bool_exp!
  ): service_mutation_response

  """
  delete single row from the table: "service"
  """
  delete_service_by_pk(
    """
    L'identifiant unique du service.
    """
    id: Int!
  ): service

  """
  delete data from the table: "type_demande"
  """
  delete_type_demande(
    """
    filter the rows which have to be deleted
    """
    where: type_demande_bool_exp!
  ): type_demande_mutation_response

  """
  delete single row from the table: "type_demande"
  """
  delete_type_demande_by_pk(
    """
    Le type de demande (unique).
    """
    value: String!
  ): type_demande

  """
  delete data from the table: "type_enseignement"
  """
  delete_type_enseignement(
    """
    filter the rows which have to be deleted
    """
    where: type_enseignement_bool_exp!
  ): type_enseignement_mutation_response

  """
  delete single row from the table: "type_enseignement"
  """
  delete_type_enseignement_by_pk(
    """
    Le type d'enseignement (unique).
    """
    label: String!
  ): type_enseignement

  """
  delete data from the table: "type_modification"
  """
  delete_type_modification(
    """
    filter the rows which have to be deleted
    """
    where: type_modification_bool_exp!
  ): type_modification_mutation_response

  """
  delete single row from the table: "type_modification"
  """
  delete_type_modification_by_pk(
    """
    Le type de modification (unique).
    """
    label: String!
  ): type_modification

  """
  insert data into the table: "annee"
  """
  insert_annee(
    """
    the rows to be inserted
    """
    objects: [annee_insert_input!]!

    """
    upsert condition
    """
    on_conflict: annee_on_conflict
  ): annee_mutation_response

  """
  insert a single row into the table: "annee"
  """
  insert_annee_one(
    """
    the row to be inserted
    """
    object: annee_insert_input!

    """
    upsert condition
    """
    on_conflict: annee_on_conflict
  ): annee

  """
  insert data into the table: "cursus"
  """
  insert_cursus(
    """
    the rows to be inserted
    """
    objects: [cursus_insert_input!]!

    """
    upsert condition
    """
    on_conflict: cursus_on_conflict
  ): cursus_mutation_response

  """
  insert a single row into the table: "cursus"
  """
  insert_cursus_one(
    """
    the row to be inserted
    """
    object: cursus_insert_input!

    """
    upsert condition
    """
    on_conflict: cursus_on_conflict
  ): cursus

  """
  insert data into the table: "demande"
  """
  insert_demande(
    """
    the rows to be inserted
    """
    objects: [demande_insert_input!]!

    """
    upsert condition
    """
    on_conflict: demande_on_conflict
  ): demande_mutation_response

  """
  insert a single row into the table: "demande"
  """
  insert_demande_one(
    """
    the row to be inserted
    """
    object: demande_insert_input!

    """
    upsert condition
    """
    on_conflict: demande_on_conflict
  ): demande

  """
  insert data into the table: "enseignement"
  """
  insert_enseignement(
    """
    the rows to be inserted
    """
    objects: [enseignement_insert_input!]!

    """
    upsert condition
    """
    on_conflict: enseignement_on_conflict
  ): enseignement_mutation_response

  """
  insert a single row into the table: "enseignement"
  """
  insert_enseignement_one(
    """
    the row to be inserted
    """
    object: enseignement_insert_input!

    """
    upsert condition
    """
    on_conflict: enseignement_on_conflict
  ): enseignement

  """
  insert data into the table: "intervenant"
  """
  insert_intervenant(
    """
    the rows to be inserted
    """
    objects: [intervenant_insert_input!]!

    """
    upsert condition
    """
    on_conflict: intervenant_on_conflict
  ): intervenant_mutation_response

  """
  insert a single row into the table: "intervenant"
  """
  insert_intervenant_one(
    """
    the row to be inserted
    """
    object: intervenant_insert_input!

    """
    upsert condition
    """
    on_conflict: intervenant_on_conflict
  ): intervenant

  """
  insert data into the table: "mention"
  """
  insert_mention(
    """
    the rows to be inserted
    """
    objects: [mention_insert_input!]!

    """
    upsert condition
    """
    on_conflict: mention_on_conflict
  ): mention_mutation_response

  """
  insert a single row into the table: "mention"
  """
  insert_mention_one(
    """
    the row to be inserted
    """
    object: mention_insert_input!

    """
    upsert condition
    """
    on_conflict: mention_on_conflict
  ): mention

  """
  insert data into the table: "message"
  """
  insert_message(
    """
    the rows to be inserted
    """
    objects: [message_insert_input!]!

    """
    upsert condition
    """
    on_conflict: message_on_conflict
  ): message_mutation_response

  """
  insert a single row into the table: "message"
  """
  insert_message_one(
    """
    the row to be inserted
    """
    object: message_insert_input!

    """
    upsert condition
    """
    on_conflict: message_on_conflict
  ): message

  """
  insert data into the table: "modification_service"
  """
  insert_modification_service(
    """
    the rows to be inserted
    """
    objects: [modification_service_insert_input!]!

    """
    upsert condition
    """
    on_conflict: modification_service_on_conflict
  ): modification_service_mutation_response

  """
  insert a single row into the table: "modification_service"
  """
  insert_modification_service_one(
    """
    the row to be inserted
    """
    object: modification_service_insert_input!

    """
    upsert condition
    """
    on_conflict: modification_service_on_conflict
  ): modification_service

  """
  insert data into the table: "parcours"
  """
  insert_parcours(
    """
    the rows to be inserted
    """
    objects: [parcours_insert_input!]!

    """
    upsert condition
    """
    on_conflict: parcours_on_conflict
  ): parcours_mutation_response

  """
  insert a single row into the table: "parcours"
  """
  insert_parcours_one(
    """
    the row to be inserted
    """
    object: parcours_insert_input!

    """
    upsert condition
    """
    on_conflict: parcours_on_conflict
  ): parcours

  """
  insert data into the table: "phase"
  """
  insert_phase(
    """
    the rows to be inserted
    """
    objects: [phase_insert_input!]!

    """
    upsert condition
    """
    on_conflict: phase_on_conflict
  ): phase_mutation_response

  """
  insert a single row into the table: "phase"
  """
  insert_phase_one(
    """
    the row to be inserted
    """
    object: phase_insert_input!

    """
    upsert condition
    """
    on_conflict: phase_on_conflict
  ): phase

  """
  insert data into the table: "priorite"
  """
  insert_priorite(
    """
    the rows to be inserted
    """
    objects: [priorite_insert_input!]!

    """
    upsert condition
    """
    on_conflict: priorite_on_conflict
  ): priorite_mutation_response

  """
  insert a single row into the table: "priorite"
  """
  insert_priorite_one(
    """
    the row to be inserted
    """
    object: priorite_insert_input!

    """
    upsert condition
    """
    on_conflict: priorite_on_conflict
  ): priorite

  """
  insert data into the table: "responsable"
  """
  insert_responsable(
    """
    the rows to be inserted
    """
    objects: [responsable_insert_input!]!

    """
    upsert condition
    """
    on_conflict: responsable_on_conflict
  ): responsable_mutation_response

  """
  insert a single row into the table: "responsable"
  """
  insert_responsable_one(
    """
    the row to be inserted
    """
    object: responsable_insert_input!

    """
    upsert condition
    """
    on_conflict: responsable_on_conflict
  ): responsable

  """
  insert data into the table: "service"
  """
  insert_service(
    """
    the rows to be inserted
    """
    objects: [service_insert_input!]!

    """
    upsert condition
    """
    on_conflict: service_on_conflict
  ): service_mutation_response

  """
  insert a single row into the table: "service"
  """
  insert_service_one(
    """
    the row to be inserted
    """
    object: service_insert_input!

    """
    upsert condition
    """
    on_conflict: service_on_conflict
  ): service

  """
  insert data into the table: "type_demande"
  """
  insert_type_demande(
    """
    the rows to be inserted
    """
    objects: [type_demande_insert_input!]!

    """
    upsert condition
    """
    on_conflict: type_demande_on_conflict
  ): type_demande_mutation_response

  """
  insert a single row into the table: "type_demande"
  """
  insert_type_demande_one(
    """
    the row to be inserted
    """
    object: type_demande_insert_input!

    """
    upsert condition
    """
    on_conflict: type_demande_on_conflict
  ): type_demande

  """
  insert data into the table: "type_enseignement"
  """
  insert_type_enseignement(
    """
    the rows to be inserted
    """
    objects: [type_enseignement_insert_input!]!

    """
    upsert condition
    """
    on_conflict: type_enseignement_on_conflict
  ): type_enseignement_mutation_response

  """
  insert a single row into the table: "type_enseignement"
  """
  insert_type_enseignement_one(
    """
    the row to be inserted
    """
    object: type_enseignement_insert_input!

    """
    upsert condition
    """
    on_conflict: type_enseignement_on_conflict
  ): type_enseignement

  """
  insert data into the table: "type_modification"
  """
  insert_type_modification(
    """
    the rows to be inserted
    """
    objects: [type_modification_insert_input!]!

    """
    upsert condition
    """
    on_conflict: type_modification_on_conflict
  ): type_modification_mutation_response

  """
  insert a single row into the table: "type_modification"
  """
  insert_type_modification_one(
    """
    the row to be inserted
    """
    object: type_modification_insert_input!

    """
    upsert condition
    """
    on_conflict: type_modification_on_conflict
  ): type_modification

  """
  update data of the table: "annee"
  """
  update_annee(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: annee_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: annee_set_input

    """
    filter the rows which have to be updated
    """
    where: annee_bool_exp!
  ): annee_mutation_response

  """
  update single row of the table: "annee"
  """
  update_annee_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: annee_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: annee_set_input
    pk_columns: annee_pk_columns_input!
  ): annee

  """
  update multiples rows of table: "annee"
  """
  update_annee_many(
    """
    updates to execute, in order
    """
    updates: [annee_updates!]!
  ): [annee_mutation_response]

  """
  update data of the table: "cursus"
  """
  update_cursus(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: cursus_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: cursus_set_input

    """
    filter the rows which have to be updated
    """
    where: cursus_bool_exp!
  ): cursus_mutation_response

  """
  update single row of the table: "cursus"
  """
  update_cursus_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: cursus_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: cursus_set_input
    pk_columns: cursus_pk_columns_input!
  ): cursus

  """
  update multiples rows of table: "cursus"
  """
  update_cursus_many(
    """
    updates to execute, in order
    """
    updates: [cursus_updates!]!
  ): [cursus_mutation_response]

  """
  update data of the table: "demande"
  """
  update_demande(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: demande_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: demande_set_input

    """
    filter the rows which have to be updated
    """
    where: demande_bool_exp!
  ): demande_mutation_response

  """
  update single row of the table: "demande"
  """
  update_demande_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: demande_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: demande_set_input
    pk_columns: demande_pk_columns_input!
  ): demande

  """
  update multiples rows of table: "demande"
  """
  update_demande_many(
    """
    updates to execute, in order
    """
    updates: [demande_updates!]!
  ): [demande_mutation_response]

  """
  update data of the table: "enseignement"
  """
  update_enseignement(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: enseignement_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: enseignement_set_input

    """
    filter the rows which have to be updated
    """
    where: enseignement_bool_exp!
  ): enseignement_mutation_response

  """
  update single row of the table: "enseignement"
  """
  update_enseignement_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: enseignement_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: enseignement_set_input
    pk_columns: enseignement_pk_columns_input!
  ): enseignement

  """
  update multiples rows of table: "enseignement"
  """
  update_enseignement_many(
    """
    updates to execute, in order
    """
    updates: [enseignement_updates!]!
  ): [enseignement_mutation_response]

  """
  update data of the table: "intervenant"
  """
  update_intervenant(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: intervenant_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: intervenant_set_input

    """
    filter the rows which have to be updated
    """
    where: intervenant_bool_exp!
  ): intervenant_mutation_response

  """
  update single row of the table: "intervenant"
  """
  update_intervenant_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: intervenant_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: intervenant_set_input
    pk_columns: intervenant_pk_columns_input!
  ): intervenant

  """
  update multiples rows of table: "intervenant"
  """
  update_intervenant_many(
    """
    updates to execute, in order
    """
    updates: [intervenant_updates!]!
  ): [intervenant_mutation_response]

  """
  update data of the table: "mention"
  """
  update_mention(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: mention_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: mention_set_input

    """
    filter the rows which have to be updated
    """
    where: mention_bool_exp!
  ): mention_mutation_response

  """
  update single row of the table: "mention"
  """
  update_mention_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: mention_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: mention_set_input
    pk_columns: mention_pk_columns_input!
  ): mention

  """
  update multiples rows of table: "mention"
  """
  update_mention_many(
    """
    updates to execute, in order
    """
    updates: [mention_updates!]!
  ): [mention_mutation_response]

  """
  update data of the table: "message"
  """
  update_message(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: message_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: message_set_input

    """
    filter the rows which have to be updated
    """
    where: message_bool_exp!
  ): message_mutation_response

  """
  update single row of the table: "message"
  """
  update_message_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: message_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: message_set_input
    pk_columns: message_pk_columns_input!
  ): message

  """
  update multiples rows of table: "message"
  """
  update_message_many(
    """
    updates to execute, in order
    """
    updates: [message_updates!]!
  ): [message_mutation_response]

  """
  update data of the table: "modification_service"
  """
  update_modification_service(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: modification_service_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: modification_service_set_input

    """
    filter the rows which have to be updated
    """
    where: modification_service_bool_exp!
  ): modification_service_mutation_response

  """
  update single row of the table: "modification_service"
  """
  update_modification_service_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: modification_service_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: modification_service_set_input
    pk_columns: modification_service_pk_columns_input!
  ): modification_service

  """
  update multiples rows of table: "modification_service"
  """
  update_modification_service_many(
    """
    updates to execute, in order
    """
    updates: [modification_service_updates!]!
  ): [modification_service_mutation_response]

  """
  update data of the table: "parcours"
  """
  update_parcours(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: parcours_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: parcours_set_input

    """
    filter the rows which have to be updated
    """
    where: parcours_bool_exp!
  ): parcours_mutation_response

  """
  update single row of the table: "parcours"
  """
  update_parcours_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: parcours_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: parcours_set_input
    pk_columns: parcours_pk_columns_input!
  ): parcours

  """
  update multiples rows of table: "parcours"
  """
  update_parcours_many(
    """
    updates to execute, in order
    """
    updates: [parcours_updates!]!
  ): [parcours_mutation_response]

  """
  update data of the table: "phase"
  """
  update_phase(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: phase_set_input

    """
    filter the rows which have to be updated
    """
    where: phase_bool_exp!
  ): phase_mutation_response

  """
  update single row of the table: "phase"
  """
  update_phase_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: phase_set_input
    pk_columns: phase_pk_columns_input!
  ): phase

  """
  update multiples rows of table: "phase"
  """
  update_phase_many(
    """
    updates to execute, in order
    """
    updates: [phase_updates!]!
  ): [phase_mutation_response]

  """
  update data of the table: "priorite"
  """
  update_priorite(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: priorite_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: priorite_set_input

    """
    filter the rows which have to be updated
    """
    where: priorite_bool_exp!
  ): priorite_mutation_response

  """
  update single row of the table: "priorite"
  """
  update_priorite_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: priorite_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: priorite_set_input
    pk_columns: priorite_pk_columns_input!
  ): priorite

  """
  update multiples rows of table: "priorite"
  """
  update_priorite_many(
    """
    updates to execute, in order
    """
    updates: [priorite_updates!]!
  ): [priorite_mutation_response]

  """
  update data of the table: "responsable"
  """
  update_responsable(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: responsable_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: responsable_set_input

    """
    filter the rows which have to be updated
    """
    where: responsable_bool_exp!
  ): responsable_mutation_response

  """
  update single row of the table: "responsable"
  """
  update_responsable_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: responsable_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: responsable_set_input
    pk_columns: responsable_pk_columns_input!
  ): responsable

  """
  update multiples rows of table: "responsable"
  """
  update_responsable_many(
    """
    updates to execute, in order
    """
    updates: [responsable_updates!]!
  ): [responsable_mutation_response]

  """
  update data of the table: "service"
  """
  update_service(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: service_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: service_set_input

    """
    filter the rows which have to be updated
    """
    where: service_bool_exp!
  ): service_mutation_response

  """
  update single row of the table: "service"
  """
  update_service_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: service_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: service_set_input
    pk_columns: service_pk_columns_input!
  ): service

  """
  update multiples rows of table: "service"
  """
  update_service_many(
    """
    updates to execute, in order
    """
    updates: [service_updates!]!
  ): [service_mutation_response]

  """
  update data of the table: "type_demande"
  """
  update_type_demande(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: type_demande_set_input

    """
    filter the rows which have to be updated
    """
    where: type_demande_bool_exp!
  ): type_demande_mutation_response

  """
  update single row of the table: "type_demande"
  """
  update_type_demande_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: type_demande_set_input
    pk_columns: type_demande_pk_columns_input!
  ): type_demande

  """
  update multiples rows of table: "type_demande"
  """
  update_type_demande_many(
    """
    updates to execute, in order
    """
    updates: [type_demande_updates!]!
  ): [type_demande_mutation_response]

  """
  update data of the table: "type_enseignement"
  """
  update_type_enseignement(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: type_enseignement_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: type_enseignement_set_input

    """
    filter the rows which have to be updated
    """
    where: type_enseignement_bool_exp!
  ): type_enseignement_mutation_response

  """
  update single row of the table: "type_enseignement"
  """
  update_type_enseignement_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: type_enseignement_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: type_enseignement_set_input
    pk_columns: type_enseignement_pk_columns_input!
  ): type_enseignement

  """
  update multiples rows of table: "type_enseignement"
  """
  update_type_enseignement_many(
    """
    updates to execute, in order
    """
    updates: [type_enseignement_updates!]!
  ): [type_enseignement_mutation_response]

  """
  update data of the table: "type_modification"
  """
  update_type_modification(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: type_modification_set_input

    """
    filter the rows which have to be updated
    """
    where: type_modification_bool_exp!
  ): type_modification_mutation_response

  """
  update single row of the table: "type_modification"
  """
  update_type_modification_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: type_modification_set_input
    pk_columns: type_modification_pk_columns_input!
  ): type_modification

  """
  update multiples rows of table: "type_modification"
  """
  update_type_modification_many(
    """
    updates to execute, in order
    """
    updates: [type_modification_updates!]!
  ): [type_modification_mutation_response]
}

"""
column ordering options
"""
enum order_by {
  """
  in ascending order, nulls last
  """
  asc

  """
  in ascending order, nulls first
  """
  asc_nulls_first

  """
  in ascending order, nulls last
  """
  asc_nulls_last

  """
  in descending order, nulls first
  """
  desc

  """
  in descending order, nulls first
  """
  desc_nulls_first

  """
  in descending order, nulls last
  """
  desc_nulls_last
}

"""
Table contenant les différents parcours.
"""
type parcours {
  """
  An array relationship
  """
  enseignements(
    """
    distinct select on columns
    """
    distinct_on: [enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [enseignement_order_by!]

    """
    filter the rows returned
    """
    where: enseignement_bool_exp
  ): [enseignement!]!

  """
  An aggregate relationship
  """
  enseignements_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [enseignement_order_by!]

    """
    filter the rows returned
    """
    where: enseignement_bool_exp
  ): enseignement_aggregate!

  """
  L'identifiant unique du parcours.
  """
  id: Int!

  """
  An object relationship
  """
  mention: mention!
  mention_id: Int!

  """
  Le nom du parcours (unique).
  """
  nom: String!

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String
  nom_import: String

  """
  An array relationship
  """
  responsables(
    """
    distinct select on columns
    """
    distinct_on: [responsable_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [responsable_order_by!]

    """
    filter the rows returned
    """
    where: responsable_bool_exp
  ): [responsable!]!

  """
  An aggregate relationship
  """
  responsables_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [responsable_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [responsable_order_by!]

    """
    filter the rows returned
    """
    where: responsable_bool_exp
  ): responsable_aggregate!

  """
  Indique si le parcours correspondant est visible par les utilisateurs.
  """
  visible: Boolean!
}

"""
aggregated selection of "parcours"
"""
type parcours_aggregate {
  aggregate: parcours_aggregate_fields
  nodes: [parcours!]!
}

input parcours_aggregate_bool_exp {
  bool_and: parcours_aggregate_bool_exp_bool_and
  bool_or: parcours_aggregate_bool_exp_bool_or
  count: parcours_aggregate_bool_exp_count
}

input parcours_aggregate_bool_exp_bool_and {
  arguments: parcours_select_column_parcours_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: parcours_bool_exp
  predicate: Boolean_comparison_exp!
}

input parcours_aggregate_bool_exp_bool_or {
  arguments: parcours_select_column_parcours_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: parcours_bool_exp
  predicate: Boolean_comparison_exp!
}

input parcours_aggregate_bool_exp_count {
  arguments: [parcours_select_column!]
  distinct: Boolean
  filter: parcours_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "parcours"
"""
type parcours_aggregate_fields {
  avg: parcours_avg_fields
  count(columns: [parcours_select_column!], distinct: Boolean): Int!
  max: parcours_max_fields
  min: parcours_min_fields
  stddev: parcours_stddev_fields
  stddev_pop: parcours_stddev_pop_fields
  stddev_samp: parcours_stddev_samp_fields
  sum: parcours_sum_fields
  var_pop: parcours_var_pop_fields
  var_samp: parcours_var_samp_fields
  variance: parcours_variance_fields
}

"""
order by aggregate values of table "parcours"
"""
input parcours_aggregate_order_by {
  avg: parcours_avg_order_by
  count: order_by
  max: parcours_max_order_by
  min: parcours_min_order_by
  stddev: parcours_stddev_order_by
  stddev_pop: parcours_stddev_pop_order_by
  stddev_samp: parcours_stddev_samp_order_by
  sum: parcours_sum_order_by
  var_pop: parcours_var_pop_order_by
  var_samp: parcours_var_samp_order_by
  variance: parcours_variance_order_by
}

"""
input type for inserting array relation for remote table "parcours"
"""
input parcours_arr_rel_insert_input {
  data: [parcours_insert_input!]!

  """
  upsert condition
  """
  on_conflict: parcours_on_conflict
}

"""
aggregate avg on columns
"""
type parcours_avg_fields {
  """
  L'identifiant unique du parcours.
  """
  id: Float
  mention_id: Float
}

"""
order by avg() on columns of table "parcours"
"""
input parcours_avg_order_by {
  """
  L'identifiant unique du parcours.
  """
  id: order_by
  mention_id: order_by
}

"""
Boolean expression to filter rows from the table "parcours". All fields are combined with a logical 'AND'.
"""
input parcours_bool_exp {
  _and: [parcours_bool_exp!]
  _not: parcours_bool_exp
  _or: [parcours_bool_exp!]
  enseignements: enseignement_bool_exp
  enseignements_aggregate: enseignement_aggregate_bool_exp
  id: Int_comparison_exp
  mention: mention_bool_exp
  mention_id: Int_comparison_exp
  nom: String_comparison_exp
  nom_court: String_comparison_exp
  nom_import: String_comparison_exp
  responsables: responsable_bool_exp
  responsables_aggregate: responsable_aggregate_bool_exp
  visible: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "parcours"
"""
enum parcours_constraint {
  """
  unique or primary key constraint on columns "mention_id", "nom"
  """
  parcours_mention_id_nom_key

  """
  unique or primary key constraint on columns "id"
  """
  parcours_pkey
}

"""
input type for incrementing numeric columns in table "parcours"
"""
input parcours_inc_input {
  """
  L'identifiant unique du parcours.
  """
  id: Int
  mention_id: Int
}

"""
input type for inserting data into table "parcours"
"""
input parcours_insert_input {
  enseignements: enseignement_arr_rel_insert_input

  """
  L'identifiant unique du parcours.
  """
  id: Int
  mention: mention_obj_rel_insert_input
  mention_id: Int

  """
  Le nom du parcours (unique).
  """
  nom: String

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String
  nom_import: String
  responsables: responsable_arr_rel_insert_input

  """
  Indique si le parcours correspondant est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate max on columns
"""
type parcours_max_fields {
  """
  L'identifiant unique du parcours.
  """
  id: Int
  mention_id: Int

  """
  Le nom du parcours (unique).
  """
  nom: String

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String
  nom_import: String
}

"""
order by max() on columns of table "parcours"
"""
input parcours_max_order_by {
  """
  L'identifiant unique du parcours.
  """
  id: order_by
  mention_id: order_by

  """
  Le nom du parcours (unique).
  """
  nom: order_by

  """
  Le nom abrégé (optionnel).
  """
  nom_court: order_by
  nom_import: order_by
}

"""
aggregate min on columns
"""
type parcours_min_fields {
  """
  L'identifiant unique du parcours.
  """
  id: Int
  mention_id: Int

  """
  Le nom du parcours (unique).
  """
  nom: String

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String
  nom_import: String
}

"""
order by min() on columns of table "parcours"
"""
input parcours_min_order_by {
  """
  L'identifiant unique du parcours.
  """
  id: order_by
  mention_id: order_by

  """
  Le nom du parcours (unique).
  """
  nom: order_by

  """
  Le nom abrégé (optionnel).
  """
  nom_court: order_by
  nom_import: order_by
}

"""
response of any mutation on the table "parcours"
"""
type parcours_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [parcours!]!
}

"""
input type for inserting object relation for remote table "parcours"
"""
input parcours_obj_rel_insert_input {
  data: parcours_insert_input!

  """
  upsert condition
  """
  on_conflict: parcours_on_conflict
}

"""
on_conflict condition type for table "parcours"
"""
input parcours_on_conflict {
  constraint: parcours_constraint!
  update_columns: [parcours_update_column!]! = []
  where: parcours_bool_exp
}

"""
Ordering options when selecting data from "parcours".
"""
input parcours_order_by {
  enseignements_aggregate: enseignement_aggregate_order_by
  id: order_by
  mention: mention_order_by
  mention_id: order_by
  nom: order_by
  nom_court: order_by
  nom_import: order_by
  responsables_aggregate: responsable_aggregate_order_by
  visible: order_by
}

"""
primary key columns input for table: parcours
"""
input parcours_pk_columns_input {
  """
  L'identifiant unique du parcours.
  """
  id: Int!
}

"""
select columns of table "parcours"
"""
enum parcours_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  mention_id

  """
  column name
  """
  nom

  """
  column name
  """
  nom_court

  """
  column name
  """
  nom_import

  """
  column name
  """
  visible
}

"""
select "parcours_aggregate_bool_exp_bool_and_arguments_columns" columns of table "parcours"
"""
enum parcours_select_column_parcours_aggregate_bool_exp_bool_and_arguments_columns {
  """
  column name
  """
  visible
}

"""
select "parcours_aggregate_bool_exp_bool_or_arguments_columns" columns of table "parcours"
"""
enum parcours_select_column_parcours_aggregate_bool_exp_bool_or_arguments_columns {
  """
  column name
  """
  visible
}

"""
input type for updating data in table "parcours"
"""
input parcours_set_input {
  """
  L'identifiant unique du parcours.
  """
  id: Int
  mention_id: Int

  """
  Le nom du parcours (unique).
  """
  nom: String

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String
  nom_import: String

  """
  Indique si le parcours correspondant est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate stddev on columns
"""
type parcours_stddev_fields {
  """
  L'identifiant unique du parcours.
  """
  id: Float
  mention_id: Float
}

"""
order by stddev() on columns of table "parcours"
"""
input parcours_stddev_order_by {
  """
  L'identifiant unique du parcours.
  """
  id: order_by
  mention_id: order_by
}

"""
aggregate stddev_pop on columns
"""
type parcours_stddev_pop_fields {
  """
  L'identifiant unique du parcours.
  """
  id: Float
  mention_id: Float
}

"""
order by stddev_pop() on columns of table "parcours"
"""
input parcours_stddev_pop_order_by {
  """
  L'identifiant unique du parcours.
  """
  id: order_by
  mention_id: order_by
}

"""
aggregate stddev_samp on columns
"""
type parcours_stddev_samp_fields {
  """
  L'identifiant unique du parcours.
  """
  id: Float
  mention_id: Float
}

"""
order by stddev_samp() on columns of table "parcours"
"""
input parcours_stddev_samp_order_by {
  """
  L'identifiant unique du parcours.
  """
  id: order_by
  mention_id: order_by
}

"""
Streaming cursor of the table "parcours"
"""
input parcours_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: parcours_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input parcours_stream_cursor_value_input {
  """
  L'identifiant unique du parcours.
  """
  id: Int
  mention_id: Int

  """
  Le nom du parcours (unique).
  """
  nom: String

  """
  Le nom abrégé (optionnel).
  """
  nom_court: String
  nom_import: String

  """
  Indique si le parcours correspondant est visible par les utilisateurs.
  """
  visible: Boolean
}

"""
aggregate sum on columns
"""
type parcours_sum_fields {
  """
  L'identifiant unique du parcours.
  """
  id: Int
  mention_id: Int
}

"""
order by sum() on columns of table "parcours"
"""
input parcours_sum_order_by {
  """
  L'identifiant unique du parcours.
  """
  id: order_by
  mention_id: order_by
}

"""
update columns of table "parcours"
"""
enum parcours_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  mention_id

  """
  column name
  """
  nom

  """
  column name
  """
  nom_court

  """
  column name
  """
  nom_import

  """
  column name
  """
  visible
}

input parcours_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: parcours_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: parcours_set_input

  """
  filter the rows which have to be updated
  """
  where: parcours_bool_exp!
}

"""
aggregate var_pop on columns
"""
type parcours_var_pop_fields {
  """
  L'identifiant unique du parcours.
  """
  id: Float
  mention_id: Float
}

"""
order by var_pop() on columns of table "parcours"
"""
input parcours_var_pop_order_by {
  """
  L'identifiant unique du parcours.
  """
  id: order_by
  mention_id: order_by
}

"""
aggregate var_samp on columns
"""
type parcours_var_samp_fields {
  """
  L'identifiant unique du parcours.
  """
  id: Float
  mention_id: Float
}

"""
order by var_samp() on columns of table "parcours"
"""
input parcours_var_samp_order_by {
  """
  L'identifiant unique du parcours.
  """
  id: order_by
  mention_id: order_by
}

"""
aggregate variance on columns
"""
type parcours_variance_fields {
  """
  L'identifiant unique du parcours.
  """
  id: Float
  mention_id: Float
}

"""
order by variance() on columns of table "parcours"
"""
input parcours_variance_order_by {
  """
  L'identifiant unique du parcours.
  """
  id: order_by
  mention_id: order_by
}

"""
Table contenant les différentes phases de Geyser.
"""
type phase {
  """
  Une brève description.
  """
  description: String

  """
  Indique si la phase correspondante est la phase en cours (TRUE) ou non (NULL). Une seule phase peut être en cours à la fois.
  """
  en_cours: Boolean

  """
  Le nom de la phase (unique).
  """
  value: String!
}

"""
aggregated selection of "phase"
"""
type phase_aggregate {
  aggregate: phase_aggregate_fields
  nodes: [phase!]!
}

"""
aggregate fields of "phase"
"""
type phase_aggregate_fields {
  count(columns: [phase_select_column!], distinct: Boolean): Int!
  max: phase_max_fields
  min: phase_min_fields
}

"""
Boolean expression to filter rows from the table "phase". All fields are combined with a logical 'AND'.
"""
input phase_bool_exp {
  _and: [phase_bool_exp!]
  _not: phase_bool_exp
  _or: [phase_bool_exp!]
  description: String_comparison_exp
  en_cours: Boolean_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "phase"
"""
enum phase_constraint {
  """
  unique or primary key constraint on columns "en_cours"
  """
  phase_en_cours_key

  """
  unique or primary key constraint on columns "value"
  """
  phase_pkey
}

"""
input type for inserting data into table "phase"
"""
input phase_insert_input {
  """
  Une brève description.
  """
  description: String

  """
  Indique si la phase correspondante est la phase en cours (TRUE) ou non (NULL). Une seule phase peut être en cours à la fois.
  """
  en_cours: Boolean

  """
  Le nom de la phase (unique).
  """
  value: String
}

"""
aggregate max on columns
"""
type phase_max_fields {
  """
  Une brève description.
  """
  description: String

  """
  Le nom de la phase (unique).
  """
  value: String
}

"""
aggregate min on columns
"""
type phase_min_fields {
  """
  Une brève description.
  """
  description: String

  """
  Le nom de la phase (unique).
  """
  value: String
}

"""
response of any mutation on the table "phase"
"""
type phase_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [phase!]!
}

"""
on_conflict condition type for table "phase"
"""
input phase_on_conflict {
  constraint: phase_constraint!
  update_columns: [phase_update_column!]! = []
  where: phase_bool_exp
}

"""
Ordering options when selecting data from "phase".
"""
input phase_order_by {
  description: order_by
  en_cours: order_by
  value: order_by
}

"""
primary key columns input for table: phase
"""
input phase_pk_columns_input {
  """
  Le nom de la phase (unique).
  """
  value: String!
}

"""
select columns of table "phase"
"""
enum phase_select_column {
  """
  column name
  """
  description

  """
  column name
  """
  en_cours

  """
  column name
  """
  value
}

"""
input type for updating data in table "phase"
"""
input phase_set_input {
  """
  Une brève description.
  """
  description: String

  """
  Indique si la phase correspondante est la phase en cours (TRUE) ou non (NULL). Une seule phase peut être en cours à la fois.
  """
  en_cours: Boolean

  """
  Le nom de la phase (unique).
  """
  value: String
}

"""
Streaming cursor of the table "phase"
"""
input phase_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: phase_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input phase_stream_cursor_value_input {
  """
  Une brève description.
  """
  description: String

  """
  Indique si la phase correspondante est la phase en cours (TRUE) ou non (NULL). Une seule phase peut être en cours à la fois.
  """
  en_cours: Boolean

  """
  Le nom de la phase (unique).
  """
  value: String
}

"""
update columns of table "phase"
"""
enum phase_update_column {
  """
  column name
  """
  description

  """
  column name
  """
  en_cours

  """
  column name
  """
  value
}

input phase_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: phase_set_input

  """
  filter the rows which have to be updated
  """
  where: phase_bool_exp!
}

"""
Table contenant les informations relatives à l'ancienneté et la priorité des intervenants sur les enseignements.
"""
type priorite {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: Int

  """
  L'identifiant d'un enseignement.
  """
  ens_id: Int!

  """
  An object relationship
  """
  enseignement: enseignement!
  id: Int!

  """
  An object relationship
  """
  intervenant: intervenant!

  """
  Indique si l'intervenant est prioritaire sur l'enseignement.
  """
  prioritaire: Boolean

  """
  L'identifiant d'un intervenant.
  """
  uid: String!
}

"""
aggregated selection of "priorite"
"""
type priorite_aggregate {
  aggregate: priorite_aggregate_fields
  nodes: [priorite!]!
}

input priorite_aggregate_bool_exp {
  bool_and: priorite_aggregate_bool_exp_bool_and
  bool_or: priorite_aggregate_bool_exp_bool_or
  count: priorite_aggregate_bool_exp_count
}

input priorite_aggregate_bool_exp_bool_and {
  arguments: priorite_select_column_priorite_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: priorite_bool_exp
  predicate: Boolean_comparison_exp!
}

input priorite_aggregate_bool_exp_bool_or {
  arguments: priorite_select_column_priorite_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: priorite_bool_exp
  predicate: Boolean_comparison_exp!
}

input priorite_aggregate_bool_exp_count {
  arguments: [priorite_select_column!]
  distinct: Boolean
  filter: priorite_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "priorite"
"""
type priorite_aggregate_fields {
  avg: priorite_avg_fields
  count(columns: [priorite_select_column!], distinct: Boolean): Int!
  max: priorite_max_fields
  min: priorite_min_fields
  stddev: priorite_stddev_fields
  stddev_pop: priorite_stddev_pop_fields
  stddev_samp: priorite_stddev_samp_fields
  sum: priorite_sum_fields
  var_pop: priorite_var_pop_fields
  var_samp: priorite_var_samp_fields
  variance: priorite_variance_fields
}

"""
order by aggregate values of table "priorite"
"""
input priorite_aggregate_order_by {
  avg: priorite_avg_order_by
  count: order_by
  max: priorite_max_order_by
  min: priorite_min_order_by
  stddev: priorite_stddev_order_by
  stddev_pop: priorite_stddev_pop_order_by
  stddev_samp: priorite_stddev_samp_order_by
  sum: priorite_sum_order_by
  var_pop: priorite_var_pop_order_by
  var_samp: priorite_var_samp_order_by
  variance: priorite_variance_order_by
}

"""
input type for inserting array relation for remote table "priorite"
"""
input priorite_arr_rel_insert_input {
  data: [priorite_insert_input!]!

  """
  upsert condition
  """
  on_conflict: priorite_on_conflict
}

"""
aggregate avg on columns
"""
type priorite_avg_fields {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: Float

  """
  L'identifiant d'un enseignement.
  """
  ens_id: Float
  id: Float
}

"""
order by avg() on columns of table "priorite"
"""
input priorite_avg_order_by {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: order_by

  """
  L'identifiant d'un enseignement.
  """
  ens_id: order_by
  id: order_by
}

"""
Boolean expression to filter rows from the table "priorite". All fields are combined with a logical 'AND'.
"""
input priorite_bool_exp {
  _and: [priorite_bool_exp!]
  _not: priorite_bool_exp
  _or: [priorite_bool_exp!]
  anciennete: Int_comparison_exp
  ens_id: Int_comparison_exp
  enseignement: enseignement_bool_exp
  id: Int_comparison_exp
  intervenant: intervenant_bool_exp
  prioritaire: Boolean_comparison_exp
  uid: String_comparison_exp
}

"""
unique or primary key constraints on table "priorite"
"""
enum priorite_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  priorite_pkey

  """
  unique or primary key constraint on columns "uid", "ens_id"
  """
  priorite_uid_ens_id_key
}

"""
input type for incrementing numeric columns in table "priorite"
"""
input priorite_inc_input {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: Int

  """
  L'identifiant d'un enseignement.
  """
  ens_id: Int
  id: Int
}

"""
input type for inserting data into table "priorite"
"""
input priorite_insert_input {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: Int

  """
  L'identifiant d'un enseignement.
  """
  ens_id: Int
  enseignement: enseignement_obj_rel_insert_input
  id: Int
  intervenant: intervenant_obj_rel_insert_input

  """
  Indique si l'intervenant est prioritaire sur l'enseignement.
  """
  prioritaire: Boolean

  """
  L'identifiant d'un intervenant.
  """
  uid: String
}

"""
aggregate max on columns
"""
type priorite_max_fields {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: Int

  """
  L'identifiant d'un enseignement.
  """
  ens_id: Int
  id: Int

  """
  L'identifiant d'un intervenant.
  """
  uid: String
}

"""
order by max() on columns of table "priorite"
"""
input priorite_max_order_by {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: order_by

  """
  L'identifiant d'un enseignement.
  """
  ens_id: order_by
  id: order_by

  """
  L'identifiant d'un intervenant.
  """
  uid: order_by
}

"""
aggregate min on columns
"""
type priorite_min_fields {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: Int

  """
  L'identifiant d'un enseignement.
  """
  ens_id: Int
  id: Int

  """
  L'identifiant d'un intervenant.
  """
  uid: String
}

"""
order by min() on columns of table "priorite"
"""
input priorite_min_order_by {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: order_by

  """
  L'identifiant d'un enseignement.
  """
  ens_id: order_by
  id: order_by

  """
  L'identifiant d'un intervenant.
  """
  uid: order_by
}

"""
response of any mutation on the table "priorite"
"""
type priorite_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [priorite!]!
}

"""
on_conflict condition type for table "priorite"
"""
input priorite_on_conflict {
  constraint: priorite_constraint!
  update_columns: [priorite_update_column!]! = []
  where: priorite_bool_exp
}

"""
Ordering options when selecting data from "priorite".
"""
input priorite_order_by {
  anciennete: order_by
  ens_id: order_by
  enseignement: enseignement_order_by
  id: order_by
  intervenant: intervenant_order_by
  prioritaire: order_by
  uid: order_by
}

"""
primary key columns input for table: priorite
"""
input priorite_pk_columns_input {
  id: Int!
}

"""
select columns of table "priorite"
"""
enum priorite_select_column {
  """
  column name
  """
  anciennete

  """
  column name
  """
  ens_id

  """
  column name
  """
  id

  """
  column name
  """
  prioritaire

  """
  column name
  """
  uid
}

"""
select "priorite_aggregate_bool_exp_bool_and_arguments_columns" columns of table "priorite"
"""
enum priorite_select_column_priorite_aggregate_bool_exp_bool_and_arguments_columns {
  """
  column name
  """
  prioritaire
}

"""
select "priorite_aggregate_bool_exp_bool_or_arguments_columns" columns of table "priorite"
"""
enum priorite_select_column_priorite_aggregate_bool_exp_bool_or_arguments_columns {
  """
  column name
  """
  prioritaire
}

"""
input type for updating data in table "priorite"
"""
input priorite_set_input {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: Int

  """
  L'identifiant d'un enseignement.
  """
  ens_id: Int
  id: Int

  """
  Indique si l'intervenant est prioritaire sur l'enseignement.
  """
  prioritaire: Boolean

  """
  L'identifiant d'un intervenant.
  """
  uid: String
}

"""
aggregate stddev on columns
"""
type priorite_stddev_fields {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: Float

  """
  L'identifiant d'un enseignement.
  """
  ens_id: Float
  id: Float
}

"""
order by stddev() on columns of table "priorite"
"""
input priorite_stddev_order_by {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: order_by

  """
  L'identifiant d'un enseignement.
  """
  ens_id: order_by
  id: order_by
}

"""
aggregate stddev_pop on columns
"""
type priorite_stddev_pop_fields {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: Float

  """
  L'identifiant d'un enseignement.
  """
  ens_id: Float
  id: Float
}

"""
order by stddev_pop() on columns of table "priorite"
"""
input priorite_stddev_pop_order_by {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: order_by

  """
  L'identifiant d'un enseignement.
  """
  ens_id: order_by
  id: order_by
}

"""
aggregate stddev_samp on columns
"""
type priorite_stddev_samp_fields {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: Float

  """
  L'identifiant d'un enseignement.
  """
  ens_id: Float
  id: Float
}

"""
order by stddev_samp() on columns of table "priorite"
"""
input priorite_stddev_samp_order_by {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: order_by

  """
  L'identifiant d'un enseignement.
  """
  ens_id: order_by
  id: order_by
}

"""
Streaming cursor of the table "priorite"
"""
input priorite_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: priorite_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input priorite_stream_cursor_value_input {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: Int

  """
  L'identifiant d'un enseignement.
  """
  ens_id: Int
  id: Int

  """
  Indique si l'intervenant est prioritaire sur l'enseignement.
  """
  prioritaire: Boolean

  """
  L'identifiant d'un intervenant.
  """
  uid: String
}

"""
aggregate sum on columns
"""
type priorite_sum_fields {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: Int

  """
  L'identifiant d'un enseignement.
  """
  ens_id: Int
  id: Int
}

"""
order by sum() on columns of table "priorite"
"""
input priorite_sum_order_by {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: order_by

  """
  L'identifiant d'un enseignement.
  """
  ens_id: order_by
  id: order_by
}

"""
update columns of table "priorite"
"""
enum priorite_update_column {
  """
  column name
  """
  anciennete

  """
  column name
  """
  ens_id

  """
  column name
  """
  id

  """
  column name
  """
  prioritaire

  """
  column name
  """
  uid
}

input priorite_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: priorite_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: priorite_set_input

  """
  filter the rows which have to be updated
  """
  where: priorite_bool_exp!
}

"""
aggregate var_pop on columns
"""
type priorite_var_pop_fields {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: Float

  """
  L'identifiant d'un enseignement.
  """
  ens_id: Float
  id: Float
}

"""
order by var_pop() on columns of table "priorite"
"""
input priorite_var_pop_order_by {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: order_by

  """
  L'identifiant d'un enseignement.
  """
  ens_id: order_by
  id: order_by
}

"""
aggregate var_samp on columns
"""
type priorite_var_samp_fields {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: Float

  """
  L'identifiant d'un enseignement.
  """
  ens_id: Float
  id: Float
}

"""
order by var_samp() on columns of table "priorite"
"""
input priorite_var_samp_order_by {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: order_by

  """
  L'identifiant d'un enseignement.
  """
  ens_id: order_by
  id: order_by
}

"""
aggregate variance on columns
"""
type priorite_variance_fields {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: Float

  """
  L'identifiant d'un enseignement.
  """
  ens_id: Float
  id: Float
}

"""
order by variance() on columns of table "priorite"
"""
input priorite_variance_order_by {
  """
  Le nombre d'années consécutives jusqu'à l'année en cours (exclue) durant lesquelles l'enseignement a été attribué à l'intervenant.
  """
  anciennete: order_by

  """
  L'identifiant d'un enseignement.
  """
  ens_id: order_by
  id: order_by
}

type query_root {
  """
  fetch data from the table: "annee"
  """
  annee(
    """
    distinct select on columns
    """
    distinct_on: [annee_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [annee_order_by!]

    """
    filter the rows returned
    """
    where: annee_bool_exp
  ): [annee!]!

  """
  fetch aggregated fields from the table: "annee"
  """
  annee_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [annee_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [annee_order_by!]

    """
    filter the rows returned
    """
    where: annee_bool_exp
  ): annee_aggregate!

  """
  fetch data from the table: "annee" using primary key columns
  """
  annee_by_pk(
    """
    Le numéro de l'année (unique).
    """
    value: Int!
  ): annee

  """
  fetch data from the table: "cursus"
  """
  cursus(
    """
    distinct select on columns
    """
    distinct_on: [cursus_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [cursus_order_by!]

    """
    filter the rows returned
    """
    where: cursus_bool_exp
  ): [cursus!]!

  """
  fetch aggregated fields from the table: "cursus"
  """
  cursus_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [cursus_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [cursus_order_by!]

    """
    filter the rows returned
    """
    where: cursus_bool_exp
  ): cursus_aggregate!

  """
  fetch data from the table: "cursus" using primary key columns
  """
  cursus_by_pk(
    """
    L'identifiant unique du cursus.
    """
    id: Int!
  ): cursus

  """
  fetch data from the table: "demande"
  """
  demande(
    """
    distinct select on columns
    """
    distinct_on: [demande_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [demande_order_by!]

    """
    filter the rows returned
    """
    where: demande_bool_exp
  ): [demande!]!

  """
  fetch aggregated fields from the table: "demande"
  """
  demande_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [demande_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [demande_order_by!]

    """
    filter the rows returned
    """
    where: demande_bool_exp
  ): demande_aggregate!

  """
  fetch data from the table: "demande" using primary key columns
  """
  demande_by_pk(id: Int!): demande

  """
  fetch data from the table: "enseignement"
  """
  enseignement(
    """
    distinct select on columns
    """
    distinct_on: [enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [enseignement_order_by!]

    """
    filter the rows returned
    """
    where: enseignement_bool_exp
  ): [enseignement!]!

  """
  fetch aggregated fields from the table: "enseignement"
  """
  enseignement_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [enseignement_order_by!]

    """
    filter the rows returned
    """
    where: enseignement_bool_exp
  ): enseignement_aggregate!

  """
  fetch data from the table: "enseignement" using primary key columns
  """
  enseignement_by_pk(
    """
    L'identifiant unique de l'enseignement.
    """
    id: Int!
  ): enseignement

  """
  fetch data from the table: "intervenant"
  """
  intervenant(
    """
    distinct select on columns
    """
    distinct_on: [intervenant_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [intervenant_order_by!]

    """
    filter the rows returned
    """
    where: intervenant_bool_exp
  ): [intervenant!]!

  """
  fetch aggregated fields from the table: "intervenant"
  """
  intervenant_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [intervenant_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [intervenant_order_by!]

    """
    filter the rows returned
    """
    where: intervenant_bool_exp
  ): intervenant_aggregate!

  """
  fetch data from the table: "intervenant" using primary key columns
  """
  intervenant_by_pk(
    """
    L'identifiant unique de l'intervenant.
    """
    uid: String!
  ): intervenant

  """
  fetch data from the table: "mention"
  """
  mention(
    """
    distinct select on columns
    """
    distinct_on: [mention_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [mention_order_by!]

    """
    filter the rows returned
    """
    where: mention_bool_exp
  ): [mention!]!

  """
  fetch aggregated fields from the table: "mention"
  """
  mention_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [mention_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [mention_order_by!]

    """
    filter the rows returned
    """
    where: mention_bool_exp
  ): mention_aggregate!

  """
  fetch data from the table: "mention" using primary key columns
  """
  mention_by_pk(
    """
    L'identifiant unique de la mention.
    """
    id: Int!
  ): mention

  """
  fetch data from the table: "message"
  """
  message(
    """
    distinct select on columns
    """
    distinct_on: [message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [message_order_by!]

    """
    filter the rows returned
    """
    where: message_bool_exp
  ): [message!]!

  """
  fetch aggregated fields from the table: "message"
  """
  message_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [message_order_by!]

    """
    filter the rows returned
    """
    where: message_bool_exp
  ): message_aggregate!

  """
  fetch data from the table: "message" using primary key columns
  """
  message_by_pk(
    """
    L'identifiant unique du message.
    """
    id: Int!
  ): message

  """
  fetch data from the table: "modification_service"
  """
  modification_service(
    """
    distinct select on columns
    """
    distinct_on: [modification_service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [modification_service_order_by!]

    """
    filter the rows returned
    """
    where: modification_service_bool_exp
  ): [modification_service!]!

  """
  fetch aggregated fields from the table: "modification_service"
  """
  modification_service_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [modification_service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [modification_service_order_by!]

    """
    filter the rows returned
    """
    where: modification_service_bool_exp
  ): modification_service_aggregate!

  """
  fetch data from the table: "modification_service" using primary key columns
  """
  modification_service_by_pk(
    """
    L'identifiant unique de la modification.
    """
    id: Int!
  ): modification_service

  """
  An array relationship
  """
  parcours(
    """
    distinct select on columns
    """
    distinct_on: [parcours_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [parcours_order_by!]

    """
    filter the rows returned
    """
    where: parcours_bool_exp
  ): [parcours!]!

  """
  An aggregate relationship
  """
  parcours_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [parcours_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [parcours_order_by!]

    """
    filter the rows returned
    """
    where: parcours_bool_exp
  ): parcours_aggregate!

  """
  fetch data from the table: "parcours" using primary key columns
  """
  parcours_by_pk(
    """
    L'identifiant unique du parcours.
    """
    id: Int!
  ): parcours

  """
  fetch data from the table: "phase"
  """
  phase(
    """
    distinct select on columns
    """
    distinct_on: [phase_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [phase_order_by!]

    """
    filter the rows returned
    """
    where: phase_bool_exp
  ): [phase!]!

  """
  fetch aggregated fields from the table: "phase"
  """
  phase_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [phase_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [phase_order_by!]

    """
    filter the rows returned
    """
    where: phase_bool_exp
  ): phase_aggregate!

  """
  fetch data from the table: "phase" using primary key columns
  """
  phase_by_pk(
    """
    Le nom de la phase (unique).
    """
    value: String!
  ): phase

  """
  fetch data from the table: "priorite"
  """
  priorite(
    """
    distinct select on columns
    """
    distinct_on: [priorite_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [priorite_order_by!]

    """
    filter the rows returned
    """
    where: priorite_bool_exp
  ): [priorite!]!

  """
  fetch aggregated fields from the table: "priorite"
  """
  priorite_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [priorite_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [priorite_order_by!]

    """
    filter the rows returned
    """
    where: priorite_bool_exp
  ): priorite_aggregate!

  """
  fetch data from the table: "priorite" using primary key columns
  """
  priorite_by_pk(id: Int!): priorite

  """
  fetch data from the table: "responsable"
  """
  responsable(
    """
    distinct select on columns
    """
    distinct_on: [responsable_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [responsable_order_by!]

    """
    filter the rows returned
    """
    where: responsable_bool_exp
  ): [responsable!]!

  """
  fetch aggregated fields from the table: "responsable"
  """
  responsable_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [responsable_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [responsable_order_by!]

    """
    filter the rows returned
    """
    where: responsable_bool_exp
  ): responsable_aggregate!

  """
  fetch data from the table: "responsable" using primary key columns
  """
  responsable_by_pk(id: Int!): responsable

  """
  fetch data from the table: "service"
  """
  service(
    """
    distinct select on columns
    """
    distinct_on: [service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [service_order_by!]

    """
    filter the rows returned
    """
    where: service_bool_exp
  ): [service!]!

  """
  fetch aggregated fields from the table: "service"
  """
  service_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [service_order_by!]

    """
    filter the rows returned
    """
    where: service_bool_exp
  ): service_aggregate!

  """
  fetch data from the table: "service" using primary key columns
  """
  service_by_pk(
    """
    L'identifiant unique du service.
    """
    id: Int!
  ): service

  """
  fetch data from the table: "type_demande"
  """
  type_demande(
    """
    distinct select on columns
    """
    distinct_on: [type_demande_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [type_demande_order_by!]

    """
    filter the rows returned
    """
    where: type_demande_bool_exp
  ): [type_demande!]!

  """
  fetch aggregated fields from the table: "type_demande"
  """
  type_demande_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [type_demande_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [type_demande_order_by!]

    """
    filter the rows returned
    """
    where: type_demande_bool_exp
  ): type_demande_aggregate!

  """
  fetch data from the table: "type_demande" using primary key columns
  """
  type_demande_by_pk(
    """
    Le type de demande (unique).
    """
    value: String!
  ): type_demande

  """
  fetch data from the table: "type_enseignement"
  """
  type_enseignement(
    """
    distinct select on columns
    """
    distinct_on: [type_enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [type_enseignement_order_by!]

    """
    filter the rows returned
    """
    where: type_enseignement_bool_exp
  ): [type_enseignement!]!

  """
  fetch aggregated fields from the table: "type_enseignement"
  """
  type_enseignement_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [type_enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [type_enseignement_order_by!]

    """
    filter the rows returned
    """
    where: type_enseignement_bool_exp
  ): type_enseignement_aggregate!

  """
  fetch data from the table: "type_enseignement" using primary key columns
  """
  type_enseignement_by_pk(
    """
    Le type d'enseignement (unique).
    """
    label: String!
  ): type_enseignement

  """
  fetch data from the table: "type_modification"
  """
  type_modification(
    """
    distinct select on columns
    """
    distinct_on: [type_modification_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [type_modification_order_by!]

    """
    filter the rows returned
    """
    where: type_modification_bool_exp
  ): [type_modification!]!

  """
  fetch aggregated fields from the table: "type_modification"
  """
  type_modification_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [type_modification_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [type_modification_order_by!]

    """
    filter the rows returned
    """
    where: type_modification_bool_exp
  ): type_modification_aggregate!

  """
  fetch data from the table: "type_modification" using primary key columns
  """
  type_modification_by_pk(
    """
    Le type de modification (unique).
    """
    label: String!
  ): type_modification
}

"""
Table contenant les responsables d'une mention, d'un parcours ou d'un enseignement. Chaque ligne correspond à un et un seul de ces trois types de responsabilité.
"""
type responsable {
  """
  Informations supplémentaires (optionnel, par exemple pour préciser l'année dans le cas d'une responsabilité de parcours ou de mention).
  """
  commentaire: String

  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: Int

  """
  An object relationship
  """
  enseignement: enseignement
  id: Int!

  """
  An object relationship
  """
  intervenant: intervenant!

  """
  An object relationship
  """
  mention: mention

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: Int

  """
  An object relationship
  """
  parcours: parcours

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: Int

  """
  L'identifiant de l'intervenant responsable.
  """
  uid: String!
}

"""
aggregated selection of "responsable"
"""
type responsable_aggregate {
  aggregate: responsable_aggregate_fields
  nodes: [responsable!]!
}

input responsable_aggregate_bool_exp {
  count: responsable_aggregate_bool_exp_count
}

input responsable_aggregate_bool_exp_count {
  arguments: [responsable_select_column!]
  distinct: Boolean
  filter: responsable_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "responsable"
"""
type responsable_aggregate_fields {
  avg: responsable_avg_fields
  count(columns: [responsable_select_column!], distinct: Boolean): Int!
  max: responsable_max_fields
  min: responsable_min_fields
  stddev: responsable_stddev_fields
  stddev_pop: responsable_stddev_pop_fields
  stddev_samp: responsable_stddev_samp_fields
  sum: responsable_sum_fields
  var_pop: responsable_var_pop_fields
  var_samp: responsable_var_samp_fields
  variance: responsable_variance_fields
}

"""
order by aggregate values of table "responsable"
"""
input responsable_aggregate_order_by {
  avg: responsable_avg_order_by
  count: order_by
  max: responsable_max_order_by
  min: responsable_min_order_by
  stddev: responsable_stddev_order_by
  stddev_pop: responsable_stddev_pop_order_by
  stddev_samp: responsable_stddev_samp_order_by
  sum: responsable_sum_order_by
  var_pop: responsable_var_pop_order_by
  var_samp: responsable_var_samp_order_by
  variance: responsable_variance_order_by
}

"""
input type for inserting array relation for remote table "responsable"
"""
input responsable_arr_rel_insert_input {
  data: [responsable_insert_input!]!

  """
  upsert condition
  """
  on_conflict: responsable_on_conflict
}

"""
aggregate avg on columns
"""
type responsable_avg_fields {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: Float
  id: Float

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: Float

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: Float
}

"""
order by avg() on columns of table "responsable"
"""
input responsable_avg_order_by {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: order_by
  id: order_by

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: order_by

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: order_by
}

"""
Boolean expression to filter rows from the table "responsable". All fields are combined with a logical 'AND'.
"""
input responsable_bool_exp {
  _and: [responsable_bool_exp!]
  _not: responsable_bool_exp
  _or: [responsable_bool_exp!]
  commentaire: String_comparison_exp
  ens_id: Int_comparison_exp
  enseignement: enseignement_bool_exp
  id: Int_comparison_exp
  intervenant: intervenant_bool_exp
  mention: mention_bool_exp
  mention_id: Int_comparison_exp
  parcours: parcours_bool_exp
  parcours_id: Int_comparison_exp
  uid: String_comparison_exp
}

"""
unique or primary key constraints on table "responsable"
"""
enum responsable_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  responsable_pkey

  """
  unique or primary key constraint on columns "uid", "mention_id", "ens_id", "parcours_id"
  """
  responsable_uid_ens_id_parcours_id_mention_id_key
}

"""
input type for incrementing numeric columns in table "responsable"
"""
input responsable_inc_input {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: Int
  id: Int

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: Int

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: Int
}

"""
input type for inserting data into table "responsable"
"""
input responsable_insert_input {
  """
  Informations supplémentaires (optionnel, par exemple pour préciser l'année dans le cas d'une responsabilité de parcours ou de mention).
  """
  commentaire: String

  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: Int
  enseignement: enseignement_obj_rel_insert_input
  id: Int
  intervenant: intervenant_obj_rel_insert_input
  mention: mention_obj_rel_insert_input

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: Int
  parcours: parcours_obj_rel_insert_input

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: Int

  """
  L'identifiant de l'intervenant responsable.
  """
  uid: String
}

"""
aggregate max on columns
"""
type responsable_max_fields {
  """
  Informations supplémentaires (optionnel, par exemple pour préciser l'année dans le cas d'une responsabilité de parcours ou de mention).
  """
  commentaire: String

  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: Int
  id: Int

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: Int

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: Int

  """
  L'identifiant de l'intervenant responsable.
  """
  uid: String
}

"""
order by max() on columns of table "responsable"
"""
input responsable_max_order_by {
  """
  Informations supplémentaires (optionnel, par exemple pour préciser l'année dans le cas d'une responsabilité de parcours ou de mention).
  """
  commentaire: order_by

  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: order_by
  id: order_by

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: order_by

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: order_by

  """
  L'identifiant de l'intervenant responsable.
  """
  uid: order_by
}

"""
aggregate min on columns
"""
type responsable_min_fields {
  """
  Informations supplémentaires (optionnel, par exemple pour préciser l'année dans le cas d'une responsabilité de parcours ou de mention).
  """
  commentaire: String

  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: Int
  id: Int

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: Int

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: Int

  """
  L'identifiant de l'intervenant responsable.
  """
  uid: String
}

"""
order by min() on columns of table "responsable"
"""
input responsable_min_order_by {
  """
  Informations supplémentaires (optionnel, par exemple pour préciser l'année dans le cas d'une responsabilité de parcours ou de mention).
  """
  commentaire: order_by

  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: order_by
  id: order_by

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: order_by

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: order_by

  """
  L'identifiant de l'intervenant responsable.
  """
  uid: order_by
}

"""
response of any mutation on the table "responsable"
"""
type responsable_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [responsable!]!
}

"""
on_conflict condition type for table "responsable"
"""
input responsable_on_conflict {
  constraint: responsable_constraint!
  update_columns: [responsable_update_column!]! = []
  where: responsable_bool_exp
}

"""
Ordering options when selecting data from "responsable".
"""
input responsable_order_by {
  commentaire: order_by
  ens_id: order_by
  enseignement: enseignement_order_by
  id: order_by
  intervenant: intervenant_order_by
  mention: mention_order_by
  mention_id: order_by
  parcours: parcours_order_by
  parcours_id: order_by
  uid: order_by
}

"""
primary key columns input for table: responsable
"""
input responsable_pk_columns_input {
  id: Int!
}

"""
select columns of table "responsable"
"""
enum responsable_select_column {
  """
  column name
  """
  commentaire

  """
  column name
  """
  ens_id

  """
  column name
  """
  id

  """
  column name
  """
  mention_id

  """
  column name
  """
  parcours_id

  """
  column name
  """
  uid
}

"""
input type for updating data in table "responsable"
"""
input responsable_set_input {
  """
  Informations supplémentaires (optionnel, par exemple pour préciser l'année dans le cas d'une responsabilité de parcours ou de mention).
  """
  commentaire: String

  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: Int
  id: Int

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: Int

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: Int

  """
  L'identifiant de l'intervenant responsable.
  """
  uid: String
}

"""
aggregate stddev on columns
"""
type responsable_stddev_fields {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: Float
  id: Float

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: Float

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: Float
}

"""
order by stddev() on columns of table "responsable"
"""
input responsable_stddev_order_by {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: order_by
  id: order_by

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: order_by

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: order_by
}

"""
aggregate stddev_pop on columns
"""
type responsable_stddev_pop_fields {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: Float
  id: Float

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: Float

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: Float
}

"""
order by stddev_pop() on columns of table "responsable"
"""
input responsable_stddev_pop_order_by {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: order_by
  id: order_by

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: order_by

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: order_by
}

"""
aggregate stddev_samp on columns
"""
type responsable_stddev_samp_fields {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: Float
  id: Float

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: Float

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: Float
}

"""
order by stddev_samp() on columns of table "responsable"
"""
input responsable_stddev_samp_order_by {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: order_by
  id: order_by

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: order_by

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: order_by
}

"""
Streaming cursor of the table "responsable"
"""
input responsable_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: responsable_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input responsable_stream_cursor_value_input {
  """
  Informations supplémentaires (optionnel, par exemple pour préciser l'année dans le cas d'une responsabilité de parcours ou de mention).
  """
  commentaire: String

  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: Int
  id: Int

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: Int

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: Int

  """
  L'identifiant de l'intervenant responsable.
  """
  uid: String
}

"""
aggregate sum on columns
"""
type responsable_sum_fields {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: Int
  id: Int

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: Int

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: Int
}

"""
order by sum() on columns of table "responsable"
"""
input responsable_sum_order_by {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: order_by
  id: order_by

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: order_by

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: order_by
}

"""
update columns of table "responsable"
"""
enum responsable_update_column {
  """
  column name
  """
  commentaire

  """
  column name
  """
  ens_id

  """
  column name
  """
  id

  """
  column name
  """
  mention_id

  """
  column name
  """
  parcours_id

  """
  column name
  """
  uid
}

input responsable_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: responsable_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: responsable_set_input

  """
  filter the rows which have to be updated
  """
  where: responsable_bool_exp!
}

"""
aggregate var_pop on columns
"""
type responsable_var_pop_fields {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: Float
  id: Float

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: Float

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: Float
}

"""
order by var_pop() on columns of table "responsable"
"""
input responsable_var_pop_order_by {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: order_by
  id: order_by

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: order_by

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: order_by
}

"""
aggregate var_samp on columns
"""
type responsable_var_samp_fields {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: Float
  id: Float

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: Float

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: Float
}

"""
order by var_samp() on columns of table "responsable"
"""
input responsable_var_samp_order_by {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: order_by
  id: order_by

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: order_by

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: order_by
}

"""
aggregate variance on columns
"""
type responsable_variance_fields {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: Float
  id: Float

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: Float

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: Float
}

"""
order by variance() on columns of table "responsable"
"""
input responsable_variance_order_by {
  """
  L'identifiant de l'enseignement (optionnel, si et seulement si la ligne correspond à une responsabilité d'enseignement).
  """
  ens_id: order_by
  id: order_by

  """
  L'identifiant de la mention (optionnel, si et seulement si la ligne correspond à une responsabilité de mention).
  """
  mention_id: order_by

  """
  L'identifiant du parcours (optionnel, si et seulement si la ligne correspond à une responsabilité de parcours).
  """
  parcours_id: order_by
}

"""
Table contenant les services de base, c'est-à-dire le nombre d'heures EQTD qu'un intervenant donné doit réaliser lors d'une année donnée avant modifications éventuelles.
"""
type service {
  """
  L'année correspondant au service.
  """
  annee: Int!

  """
  An object relationship
  """
  anneeByAnnee: annee!

  """
  An array relationship
  """
  demandes(
    """
    distinct select on columns
    """
    distinct_on: [demande_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [demande_order_by!]

    """
    filter the rows returned
    """
    where: demande_bool_exp
  ): [demande!]!

  """
  An aggregate relationship
  """
  demandes_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [demande_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [demande_order_by!]

    """
    filter the rows returned
    """
    where: demande_bool_exp
  ): demande_aggregate!

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: Float!

  """
  L'identifiant unique du service.
  """
  id: Int!

  """
  An object relationship
  """
  intervenant: intervenant!

  """
  An array relationship
  """
  messages(
    """
    distinct select on columns
    """
    distinct_on: [message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [message_order_by!]

    """
    filter the rows returned
    """
    where: message_bool_exp
  ): [message!]!

  """
  An aggregate relationship
  """
  messages_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [message_order_by!]

    """
    filter the rows returned
    """
    where: message_bool_exp
  ): message_aggregate!

  """
  An array relationship
  """
  modifications(
    """
    distinct select on columns
    """
    distinct_on: [modification_service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [modification_service_order_by!]

    """
    filter the rows returned
    """
    where: modification_service_bool_exp
  ): [modification_service!]!

  """
  An aggregate relationship
  """
  modifications_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [modification_service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [modification_service_order_by!]

    """
    filter the rows returned
    """
    where: modification_service_bool_exp
  ): modification_service_aggregate!

  """
  L'identifiant de l'intervenant correspond au service.
  """
  uid: String!
}

"""
aggregated selection of "service"
"""
type service_aggregate {
  aggregate: service_aggregate_fields
  nodes: [service!]!
}

input service_aggregate_bool_exp {
  count: service_aggregate_bool_exp_count
}

input service_aggregate_bool_exp_count {
  arguments: [service_select_column!]
  distinct: Boolean
  filter: service_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "service"
"""
type service_aggregate_fields {
  avg: service_avg_fields
  count(columns: [service_select_column!], distinct: Boolean): Int!
  max: service_max_fields
  min: service_min_fields
  stddev: service_stddev_fields
  stddev_pop: service_stddev_pop_fields
  stddev_samp: service_stddev_samp_fields
  sum: service_sum_fields
  var_pop: service_var_pop_fields
  var_samp: service_var_samp_fields
  variance: service_variance_fields
}

"""
order by aggregate values of table "service"
"""
input service_aggregate_order_by {
  avg: service_avg_order_by
  count: order_by
  max: service_max_order_by
  min: service_min_order_by
  stddev: service_stddev_order_by
  stddev_pop: service_stddev_pop_order_by
  stddev_samp: service_stddev_samp_order_by
  sum: service_sum_order_by
  var_pop: service_var_pop_order_by
  var_samp: service_var_samp_order_by
  variance: service_variance_order_by
}

"""
input type for inserting array relation for remote table "service"
"""
input service_arr_rel_insert_input {
  data: [service_insert_input!]!

  """
  upsert condition
  """
  on_conflict: service_on_conflict
}

"""
aggregate avg on columns
"""
type service_avg_fields {
  """
  L'année correspondant au service.
  """
  annee: Float

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: Float

  """
  L'identifiant unique du service.
  """
  id: Float
}

"""
order by avg() on columns of table "service"
"""
input service_avg_order_by {
  """
  L'année correspondant au service.
  """
  annee: order_by

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: order_by

  """
  L'identifiant unique du service.
  """
  id: order_by
}

"""
Boolean expression to filter rows from the table "service". All fields are combined with a logical 'AND'.
"""
input service_bool_exp {
  _and: [service_bool_exp!]
  _not: service_bool_exp
  _or: [service_bool_exp!]
  annee: Int_comparison_exp
  anneeByAnnee: annee_bool_exp
  demandes: demande_bool_exp
  demandes_aggregate: demande_aggregate_bool_exp
  heures_eqtd: Float_comparison_exp
  id: Int_comparison_exp
  intervenant: intervenant_bool_exp
  messages: message_bool_exp
  messages_aggregate: message_aggregate_bool_exp
  modifications: modification_service_bool_exp
  modifications_aggregate: modification_service_aggregate_bool_exp
  uid: String_comparison_exp
}

"""
unique or primary key constraints on table "service"
"""
enum service_constraint {
  """
  unique or primary key constraint on columns "uid", "annee"
  """
  service_annee_uid_key

  """
  unique or primary key constraint on columns "id"
  """
  service_pkey
}

"""
input type for incrementing numeric columns in table "service"
"""
input service_inc_input {
  """
  L'année correspondant au service.
  """
  annee: Int

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: Float

  """
  L'identifiant unique du service.
  """
  id: Int
}

"""
input type for inserting data into table "service"
"""
input service_insert_input {
  """
  L'année correspondant au service.
  """
  annee: Int
  anneeByAnnee: annee_obj_rel_insert_input
  demandes: demande_arr_rel_insert_input

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: Float

  """
  L'identifiant unique du service.
  """
  id: Int
  intervenant: intervenant_obj_rel_insert_input
  messages: message_arr_rel_insert_input
  modifications: modification_service_arr_rel_insert_input

  """
  L'identifiant de l'intervenant correspond au service.
  """
  uid: String
}

"""
aggregate max on columns
"""
type service_max_fields {
  """
  L'année correspondant au service.
  """
  annee: Int

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: Float

  """
  L'identifiant unique du service.
  """
  id: Int

  """
  L'identifiant de l'intervenant correspond au service.
  """
  uid: String
}

"""
order by max() on columns of table "service"
"""
input service_max_order_by {
  """
  L'année correspondant au service.
  """
  annee: order_by

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: order_by

  """
  L'identifiant unique du service.
  """
  id: order_by

  """
  L'identifiant de l'intervenant correspond au service.
  """
  uid: order_by
}

"""
aggregate min on columns
"""
type service_min_fields {
  """
  L'année correspondant au service.
  """
  annee: Int

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: Float

  """
  L'identifiant unique du service.
  """
  id: Int

  """
  L'identifiant de l'intervenant correspond au service.
  """
  uid: String
}

"""
order by min() on columns of table "service"
"""
input service_min_order_by {
  """
  L'année correspondant au service.
  """
  annee: order_by

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: order_by

  """
  L'identifiant unique du service.
  """
  id: order_by

  """
  L'identifiant de l'intervenant correspond au service.
  """
  uid: order_by
}

"""
response of any mutation on the table "service"
"""
type service_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [service!]!
}

"""
input type for inserting object relation for remote table "service"
"""
input service_obj_rel_insert_input {
  data: service_insert_input!

  """
  upsert condition
  """
  on_conflict: service_on_conflict
}

"""
on_conflict condition type for table "service"
"""
input service_on_conflict {
  constraint: service_constraint!
  update_columns: [service_update_column!]! = []
  where: service_bool_exp
}

"""
Ordering options when selecting data from "service".
"""
input service_order_by {
  annee: order_by
  anneeByAnnee: annee_order_by
  demandes_aggregate: demande_aggregate_order_by
  heures_eqtd: order_by
  id: order_by
  intervenant: intervenant_order_by
  messages_aggregate: message_aggregate_order_by
  modifications_aggregate: modification_service_aggregate_order_by
  uid: order_by
}

"""
primary key columns input for table: service
"""
input service_pk_columns_input {
  """
  L'identifiant unique du service.
  """
  id: Int!
}

"""
select columns of table "service"
"""
enum service_select_column {
  """
  column name
  """
  annee

  """
  column name
  """
  heures_eqtd

  """
  column name
  """
  id

  """
  column name
  """
  uid
}

"""
input type for updating data in table "service"
"""
input service_set_input {
  """
  L'année correspondant au service.
  """
  annee: Int

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: Float

  """
  L'identifiant unique du service.
  """
  id: Int

  """
  L'identifiant de l'intervenant correspond au service.
  """
  uid: String
}

"""
aggregate stddev on columns
"""
type service_stddev_fields {
  """
  L'année correspondant au service.
  """
  annee: Float

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: Float

  """
  L'identifiant unique du service.
  """
  id: Float
}

"""
order by stddev() on columns of table "service"
"""
input service_stddev_order_by {
  """
  L'année correspondant au service.
  """
  annee: order_by

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: order_by

  """
  L'identifiant unique du service.
  """
  id: order_by
}

"""
aggregate stddev_pop on columns
"""
type service_stddev_pop_fields {
  """
  L'année correspondant au service.
  """
  annee: Float

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: Float

  """
  L'identifiant unique du service.
  """
  id: Float
}

"""
order by stddev_pop() on columns of table "service"
"""
input service_stddev_pop_order_by {
  """
  L'année correspondant au service.
  """
  annee: order_by

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: order_by

  """
  L'identifiant unique du service.
  """
  id: order_by
}

"""
aggregate stddev_samp on columns
"""
type service_stddev_samp_fields {
  """
  L'année correspondant au service.
  """
  annee: Float

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: Float

  """
  L'identifiant unique du service.
  """
  id: Float
}

"""
order by stddev_samp() on columns of table "service"
"""
input service_stddev_samp_order_by {
  """
  L'année correspondant au service.
  """
  annee: order_by

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: order_by

  """
  L'identifiant unique du service.
  """
  id: order_by
}

"""
Streaming cursor of the table "service"
"""
input service_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: service_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input service_stream_cursor_value_input {
  """
  L'année correspondant au service.
  """
  annee: Int

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: Float

  """
  L'identifiant unique du service.
  """
  id: Int

  """
  L'identifiant de l'intervenant correspond au service.
  """
  uid: String
}

"""
aggregate sum on columns
"""
type service_sum_fields {
  """
  L'année correspondant au service.
  """
  annee: Int

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: Float

  """
  L'identifiant unique du service.
  """
  id: Int
}

"""
order by sum() on columns of table "service"
"""
input service_sum_order_by {
  """
  L'année correspondant au service.
  """
  annee: order_by

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: order_by

  """
  L'identifiant unique du service.
  """
  id: order_by
}

"""
update columns of table "service"
"""
enum service_update_column {
  """
  column name
  """
  annee

  """
  column name
  """
  heures_eqtd

  """
  column name
  """
  id

  """
  column name
  """
  uid
}

input service_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: service_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: service_set_input

  """
  filter the rows which have to be updated
  """
  where: service_bool_exp!
}

"""
aggregate var_pop on columns
"""
type service_var_pop_fields {
  """
  L'année correspondant au service.
  """
  annee: Float

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: Float

  """
  L'identifiant unique du service.
  """
  id: Float
}

"""
order by var_pop() on columns of table "service"
"""
input service_var_pop_order_by {
  """
  L'année correspondant au service.
  """
  annee: order_by

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: order_by

  """
  L'identifiant unique du service.
  """
  id: order_by
}

"""
aggregate var_samp on columns
"""
type service_var_samp_fields {
  """
  L'année correspondant au service.
  """
  annee: Float

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: Float

  """
  L'identifiant unique du service.
  """
  id: Float
}

"""
order by var_samp() on columns of table "service"
"""
input service_var_samp_order_by {
  """
  L'année correspondant au service.
  """
  annee: order_by

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: order_by

  """
  L'identifiant unique du service.
  """
  id: order_by
}

"""
aggregate variance on columns
"""
type service_variance_fields {
  """
  L'année correspondant au service.
  """
  annee: Float

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: Float

  """
  L'identifiant unique du service.
  """
  id: Float
}

"""
order by variance() on columns of table "service"
"""
input service_variance_order_by {
  """
  L'année correspondant au service.
  """
  annee: order_by

  """
  Le nombre d'heures EQTD du service.
  """
  heures_eqtd: order_by

  """
  L'identifiant unique du service.
  """
  id: order_by
}

type subscription_root {
  """
  fetch data from the table: "annee"
  """
  annee(
    """
    distinct select on columns
    """
    distinct_on: [annee_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [annee_order_by!]

    """
    filter the rows returned
    """
    where: annee_bool_exp
  ): [annee!]!

  """
  fetch aggregated fields from the table: "annee"
  """
  annee_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [annee_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [annee_order_by!]

    """
    filter the rows returned
    """
    where: annee_bool_exp
  ): annee_aggregate!

  """
  fetch data from the table: "annee" using primary key columns
  """
  annee_by_pk(
    """
    Le numéro de l'année (unique).
    """
    value: Int!
  ): annee

  """
  fetch data from the table in a streaming manner: "annee"
  """
  annee_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [annee_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: annee_bool_exp
  ): [annee!]!

  """
  fetch data from the table: "cursus"
  """
  cursus(
    """
    distinct select on columns
    """
    distinct_on: [cursus_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [cursus_order_by!]

    """
    filter the rows returned
    """
    where: cursus_bool_exp
  ): [cursus!]!

  """
  fetch aggregated fields from the table: "cursus"
  """
  cursus_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [cursus_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [cursus_order_by!]

    """
    filter the rows returned
    """
    where: cursus_bool_exp
  ): cursus_aggregate!

  """
  fetch data from the table: "cursus" using primary key columns
  """
  cursus_by_pk(
    """
    L'identifiant unique du cursus.
    """
    id: Int!
  ): cursus

  """
  fetch data from the table in a streaming manner: "cursus"
  """
  cursus_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [cursus_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: cursus_bool_exp
  ): [cursus!]!

  """
  fetch data from the table: "demande"
  """
  demande(
    """
    distinct select on columns
    """
    distinct_on: [demande_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [demande_order_by!]

    """
    filter the rows returned
    """
    where: demande_bool_exp
  ): [demande!]!

  """
  fetch aggregated fields from the table: "demande"
  """
  demande_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [demande_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [demande_order_by!]

    """
    filter the rows returned
    """
    where: demande_bool_exp
  ): demande_aggregate!

  """
  fetch data from the table: "demande" using primary key columns
  """
  demande_by_pk(id: Int!): demande

  """
  fetch data from the table in a streaming manner: "demande"
  """
  demande_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [demande_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: demande_bool_exp
  ): [demande!]!

  """
  fetch data from the table: "enseignement"
  """
  enseignement(
    """
    distinct select on columns
    """
    distinct_on: [enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [enseignement_order_by!]

    """
    filter the rows returned
    """
    where: enseignement_bool_exp
  ): [enseignement!]!

  """
  fetch aggregated fields from the table: "enseignement"
  """
  enseignement_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [enseignement_order_by!]

    """
    filter the rows returned
    """
    where: enseignement_bool_exp
  ): enseignement_aggregate!

  """
  fetch data from the table: "enseignement" using primary key columns
  """
  enseignement_by_pk(
    """
    L'identifiant unique de l'enseignement.
    """
    id: Int!
  ): enseignement

  """
  fetch data from the table in a streaming manner: "enseignement"
  """
  enseignement_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [enseignement_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: enseignement_bool_exp
  ): [enseignement!]!

  """
  fetch data from the table: "intervenant"
  """
  intervenant(
    """
    distinct select on columns
    """
    distinct_on: [intervenant_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [intervenant_order_by!]

    """
    filter the rows returned
    """
    where: intervenant_bool_exp
  ): [intervenant!]!

  """
  fetch aggregated fields from the table: "intervenant"
  """
  intervenant_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [intervenant_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [intervenant_order_by!]

    """
    filter the rows returned
    """
    where: intervenant_bool_exp
  ): intervenant_aggregate!

  """
  fetch data from the table: "intervenant" using primary key columns
  """
  intervenant_by_pk(
    """
    L'identifiant unique de l'intervenant.
    """
    uid: String!
  ): intervenant

  """
  fetch data from the table in a streaming manner: "intervenant"
  """
  intervenant_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [intervenant_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: intervenant_bool_exp
  ): [intervenant!]!

  """
  fetch data from the table: "mention"
  """
  mention(
    """
    distinct select on columns
    """
    distinct_on: [mention_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [mention_order_by!]

    """
    filter the rows returned
    """
    where: mention_bool_exp
  ): [mention!]!

  """
  fetch aggregated fields from the table: "mention"
  """
  mention_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [mention_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [mention_order_by!]

    """
    filter the rows returned
    """
    where: mention_bool_exp
  ): mention_aggregate!

  """
  fetch data from the table: "mention" using primary key columns
  """
  mention_by_pk(
    """
    L'identifiant unique de la mention.
    """
    id: Int!
  ): mention

  """
  fetch data from the table in a streaming manner: "mention"
  """
  mention_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [mention_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: mention_bool_exp
  ): [mention!]!

  """
  fetch data from the table: "message"
  """
  message(
    """
    distinct select on columns
    """
    distinct_on: [message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [message_order_by!]

    """
    filter the rows returned
    """
    where: message_bool_exp
  ): [message!]!

  """
  fetch aggregated fields from the table: "message"
  """
  message_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [message_order_by!]

    """
    filter the rows returned
    """
    where: message_bool_exp
  ): message_aggregate!

  """
  fetch data from the table: "message" using primary key columns
  """
  message_by_pk(
    """
    L'identifiant unique du message.
    """
    id: Int!
  ): message

  """
  fetch data from the table in a streaming manner: "message"
  """
  message_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [message_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: message_bool_exp
  ): [message!]!

  """
  fetch data from the table: "modification_service"
  """
  modification_service(
    """
    distinct select on columns
    """
    distinct_on: [modification_service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [modification_service_order_by!]

    """
    filter the rows returned
    """
    where: modification_service_bool_exp
  ): [modification_service!]!

  """
  fetch aggregated fields from the table: "modification_service"
  """
  modification_service_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [modification_service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [modification_service_order_by!]

    """
    filter the rows returned
    """
    where: modification_service_bool_exp
  ): modification_service_aggregate!

  """
  fetch data from the table: "modification_service" using primary key columns
  """
  modification_service_by_pk(
    """
    L'identifiant unique de la modification.
    """
    id: Int!
  ): modification_service

  """
  fetch data from the table in a streaming manner: "modification_service"
  """
  modification_service_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [modification_service_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: modification_service_bool_exp
  ): [modification_service!]!

  """
  An array relationship
  """
  parcours(
    """
    distinct select on columns
    """
    distinct_on: [parcours_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [parcours_order_by!]

    """
    filter the rows returned
    """
    where: parcours_bool_exp
  ): [parcours!]!

  """
  An aggregate relationship
  """
  parcours_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [parcours_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [parcours_order_by!]

    """
    filter the rows returned
    """
    where: parcours_bool_exp
  ): parcours_aggregate!

  """
  fetch data from the table: "parcours" using primary key columns
  """
  parcours_by_pk(
    """
    L'identifiant unique du parcours.
    """
    id: Int!
  ): parcours

  """
  fetch data from the table in a streaming manner: "parcours"
  """
  parcours_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [parcours_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: parcours_bool_exp
  ): [parcours!]!

  """
  fetch data from the table: "phase"
  """
  phase(
    """
    distinct select on columns
    """
    distinct_on: [phase_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [phase_order_by!]

    """
    filter the rows returned
    """
    where: phase_bool_exp
  ): [phase!]!

  """
  fetch aggregated fields from the table: "phase"
  """
  phase_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [phase_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [phase_order_by!]

    """
    filter the rows returned
    """
    where: phase_bool_exp
  ): phase_aggregate!

  """
  fetch data from the table: "phase" using primary key columns
  """
  phase_by_pk(
    """
    Le nom de la phase (unique).
    """
    value: String!
  ): phase

  """
  fetch data from the table in a streaming manner: "phase"
  """
  phase_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [phase_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: phase_bool_exp
  ): [phase!]!

  """
  fetch data from the table: "priorite"
  """
  priorite(
    """
    distinct select on columns
    """
    distinct_on: [priorite_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [priorite_order_by!]

    """
    filter the rows returned
    """
    where: priorite_bool_exp
  ): [priorite!]!

  """
  fetch aggregated fields from the table: "priorite"
  """
  priorite_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [priorite_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [priorite_order_by!]

    """
    filter the rows returned
    """
    where: priorite_bool_exp
  ): priorite_aggregate!

  """
  fetch data from the table: "priorite" using primary key columns
  """
  priorite_by_pk(id: Int!): priorite

  """
  fetch data from the table in a streaming manner: "priorite"
  """
  priorite_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [priorite_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: priorite_bool_exp
  ): [priorite!]!

  """
  fetch data from the table: "responsable"
  """
  responsable(
    """
    distinct select on columns
    """
    distinct_on: [responsable_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [responsable_order_by!]

    """
    filter the rows returned
    """
    where: responsable_bool_exp
  ): [responsable!]!

  """
  fetch aggregated fields from the table: "responsable"
  """
  responsable_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [responsable_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [responsable_order_by!]

    """
    filter the rows returned
    """
    where: responsable_bool_exp
  ): responsable_aggregate!

  """
  fetch data from the table: "responsable" using primary key columns
  """
  responsable_by_pk(id: Int!): responsable

  """
  fetch data from the table in a streaming manner: "responsable"
  """
  responsable_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [responsable_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: responsable_bool_exp
  ): [responsable!]!

  """
  fetch data from the table: "service"
  """
  service(
    """
    distinct select on columns
    """
    distinct_on: [service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [service_order_by!]

    """
    filter the rows returned
    """
    where: service_bool_exp
  ): [service!]!

  """
  fetch aggregated fields from the table: "service"
  """
  service_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [service_order_by!]

    """
    filter the rows returned
    """
    where: service_bool_exp
  ): service_aggregate!

  """
  fetch data from the table: "service" using primary key columns
  """
  service_by_pk(
    """
    L'identifiant unique du service.
    """
    id: Int!
  ): service

  """
  fetch data from the table in a streaming manner: "service"
  """
  service_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [service_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: service_bool_exp
  ): [service!]!

  """
  fetch data from the table: "type_demande"
  """
  type_demande(
    """
    distinct select on columns
    """
    distinct_on: [type_demande_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [type_demande_order_by!]

    """
    filter the rows returned
    """
    where: type_demande_bool_exp
  ): [type_demande!]!

  """
  fetch aggregated fields from the table: "type_demande"
  """
  type_demande_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [type_demande_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [type_demande_order_by!]

    """
    filter the rows returned
    """
    where: type_demande_bool_exp
  ): type_demande_aggregate!

  """
  fetch data from the table: "type_demande" using primary key columns
  """
  type_demande_by_pk(
    """
    Le type de demande (unique).
    """
    value: String!
  ): type_demande

  """
  fetch data from the table in a streaming manner: "type_demande"
  """
  type_demande_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [type_demande_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: type_demande_bool_exp
  ): [type_demande!]!

  """
  fetch data from the table: "type_enseignement"
  """
  type_enseignement(
    """
    distinct select on columns
    """
    distinct_on: [type_enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [type_enseignement_order_by!]

    """
    filter the rows returned
    """
    where: type_enseignement_bool_exp
  ): [type_enseignement!]!

  """
  fetch aggregated fields from the table: "type_enseignement"
  """
  type_enseignement_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [type_enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [type_enseignement_order_by!]

    """
    filter the rows returned
    """
    where: type_enseignement_bool_exp
  ): type_enseignement_aggregate!

  """
  fetch data from the table: "type_enseignement" using primary key columns
  """
  type_enseignement_by_pk(
    """
    Le type d'enseignement (unique).
    """
    label: String!
  ): type_enseignement

  """
  fetch data from the table in a streaming manner: "type_enseignement"
  """
  type_enseignement_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [type_enseignement_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: type_enseignement_bool_exp
  ): [type_enseignement!]!

  """
  fetch data from the table: "type_modification"
  """
  type_modification(
    """
    distinct select on columns
    """
    distinct_on: [type_modification_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [type_modification_order_by!]

    """
    filter the rows returned
    """
    where: type_modification_bool_exp
  ): [type_modification!]!

  """
  fetch aggregated fields from the table: "type_modification"
  """
  type_modification_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [type_modification_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [type_modification_order_by!]

    """
    filter the rows returned
    """
    where: type_modification_bool_exp
  ): type_modification_aggregate!

  """
  fetch data from the table: "type_modification" using primary key columns
  """
  type_modification_by_pk(
    """
    Le type de modification (unique).
    """
    label: String!
  ): type_modification

  """
  fetch data from the table in a streaming manner: "type_modification"
  """
  type_modification_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [type_modification_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: type_modification_bool_exp
  ): [type_modification!]!
}

"""
Table contenant les différents types de demande (principale, secondaire, attribution).
"""
type type_demande {
  """
  An array relationship
  """
  demandes(
    """
    distinct select on columns
    """
    distinct_on: [demande_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [demande_order_by!]

    """
    filter the rows returned
    """
    where: demande_bool_exp
  ): [demande!]!

  """
  An aggregate relationship
  """
  demandes_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [demande_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [demande_order_by!]

    """
    filter the rows returned
    """
    where: demande_bool_exp
  ): demande_aggregate!

  """
  Une brève description.
  """
  description: String

  """
  Le type de demande (unique).
  """
  value: String!
}

"""
aggregated selection of "type_demande"
"""
type type_demande_aggregate {
  aggregate: type_demande_aggregate_fields
  nodes: [type_demande!]!
}

"""
aggregate fields of "type_demande"
"""
type type_demande_aggregate_fields {
  count(columns: [type_demande_select_column!], distinct: Boolean): Int!
  max: type_demande_max_fields
  min: type_demande_min_fields
}

"""
Boolean expression to filter rows from the table "type_demande". All fields are combined with a logical 'AND'.
"""
input type_demande_bool_exp {
  _and: [type_demande_bool_exp!]
  _not: type_demande_bool_exp
  _or: [type_demande_bool_exp!]
  demandes: demande_bool_exp
  demandes_aggregate: demande_aggregate_bool_exp
  description: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "type_demande"
"""
enum type_demande_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  type_demande_pkey
}

"""
input type for inserting data into table "type_demande"
"""
input type_demande_insert_input {
  demandes: demande_arr_rel_insert_input

  """
  Une brève description.
  """
  description: String

  """
  Le type de demande (unique).
  """
  value: String
}

"""
aggregate max on columns
"""
type type_demande_max_fields {
  """
  Une brève description.
  """
  description: String

  """
  Le type de demande (unique).
  """
  value: String
}

"""
aggregate min on columns
"""
type type_demande_min_fields {
  """
  Une brève description.
  """
  description: String

  """
  Le type de demande (unique).
  """
  value: String
}

"""
response of any mutation on the table "type_demande"
"""
type type_demande_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [type_demande!]!
}

"""
input type for inserting object relation for remote table "type_demande"
"""
input type_demande_obj_rel_insert_input {
  data: type_demande_insert_input!

  """
  upsert condition
  """
  on_conflict: type_demande_on_conflict
}

"""
on_conflict condition type for table "type_demande"
"""
input type_demande_on_conflict {
  constraint: type_demande_constraint!
  update_columns: [type_demande_update_column!]! = []
  where: type_demande_bool_exp
}

"""
Ordering options when selecting data from "type_demande".
"""
input type_demande_order_by {
  demandes_aggregate: demande_aggregate_order_by
  description: order_by
  value: order_by
}

"""
primary key columns input for table: type_demande
"""
input type_demande_pk_columns_input {
  """
  Le type de demande (unique).
  """
  value: String!
}

"""
select columns of table "type_demande"
"""
enum type_demande_select_column {
  """
  column name
  """
  description

  """
  column name
  """
  value
}

"""
input type for updating data in table "type_demande"
"""
input type_demande_set_input {
  """
  Une brève description.
  """
  description: String

  """
  Le type de demande (unique).
  """
  value: String
}

"""
Streaming cursor of the table "type_demande"
"""
input type_demande_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: type_demande_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input type_demande_stream_cursor_value_input {
  """
  Une brève description.
  """
  description: String

  """
  Le type de demande (unique).
  """
  value: String
}

"""
update columns of table "type_demande"
"""
enum type_demande_update_column {
  """
  column name
  """
  description

  """
  column name
  """
  value
}

input type_demande_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: type_demande_set_input

  """
  filter the rows which have to be updated
  """
  where: type_demande_bool_exp!
}

"""
Table contenant les différents types d'enseignement (CM, TD, etc.).
"""
type type_enseignement {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float!

  """
  An array relationship
  """
  enseignements(
    """
    distinct select on columns
    """
    distinct_on: [enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [enseignement_order_by!]

    """
    filter the rows returned
    """
    where: enseignement_bool_exp
  ): [enseignement!]!

  """
  An aggregate relationship
  """
  enseignements_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [enseignement_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [enseignement_order_by!]

    """
    filter the rows returned
    """
    where: enseignement_bool_exp
  ): enseignement_aggregate!

  """
  Le type d'enseignement (unique).
  """
  label: String!

  """
  Le nom abrégé (optionnel).
  """
  label_court: String
}

"""
aggregated selection of "type_enseignement"
"""
type type_enseignement_aggregate {
  aggregate: type_enseignement_aggregate_fields
  nodes: [type_enseignement!]!
}

"""
aggregate fields of "type_enseignement"
"""
type type_enseignement_aggregate_fields {
  avg: type_enseignement_avg_fields
  count(columns: [type_enseignement_select_column!], distinct: Boolean): Int!
  max: type_enseignement_max_fields
  min: type_enseignement_min_fields
  stddev: type_enseignement_stddev_fields
  stddev_pop: type_enseignement_stddev_pop_fields
  stddev_samp: type_enseignement_stddev_samp_fields
  sum: type_enseignement_sum_fields
  var_pop: type_enseignement_var_pop_fields
  var_samp: type_enseignement_var_samp_fields
  variance: type_enseignement_variance_fields
}

"""
aggregate avg on columns
"""
type type_enseignement_avg_fields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""
Boolean expression to filter rows from the table "type_enseignement". All fields are combined with a logical 'AND'.
"""
input type_enseignement_bool_exp {
  _and: [type_enseignement_bool_exp!]
  _not: type_enseignement_bool_exp
  _or: [type_enseignement_bool_exp!]
  coefficient: Float_comparison_exp
  enseignements: enseignement_bool_exp
  enseignements_aggregate: enseignement_aggregate_bool_exp
  label: String_comparison_exp
  label_court: String_comparison_exp
}

"""
unique or primary key constraints on table "type_enseignement"
"""
enum type_enseignement_constraint {
  """
  unique or primary key constraint on columns "label"
  """
  type_enseignement_pkey
}

"""
input type for incrementing numeric columns in table "type_enseignement"
"""
input type_enseignement_inc_input {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""
input type for inserting data into table "type_enseignement"
"""
input type_enseignement_insert_input {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
  enseignements: enseignement_arr_rel_insert_input

  """
  Le type d'enseignement (unique).
  """
  label: String

  """
  Le nom abrégé (optionnel).
  """
  label_court: String
}

"""
aggregate max on columns
"""
type type_enseignement_max_fields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float

  """
  Le type d'enseignement (unique).
  """
  label: String

  """
  Le nom abrégé (optionnel).
  """
  label_court: String
}

"""
aggregate min on columns
"""
type type_enseignement_min_fields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float

  """
  Le type d'enseignement (unique).
  """
  label: String

  """
  Le nom abrégé (optionnel).
  """
  label_court: String
}

"""
response of any mutation on the table "type_enseignement"
"""
type type_enseignement_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [type_enseignement!]!
}

"""
input type for inserting object relation for remote table "type_enseignement"
"""
input type_enseignement_obj_rel_insert_input {
  data: type_enseignement_insert_input!

  """
  upsert condition
  """
  on_conflict: type_enseignement_on_conflict
}

"""
on_conflict condition type for table "type_enseignement"
"""
input type_enseignement_on_conflict {
  constraint: type_enseignement_constraint!
  update_columns: [type_enseignement_update_column!]! = []
  where: type_enseignement_bool_exp
}

"""
Ordering options when selecting data from "type_enseignement".
"""
input type_enseignement_order_by {
  coefficient: order_by
  enseignements_aggregate: enseignement_aggregate_order_by
  label: order_by
  label_court: order_by
}

"""
primary key columns input for table: type_enseignement
"""
input type_enseignement_pk_columns_input {
  """
  Le type d'enseignement (unique).
  """
  label: String!
}

"""
select columns of table "type_enseignement"
"""
enum type_enseignement_select_column {
  """
  column name
  """
  coefficient

  """
  column name
  """
  label

  """
  column name
  """
  label_court
}

"""
input type for updating data in table "type_enseignement"
"""
input type_enseignement_set_input {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float

  """
  Le type d'enseignement (unique).
  """
  label: String

  """
  Le nom abrégé (optionnel).
  """
  label_court: String
}

"""
aggregate stddev on columns
"""
type type_enseignement_stddev_fields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""
aggregate stddev_pop on columns
"""
type type_enseignement_stddev_pop_fields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""
aggregate stddev_samp on columns
"""
type type_enseignement_stddev_samp_fields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""
Streaming cursor of the table "type_enseignement"
"""
input type_enseignement_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: type_enseignement_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input type_enseignement_stream_cursor_value_input {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float

  """
  Le type d'enseignement (unique).
  """
  label: String

  """
  Le nom abrégé (optionnel).
  """
  label_court: String
}

"""
aggregate sum on columns
"""
type type_enseignement_sum_fields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""
update columns of table "type_enseignement"
"""
enum type_enseignement_update_column {
  """
  column name
  """
  coefficient

  """
  column name
  """
  label

  """
  column name
  """
  label_court
}

input type_enseignement_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: type_enseignement_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: type_enseignement_set_input

  """
  filter the rows which have to be updated
  """
  where: type_enseignement_bool_exp!
}

"""
aggregate var_pop on columns
"""
type type_enseignement_var_pop_fields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""
aggregate var_samp on columns
"""
type type_enseignement_var_samp_fields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""
aggregate variance on columns
"""
type type_enseignement_variance_fields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""
Table contenant les différents types de modification de service.
"""
type type_modification {
  """
  Une brève description.
  """
  description: String

  """
  Le type de modification (unique).
  """
  label: String!

  """
  An array relationship
  """
  modifications(
    """
    distinct select on columns
    """
    distinct_on: [modification_service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [modification_service_order_by!]

    """
    filter the rows returned
    """
    where: modification_service_bool_exp
  ): [modification_service!]!

  """
  An aggregate relationship
  """
  modifications_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [modification_service_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [modification_service_order_by!]

    """
    filter the rows returned
    """
    where: modification_service_bool_exp
  ): modification_service_aggregate!
}

"""
aggregated selection of "type_modification"
"""
type type_modification_aggregate {
  aggregate: type_modification_aggregate_fields
  nodes: [type_modification!]!
}

"""
aggregate fields of "type_modification"
"""
type type_modification_aggregate_fields {
  count(columns: [type_modification_select_column!], distinct: Boolean): Int!
  max: type_modification_max_fields
  min: type_modification_min_fields
}

"""
Boolean expression to filter rows from the table "type_modification". All fields are combined with a logical 'AND'.
"""
input type_modification_bool_exp {
  _and: [type_modification_bool_exp!]
  _not: type_modification_bool_exp
  _or: [type_modification_bool_exp!]
  description: String_comparison_exp
  label: String_comparison_exp
  modifications: modification_service_bool_exp
  modifications_aggregate: modification_service_aggregate_bool_exp
}

"""
unique or primary key constraints on table "type_modification"
"""
enum type_modification_constraint {
  """
  unique or primary key constraint on columns "label"
  """
  type_modification_pkey
}

"""
input type for inserting data into table "type_modification"
"""
input type_modification_insert_input {
  """
  Une brève description.
  """
  description: String

  """
  Le type de modification (unique).
  """
  label: String
  modifications: modification_service_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type type_modification_max_fields {
  """
  Une brève description.
  """
  description: String

  """
  Le type de modification (unique).
  """
  label: String
}

"""
aggregate min on columns
"""
type type_modification_min_fields {
  """
  Une brève description.
  """
  description: String

  """
  Le type de modification (unique).
  """
  label: String
}

"""
response of any mutation on the table "type_modification"
"""
type type_modification_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [type_modification!]!
}

"""
input type for inserting object relation for remote table "type_modification"
"""
input type_modification_obj_rel_insert_input {
  data: type_modification_insert_input!

  """
  upsert condition
  """
  on_conflict: type_modification_on_conflict
}

"""
on_conflict condition type for table "type_modification"
"""
input type_modification_on_conflict {
  constraint: type_modification_constraint!
  update_columns: [type_modification_update_column!]! = []
  where: type_modification_bool_exp
}

"""
Ordering options when selecting data from "type_modification".
"""
input type_modification_order_by {
  description: order_by
  label: order_by
  modifications_aggregate: modification_service_aggregate_order_by
}

"""
primary key columns input for table: type_modification
"""
input type_modification_pk_columns_input {
  """
  Le type de modification (unique).
  """
  label: String!
}

"""
select columns of table "type_modification"
"""
enum type_modification_select_column {
  """
  column name
  """
  description

  """
  column name
  """
  label
}

"""
input type for updating data in table "type_modification"
"""
input type_modification_set_input {
  """
  Une brève description.
  """
  description: String

  """
  Le type de modification (unique).
  """
  label: String
}

"""
Streaming cursor of the table "type_modification"
"""
input type_modification_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: type_modification_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input type_modification_stream_cursor_value_input {
  """
  Une brève description.
  """
  description: String

  """
  Le type de modification (unique).
  """
  label: String
}

"""
update columns of table "type_modification"
"""
enum type_modification_update_column {
  """
  column name
  """
  description

  """
  column name
  """
  label
}

input type_modification_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: type_modification_set_input

  """
  filter the rows which have to be updated
  """
  where: type_modification_bool_exp!
}
