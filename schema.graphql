schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """refresh the cache entry"""
  refresh: Boolean! = false

  """measured in seconds"""
  ttl: Int! = 60
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input BooleanComparisonExp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _isNull: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Table containing coordinators of programs, tracks, or courses. Each row corresponds to exactly one of these three types of responsibility.
"""
type Coordination {
  """
  Additional information (optional, e.g., to specify year for program or track coordination).
  """
  comment: String

  """An object relationship"""
  course: Course

  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  courseId: Int

  """Unique identifier for the coordinator entry."""
  id: Int!

  """An object relationship"""
  program: Program

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  programId: Int

  """An object relationship"""
  teacher: Teacher!

  """An object relationship"""
  track: Track

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  trackId: Int

  """Teacher's identifier."""
  uid: String!
}

"""
aggregated selection of "coordination"
"""
type CoordinationAggregate {
  aggregate: CoordinationAggregateFields
  nodes: [Coordination!]!
}

input CoordinationAggregateBoolExp {
  count: coordinationAggregateBoolExpCount
}

"""
aggregate fields of "coordination"
"""
type CoordinationAggregateFields {
  avg: CoordinationAvgFields
  count(columns: [CoordinationSelectColumn!], distinct: Boolean): Int!
  max: CoordinationMaxFields
  min: CoordinationMinFields
  stddev: CoordinationStddevFields
  stddevPop: CoordinationStddevPopFields
  stddevSamp: CoordinationStddevSampFields
  sum: CoordinationSumFields
  varPop: CoordinationVarPopFields
  varSamp: CoordinationVarSampFields
  variance: CoordinationVarianceFields
}

"""
order by aggregate values of table "coordination"
"""
input CoordinationAggregateOrderBy {
  avg: CoordinationAvgOrderBy
  count: OrderBy
  max: CoordinationMaxOrderBy
  min: CoordinationMinOrderBy
  stddev: CoordinationStddevOrderBy
  stddevPop: CoordinationStddevPopOrderBy
  stddevSamp: CoordinationStddevSampOrderBy
  sum: CoordinationSumOrderBy
  varPop: CoordinationVarPopOrderBy
  varSamp: CoordinationVarSampOrderBy
  variance: CoordinationVarianceOrderBy
}

"""
input type for inserting array relation for remote table "coordination"
"""
input CoordinationArrRelInsertInput {
  data: [CoordinationInsertInput!]!

  """upsert condition"""
  onConflict: CoordinationOnConflict
}

"""aggregate avg on columns"""
type CoordinationAvgFields {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  courseId: Float

  """Unique identifier for the coordinator entry."""
  id: Float

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  programId: Float

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  trackId: Float
}

"""
order by avg() on columns of table "coordination"
"""
input CoordinationAvgOrderBy {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  courseId: OrderBy

  """Unique identifier for the coordinator entry."""
  id: OrderBy

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  programId: OrderBy

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  trackId: OrderBy
}

"""
Boolean expression to filter rows from the table "coordination". All fields are combined with a logical 'AND'.
"""
input CoordinationBoolExp {
  _and: [CoordinationBoolExp!]
  _not: CoordinationBoolExp
  _or: [CoordinationBoolExp!]
  comment: StringComparisonExp
  course: CourseBoolExp
  courseId: IntComparisonExp
  id: IntComparisonExp
  program: ProgramBoolExp
  programId: IntComparisonExp
  teacher: TeacherBoolExp
  track: TrackBoolExp
  trackId: IntComparisonExp
  uid: StringComparisonExp
}

"""
unique or primary key constraints on table "coordination"
"""
enum CoordinationConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  responsable_pkey

  """
  unique or primary key constraint on columns "track_id", "uid", "course_id", "program_id"
  """
  responsable_uid_ens_id_parcours_id_mention_id_key
}

"""
input type for incrementing numeric columns in table "coordination"
"""
input CoordinationIncInput {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  courseId: Int

  """Unique identifier for the coordinator entry."""
  id: Int

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  programId: Int

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  trackId: Int
}

"""
input type for inserting data into table "coordination"
"""
input CoordinationInsertInput {
  """
  Additional information (optional, e.g., to specify year for program or track coordination).
  """
  comment: String
  course: CourseObjRelInsertInput

  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  courseId: Int

  """Unique identifier for the coordinator entry."""
  id: Int
  program: ProgramObjRelInsertInput

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  programId: Int
  teacher: TeacherObjRelInsertInput
  track: TrackObjRelInsertInput

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  trackId: Int

  """Teacher's identifier."""
  uid: String
}

"""aggregate max on columns"""
type CoordinationMaxFields {
  """
  Additional information (optional, e.g., to specify year for program or track coordination).
  """
  comment: String

  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  courseId: Int

  """Unique identifier for the coordinator entry."""
  id: Int

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  programId: Int

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  trackId: Int

  """Teacher's identifier."""
  uid: String
}

"""
order by max() on columns of table "coordination"
"""
input CoordinationMaxOrderBy {
  """
  Additional information (optional, e.g., to specify year for program or track coordination).
  """
  comment: OrderBy

  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  courseId: OrderBy

  """Unique identifier for the coordinator entry."""
  id: OrderBy

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  programId: OrderBy

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  trackId: OrderBy

  """Teacher's identifier."""
  uid: OrderBy
}

"""aggregate min on columns"""
type CoordinationMinFields {
  """
  Additional information (optional, e.g., to specify year for program or track coordination).
  """
  comment: String

  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  courseId: Int

  """Unique identifier for the coordinator entry."""
  id: Int

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  programId: Int

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  trackId: Int

  """Teacher's identifier."""
  uid: String
}

"""
order by min() on columns of table "coordination"
"""
input CoordinationMinOrderBy {
  """
  Additional information (optional, e.g., to specify year for program or track coordination).
  """
  comment: OrderBy

  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  courseId: OrderBy

  """Unique identifier for the coordinator entry."""
  id: OrderBy

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  programId: OrderBy

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  trackId: OrderBy

  """Teacher's identifier."""
  uid: OrderBy
}

"""
response of any mutation on the table "coordination"
"""
type CoordinationMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Coordination!]!
}

"""
on_conflict condition type for table "coordination"
"""
input CoordinationOnConflict {
  constraint: CoordinationConstraint!
  updateColumns: [CoordinationUpdateColumn!]! = []
  where: CoordinationBoolExp
}

"""Ordering options when selecting data from "coordination"."""
input CoordinationOrderBy {
  comment: OrderBy
  course: CourseOrderBy
  courseId: OrderBy
  id: OrderBy
  program: ProgramOrderBy
  programId: OrderBy
  teacher: TeacherOrderBy
  track: TrackOrderBy
  trackId: OrderBy
  uid: OrderBy
}

"""primary key columns input for table: coordination"""
input CoordinationPkColumnsInput {
  """Unique identifier for the coordinator entry."""
  id: Int!
}

"""
select columns of table "coordination"
"""
enum CoordinationSelectColumn {
  """column name"""
  comment

  """column name"""
  courseId

  """column name"""
  id

  """column name"""
  programId

  """column name"""
  trackId

  """column name"""
  uid
}

"""
input type for updating data in table "coordination"
"""
input CoordinationSetInput {
  """
  Additional information (optional, e.g., to specify year for program or track coordination).
  """
  comment: String

  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  courseId: Int

  """Unique identifier for the coordinator entry."""
  id: Int

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  programId: Int

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  trackId: Int

  """Teacher's identifier."""
  uid: String
}

"""aggregate stddev on columns"""
type CoordinationStddevFields {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  courseId: Float

  """Unique identifier for the coordinator entry."""
  id: Float

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  programId: Float

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  trackId: Float
}

"""
order by stddev() on columns of table "coordination"
"""
input CoordinationStddevOrderBy {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  courseId: OrderBy

  """Unique identifier for the coordinator entry."""
  id: OrderBy

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  programId: OrderBy

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  trackId: OrderBy
}

"""aggregate stddevPop on columns"""
type CoordinationStddevPopFields {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  courseId: Float

  """Unique identifier for the coordinator entry."""
  id: Float

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  programId: Float

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  trackId: Float
}

"""
order by stddevPop() on columns of table "coordination"
"""
input CoordinationStddevPopOrderBy {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  courseId: OrderBy

  """Unique identifier for the coordinator entry."""
  id: OrderBy

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  programId: OrderBy

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  trackId: OrderBy
}

"""aggregate stddevSamp on columns"""
type CoordinationStddevSampFields {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  courseId: Float

  """Unique identifier for the coordinator entry."""
  id: Float

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  programId: Float

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  trackId: Float
}

"""
order by stddevSamp() on columns of table "coordination"
"""
input CoordinationStddevSampOrderBy {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  courseId: OrderBy

  """Unique identifier for the coordinator entry."""
  id: OrderBy

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  programId: OrderBy

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  trackId: OrderBy
}

"""
Streaming cursor of the table "coordination"
"""
input CoordinationStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: CoordinationStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input CoordinationStreamCursorValueInput {
  """
  Additional information (optional, e.g., to specify year for program or track coordination).
  """
  comment: String

  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  courseId: Int

  """Unique identifier for the coordinator entry."""
  id: Int

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  programId: Int

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  trackId: Int

  """Teacher's identifier."""
  uid: String
}

"""aggregate sum on columns"""
type CoordinationSumFields {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  courseId: Int

  """Unique identifier for the coordinator entry."""
  id: Int

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  programId: Int

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  trackId: Int
}

"""
order by sum() on columns of table "coordination"
"""
input CoordinationSumOrderBy {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  courseId: OrderBy

  """Unique identifier for the coordinator entry."""
  id: OrderBy

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  programId: OrderBy

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  trackId: OrderBy
}

"""
update columns of table "coordination"
"""
enum CoordinationUpdateColumn {
  """column name"""
  comment

  """column name"""
  courseId

  """column name"""
  id

  """column name"""
  programId

  """column name"""
  trackId

  """column name"""
  uid
}

input CoordinationUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: CoordinationIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: CoordinationSetInput

  """filter the rows which have to be updated"""
  where: CoordinationBoolExp!
}

"""aggregate varPop on columns"""
type CoordinationVarPopFields {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  courseId: Float

  """Unique identifier for the coordinator entry."""
  id: Float

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  programId: Float

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  trackId: Float
}

"""
order by varPop() on columns of table "coordination"
"""
input CoordinationVarPopOrderBy {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  courseId: OrderBy

  """Unique identifier for the coordinator entry."""
  id: OrderBy

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  programId: OrderBy

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  trackId: OrderBy
}

"""aggregate varSamp on columns"""
type CoordinationVarSampFields {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  courseId: Float

  """Unique identifier for the coordinator entry."""
  id: Float

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  programId: Float

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  trackId: Float
}

"""
order by varSamp() on columns of table "coordination"
"""
input CoordinationVarSampOrderBy {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  courseId: OrderBy

  """Unique identifier for the coordinator entry."""
  id: OrderBy

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  programId: OrderBy

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  trackId: OrderBy
}

"""aggregate variance on columns"""
type CoordinationVarianceFields {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  courseId: Float

  """Unique identifier for the coordinator entry."""
  id: Float

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  programId: Float

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  trackId: Float
}

"""
order by variance() on columns of table "coordination"
"""
input CoordinationVarianceOrderBy {
  """
  Course ID (optional, if and only if the row corresponds to course coordination).
  """
  courseId: OrderBy

  """Unique identifier for the coordinator entry."""
  id: OrderBy

  """
  Program ID (optional, if and only if the row corresponds to program coordination).
  """
  programId: OrderBy

  """
  Track ID (optional, if and only if the row corresponds to track coordination).
  """
  trackId: OrderBy
}

"""Table contenant les enseignements."""
type Course {
  """An array relationship"""
  coordinations(
    """distinct select on columns"""
    distinctOn: [CoordinationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CoordinationOrderBy!]

    """filter the rows returned"""
    where: CoordinationBoolExp
  ): [Coordination!]!

  """An aggregate relationship"""
  coordinationsAggregate(
    """distinct select on columns"""
    distinctOn: [CoordinationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CoordinationOrderBy!]

    """filter the rows returned"""
    where: CoordinationBoolExp
  ): CoordinationAggregate!

  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycleYear: Int!

  """Une description de l'enseignement."""
  description: String

  """An array relationship"""
  enfants(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): [Course!]!

  """An aggregate relationship"""
  enfantsAggregate(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): CourseAggregate!
  ensIdImport: String
  formationIdImport: String

  """Le nombre de groupes."""
  groups: Int!

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupsAdjusted: Int
  groupsEffective: Int

  """Le nombre d'heures d'enseignement par groupe."""
  hours: Float!

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hoursAdjusted: Float
  hoursEffective: Int

  """L'identifiant unique de l'enseignement."""
  id: Int!

  """Le nom de l'enseignement."""
  name: String!

  """Le nom abrégé (optionnel)"""
  nameShort: String
  nomImport: String

  """An object relationship"""
  parent: Course

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parentId: Int

  """An array relationship"""
  priorities(
    """distinct select on columns"""
    distinctOn: [PrioritySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PriorityOrderBy!]

    """filter the rows returned"""
    where: PriorityBoolExp
  ): [Priority!]!

  """An aggregate relationship"""
  prioritiesAggregate(
    """distinct select on columns"""
    distinctOn: [PrioritySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PriorityOrderBy!]

    """filter the rows returned"""
    where: PriorityBoolExp
  ): PriorityAggregate!

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priorityRule: Int

  """An object relationship"""
  program: Program!

  """L'identifiant de la mention de l'enseignement."""
  programId: Int!

  """An array relationship"""
  requests(
    """distinct select on columns"""
    distinctOn: [RequestSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RequestOrderBy!]

    """filter the rows returned"""
    where: RequestBoolExp
  ): [Request!]!

  """An aggregate relationship"""
  requestsAggregate(
    """distinct select on columns"""
    distinctOn: [RequestSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RequestOrderBy!]

    """filter the rows returned"""
    where: RequestBoolExp
  ): RequestAggregate!

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: Int!

  """
  A computed field, executes function "total_hours_effective"
  """
  totalHoursEffective: Float

  """An object relationship"""
  track: Track

  """L'identifiant du parcours de l'enseignement."""
  trackId: Int

  """Le type d'enseignement."""
  type: String!

  """An object relationship"""
  typeByType: CourseType!

  """
  Indique si l'enseignement correspondant est visible par les utilisateurs.
  """
  visible: Boolean!

  """L'année de l'enseignement."""
  year: Int!

  """An object relationship"""
  yearByYear: Year!
}

"""
aggregated selection of "course"
"""
type CourseAggregate {
  aggregate: CourseAggregateFields
  nodes: [Course!]!
}

input CourseAggregateBoolExp {
  bool_and: courseAggregateBoolExpBool_and
  bool_or: courseAggregateBoolExpBool_or
  count: courseAggregateBoolExpCount
}

"""
aggregate fields of "course"
"""
type CourseAggregateFields {
  avg: CourseAvgFields
  count(columns: [CourseSelectColumn!], distinct: Boolean): Int!
  max: CourseMaxFields
  min: CourseMinFields
  stddev: CourseStddevFields
  stddevPop: CourseStddevPopFields
  stddevSamp: CourseStddevSampFields
  sum: CourseSumFields
  varPop: CourseVarPopFields
  varSamp: CourseVarSampFields
  variance: CourseVarianceFields
}

"""
order by aggregate values of table "course"
"""
input CourseAggregateOrderBy {
  avg: CourseAvgOrderBy
  count: OrderBy
  max: CourseMaxOrderBy
  min: CourseMinOrderBy
  stddev: CourseStddevOrderBy
  stddevPop: CourseStddevPopOrderBy
  stddevSamp: CourseStddevSampOrderBy
  sum: CourseSumOrderBy
  varPop: CourseVarPopOrderBy
  varSamp: CourseVarSampOrderBy
  variance: CourseVarianceOrderBy
}

"""
input type for inserting array relation for remote table "course"
"""
input CourseArrRelInsertInput {
  data: [CourseInsertInput!]!

  """upsert condition"""
  onConflict: CourseOnConflict
}

"""aggregate avg on columns"""
type CourseAvgFields {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycleYear: Float

  """Le nombre de groupes."""
  groups: Float

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupsAdjusted: Float
  groupsEffective: Float

  """Le nombre d'heures d'enseignement par groupe."""
  hours: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hoursAdjusted: Float
  hoursEffective: Float

  """L'identifiant unique de l'enseignement."""
  id: Float

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parentId: Float

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priorityRule: Float

  """L'identifiant de la mention de l'enseignement."""
  programId: Float

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: Float

  """
  A computed field, executes function "total_hours_effective"
  """
  totalHoursEffective: Float

  """L'identifiant du parcours de l'enseignement."""
  trackId: Float

  """L'année de l'enseignement."""
  year: Float
}

"""
order by avg() on columns of table "course"
"""
input CourseAvgOrderBy {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycleYear: OrderBy

  """Le nombre de groupes."""
  groups: OrderBy

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupsAdjusted: OrderBy
  groupsEffective: OrderBy

  """Le nombre d'heures d'enseignement par groupe."""
  hours: OrderBy

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hoursAdjusted: OrderBy
  hoursEffective: OrderBy

  """L'identifiant unique de l'enseignement."""
  id: OrderBy

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parentId: OrderBy

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priorityRule: OrderBy

  """L'identifiant de la mention de l'enseignement."""
  programId: OrderBy

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: OrderBy

  """L'identifiant du parcours de l'enseignement."""
  trackId: OrderBy

  """L'année de l'enseignement."""
  year: OrderBy
}

"""
Boolean expression to filter rows from the table "course". All fields are combined with a logical 'AND'.
"""
input CourseBoolExp {
  _and: [CourseBoolExp!]
  _not: CourseBoolExp
  _or: [CourseBoolExp!]
  coordinations: CoordinationBoolExp
  coordinationsAggregate: CoordinationAggregateBoolExp
  cycleYear: IntComparisonExp
  description: StringComparisonExp
  enfants: CourseBoolExp
  enfantsAggregate: CourseAggregateBoolExp
  ensIdImport: StringComparisonExp
  formationIdImport: StringComparisonExp
  groups: IntComparisonExp
  groupsAdjusted: IntComparisonExp
  groupsEffective: IntComparisonExp
  hours: FloatComparisonExp
  hoursAdjusted: FloatComparisonExp
  hoursEffective: IntComparisonExp
  id: IntComparisonExp
  name: StringComparisonExp
  nameShort: StringComparisonExp
  nomImport: StringComparisonExp
  parent: CourseBoolExp
  parentId: IntComparisonExp
  priorities: PriorityBoolExp
  prioritiesAggregate: PriorityAggregateBoolExp
  priorityRule: IntComparisonExp
  program: ProgramBoolExp
  programId: IntComparisonExp
  requests: RequestBoolExp
  requestsAggregate: RequestAggregateBoolExp
  semester: IntComparisonExp
  totalHoursEffective: FloatComparisonExp
  track: TrackBoolExp
  trackId: IntComparisonExp
  type: StringComparisonExp
  typeByType: CourseTypeBoolExp
  visible: BooleanComparisonExp
  year: IntComparisonExp
  yearByYear: YearBoolExp
}

"""
unique or primary key constraints on table "course"
"""
enum CourseConstraint {
  """
  unique or primary key constraint on columns "track_id", "semester", "type", "program_id", "name", "year"
  """
  enseignement_annee_mention_id_parcours_id_nom_semestre_type_key

  """
  unique or primary key constraint on columns "ens_id_import"
  """
  enseignement_ens_id_import_key

  """
  unique or primary key constraint on columns "id"
  """
  enseignement_pkey
}

"""
input type for incrementing numeric columns in table "course"
"""
input CourseIncInput {
  """Le nombre de groupes."""
  groups: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupsAdjusted: Int

  """Le nombre d'heures d'enseignement par groupe."""
  hours: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hoursAdjusted: Float

  """L'identifiant unique de l'enseignement."""
  id: Int

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parentId: Int

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priorityRule: Int

  """L'identifiant de la mention de l'enseignement."""
  programId: Int

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: Int

  """L'identifiant du parcours de l'enseignement."""
  trackId: Int

  """L'année de l'enseignement."""
  year: Int
}

"""
input type for inserting data into table "course"
"""
input CourseInsertInput {
  coordinations: CoordinationArrRelInsertInput

  """Une description de l'enseignement."""
  description: String
  enfants: CourseArrRelInsertInput
  ensIdImport: String
  formationIdImport: String

  """Le nombre de groupes."""
  groups: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupsAdjusted: Int

  """Le nombre d'heures d'enseignement par groupe."""
  hours: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hoursAdjusted: Float

  """L'identifiant unique de l'enseignement."""
  id: Int

  """Le nom de l'enseignement."""
  name: String

  """Le nom abrégé (optionnel)"""
  nameShort: String
  nomImport: String
  parent: CourseObjRelInsertInput

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parentId: Int
  priorities: PriorityArrRelInsertInput

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priorityRule: Int
  program: ProgramObjRelInsertInput

  """L'identifiant de la mention de l'enseignement."""
  programId: Int
  requests: RequestArrRelInsertInput

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: Int
  track: TrackObjRelInsertInput

  """L'identifiant du parcours de l'enseignement."""
  trackId: Int

  """Le type d'enseignement."""
  type: String
  typeByType: CourseTypeObjRelInsertInput

  """
  Indique si l'enseignement correspondant est visible par les utilisateurs.
  """
  visible: Boolean

  """L'année de l'enseignement."""
  year: Int
  yearByYear: YearObjRelInsertInput
}

"""aggregate max on columns"""
type CourseMaxFields {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycleYear: Int

  """Une description de l'enseignement."""
  description: String
  ensIdImport: String
  formationIdImport: String

  """Le nombre de groupes."""
  groups: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupsAdjusted: Int
  groupsEffective: Int

  """Le nombre d'heures d'enseignement par groupe."""
  hours: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hoursAdjusted: Float
  hoursEffective: Int

  """L'identifiant unique de l'enseignement."""
  id: Int

  """Le nom de l'enseignement."""
  name: String

  """Le nom abrégé (optionnel)"""
  nameShort: String
  nomImport: String

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parentId: Int

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priorityRule: Int

  """L'identifiant de la mention de l'enseignement."""
  programId: Int

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: Int

  """
  A computed field, executes function "total_hours_effective"
  """
  totalHoursEffective: Float

  """L'identifiant du parcours de l'enseignement."""
  trackId: Int

  """Le type d'enseignement."""
  type: String

  """L'année de l'enseignement."""
  year: Int
}

"""
order by max() on columns of table "course"
"""
input CourseMaxOrderBy {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycleYear: OrderBy

  """Une description de l'enseignement."""
  description: OrderBy
  ensIdImport: OrderBy
  formationIdImport: OrderBy

  """Le nombre de groupes."""
  groups: OrderBy

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupsAdjusted: OrderBy
  groupsEffective: OrderBy

  """Le nombre d'heures d'enseignement par groupe."""
  hours: OrderBy

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hoursAdjusted: OrderBy
  hoursEffective: OrderBy

  """L'identifiant unique de l'enseignement."""
  id: OrderBy

  """Le nom de l'enseignement."""
  name: OrderBy

  """Le nom abrégé (optionnel)"""
  nameShort: OrderBy
  nomImport: OrderBy

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parentId: OrderBy

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priorityRule: OrderBy

  """L'identifiant de la mention de l'enseignement."""
  programId: OrderBy

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: OrderBy

  """L'identifiant du parcours de l'enseignement."""
  trackId: OrderBy

  """Le type d'enseignement."""
  type: OrderBy

  """L'année de l'enseignement."""
  year: OrderBy
}

"""aggregate min on columns"""
type CourseMinFields {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycleYear: Int

  """Une description de l'enseignement."""
  description: String
  ensIdImport: String
  formationIdImport: String

  """Le nombre de groupes."""
  groups: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupsAdjusted: Int
  groupsEffective: Int

  """Le nombre d'heures d'enseignement par groupe."""
  hours: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hoursAdjusted: Float
  hoursEffective: Int

  """L'identifiant unique de l'enseignement."""
  id: Int

  """Le nom de l'enseignement."""
  name: String

  """Le nom abrégé (optionnel)"""
  nameShort: String
  nomImport: String

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parentId: Int

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priorityRule: Int

  """L'identifiant de la mention de l'enseignement."""
  programId: Int

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: Int

  """
  A computed field, executes function "total_hours_effective"
  """
  totalHoursEffective: Float

  """L'identifiant du parcours de l'enseignement."""
  trackId: Int

  """Le type d'enseignement."""
  type: String

  """L'année de l'enseignement."""
  year: Int
}

"""
order by min() on columns of table "course"
"""
input CourseMinOrderBy {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycleYear: OrderBy

  """Une description de l'enseignement."""
  description: OrderBy
  ensIdImport: OrderBy
  formationIdImport: OrderBy

  """Le nombre de groupes."""
  groups: OrderBy

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupsAdjusted: OrderBy
  groupsEffective: OrderBy

  """Le nombre d'heures d'enseignement par groupe."""
  hours: OrderBy

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hoursAdjusted: OrderBy
  hoursEffective: OrderBy

  """L'identifiant unique de l'enseignement."""
  id: OrderBy

  """Le nom de l'enseignement."""
  name: OrderBy

  """Le nom abrégé (optionnel)"""
  nameShort: OrderBy
  nomImport: OrderBy

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parentId: OrderBy

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priorityRule: OrderBy

  """L'identifiant de la mention de l'enseignement."""
  programId: OrderBy

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: OrderBy

  """L'identifiant du parcours de l'enseignement."""
  trackId: OrderBy

  """Le type d'enseignement."""
  type: OrderBy

  """L'année de l'enseignement."""
  year: OrderBy
}

"""
response of any mutation on the table "course"
"""
type CourseMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Course!]!
}

"""
input type for inserting object relation for remote table "course"
"""
input CourseObjRelInsertInput {
  data: CourseInsertInput!

  """upsert condition"""
  onConflict: CourseOnConflict
}

"""
on_conflict condition type for table "course"
"""
input CourseOnConflict {
  constraint: CourseConstraint!
  updateColumns: [CourseUpdateColumn!]! = []
  where: CourseBoolExp
}

"""Ordering options when selecting data from "course"."""
input CourseOrderBy {
  coordinationsAggregate: CoordinationAggregateOrderBy
  cycleYear: OrderBy
  description: OrderBy
  enfantsAggregate: CourseAggregateOrderBy
  ensIdImport: OrderBy
  formationIdImport: OrderBy
  groups: OrderBy
  groupsAdjusted: OrderBy
  groupsEffective: OrderBy
  hours: OrderBy
  hoursAdjusted: OrderBy
  hoursEffective: OrderBy
  id: OrderBy
  name: OrderBy
  nameShort: OrderBy
  nomImport: OrderBy
  parent: CourseOrderBy
  parentId: OrderBy
  prioritiesAggregate: PriorityAggregateOrderBy
  priorityRule: OrderBy
  program: ProgramOrderBy
  programId: OrderBy
  requestsAggregate: RequestAggregateOrderBy
  semester: OrderBy
  totalHoursEffective: OrderBy
  track: TrackOrderBy
  trackId: OrderBy
  type: OrderBy
  typeByType: CourseTypeOrderBy
  visible: OrderBy
  year: OrderBy
  yearByYear: YearOrderBy
}

"""primary key columns input for table: course"""
input CoursePkColumnsInput {
  """L'identifiant unique de l'enseignement."""
  id: Int!
}

"""
select columns of table "course"
"""
enum CourseSelectColumn {
  """column name"""
  cycleYear

  """column name"""
  description

  """column name"""
  ensIdImport

  """column name"""
  formationIdImport

  """column name"""
  groups

  """column name"""
  groupsAdjusted

  """column name"""
  groupsEffective

  """column name"""
  hours

  """column name"""
  hoursAdjusted

  """column name"""
  hoursEffective

  """column name"""
  id

  """column name"""
  name

  """column name"""
  nameShort

  """column name"""
  nomImport

  """column name"""
  parentId

  """column name"""
  priorityRule

  """column name"""
  programId

  """column name"""
  semester

  """column name"""
  trackId

  """column name"""
  type

  """column name"""
  visible

  """column name"""
  year
}

"""
select "courseAggregateBoolExpBool_andArgumentsColumns" columns of table "course"
"""
enum CourseSelectColumnCourseAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  visible
}

"""
select "courseAggregateBoolExpBool_orArgumentsColumns" columns of table "course"
"""
enum CourseSelectColumnCourseAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  visible
}

"""
input type for updating data in table "course"
"""
input CourseSetInput {
  """Une description de l'enseignement."""
  description: String
  ensIdImport: String
  formationIdImport: String

  """Le nombre de groupes."""
  groups: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupsAdjusted: Int

  """Le nombre d'heures d'enseignement par groupe."""
  hours: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hoursAdjusted: Float

  """L'identifiant unique de l'enseignement."""
  id: Int

  """Le nom de l'enseignement."""
  name: String

  """Le nom abrégé (optionnel)"""
  nameShort: String
  nomImport: String

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parentId: Int

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priorityRule: Int

  """L'identifiant de la mention de l'enseignement."""
  programId: Int

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: Int

  """L'identifiant du parcours de l'enseignement."""
  trackId: Int

  """Le type d'enseignement."""
  type: String

  """
  Indique si l'enseignement correspondant est visible par les utilisateurs.
  """
  visible: Boolean

  """L'année de l'enseignement."""
  year: Int
}

"""aggregate stddev on columns"""
type CourseStddevFields {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycleYear: Float

  """Le nombre de groupes."""
  groups: Float

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupsAdjusted: Float
  groupsEffective: Float

  """Le nombre d'heures d'enseignement par groupe."""
  hours: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hoursAdjusted: Float
  hoursEffective: Float

  """L'identifiant unique de l'enseignement."""
  id: Float

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parentId: Float

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priorityRule: Float

  """L'identifiant de la mention de l'enseignement."""
  programId: Float

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: Float

  """
  A computed field, executes function "total_hours_effective"
  """
  totalHoursEffective: Float

  """L'identifiant du parcours de l'enseignement."""
  trackId: Float

  """L'année de l'enseignement."""
  year: Float
}

"""
order by stddev() on columns of table "course"
"""
input CourseStddevOrderBy {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycleYear: OrderBy

  """Le nombre de groupes."""
  groups: OrderBy

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupsAdjusted: OrderBy
  groupsEffective: OrderBy

  """Le nombre d'heures d'enseignement par groupe."""
  hours: OrderBy

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hoursAdjusted: OrderBy
  hoursEffective: OrderBy

  """L'identifiant unique de l'enseignement."""
  id: OrderBy

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parentId: OrderBy

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priorityRule: OrderBy

  """L'identifiant de la mention de l'enseignement."""
  programId: OrderBy

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: OrderBy

  """L'identifiant du parcours de l'enseignement."""
  trackId: OrderBy

  """L'année de l'enseignement."""
  year: OrderBy
}

"""aggregate stddevPop on columns"""
type CourseStddevPopFields {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycleYear: Float

  """Le nombre de groupes."""
  groups: Float

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupsAdjusted: Float
  groupsEffective: Float

  """Le nombre d'heures d'enseignement par groupe."""
  hours: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hoursAdjusted: Float
  hoursEffective: Float

  """L'identifiant unique de l'enseignement."""
  id: Float

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parentId: Float

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priorityRule: Float

  """L'identifiant de la mention de l'enseignement."""
  programId: Float

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: Float

  """
  A computed field, executes function "total_hours_effective"
  """
  totalHoursEffective: Float

  """L'identifiant du parcours de l'enseignement."""
  trackId: Float

  """L'année de l'enseignement."""
  year: Float
}

"""
order by stddevPop() on columns of table "course"
"""
input CourseStddevPopOrderBy {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycleYear: OrderBy

  """Le nombre de groupes."""
  groups: OrderBy

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupsAdjusted: OrderBy
  groupsEffective: OrderBy

  """Le nombre d'heures d'enseignement par groupe."""
  hours: OrderBy

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hoursAdjusted: OrderBy
  hoursEffective: OrderBy

  """L'identifiant unique de l'enseignement."""
  id: OrderBy

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parentId: OrderBy

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priorityRule: OrderBy

  """L'identifiant de la mention de l'enseignement."""
  programId: OrderBy

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: OrderBy

  """L'identifiant du parcours de l'enseignement."""
  trackId: OrderBy

  """L'année de l'enseignement."""
  year: OrderBy
}

"""aggregate stddevSamp on columns"""
type CourseStddevSampFields {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycleYear: Float

  """Le nombre de groupes."""
  groups: Float

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupsAdjusted: Float
  groupsEffective: Float

  """Le nombre d'heures d'enseignement par groupe."""
  hours: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hoursAdjusted: Float
  hoursEffective: Float

  """L'identifiant unique de l'enseignement."""
  id: Float

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parentId: Float

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priorityRule: Float

  """L'identifiant de la mention de l'enseignement."""
  programId: Float

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: Float

  """
  A computed field, executes function "total_hours_effective"
  """
  totalHoursEffective: Float

  """L'identifiant du parcours de l'enseignement."""
  trackId: Float

  """L'année de l'enseignement."""
  year: Float
}

"""
order by stddevSamp() on columns of table "course"
"""
input CourseStddevSampOrderBy {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycleYear: OrderBy

  """Le nombre de groupes."""
  groups: OrderBy

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupsAdjusted: OrderBy
  groupsEffective: OrderBy

  """Le nombre d'heures d'enseignement par groupe."""
  hours: OrderBy

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hoursAdjusted: OrderBy
  hoursEffective: OrderBy

  """L'identifiant unique de l'enseignement."""
  id: OrderBy

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parentId: OrderBy

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priorityRule: OrderBy

  """L'identifiant de la mention de l'enseignement."""
  programId: OrderBy

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: OrderBy

  """L'identifiant du parcours de l'enseignement."""
  trackId: OrderBy

  """L'année de l'enseignement."""
  year: OrderBy
}

"""
Streaming cursor of the table "course"
"""
input CourseStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: CourseStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input CourseStreamCursorValueInput {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycleYear: Int

  """Une description de l'enseignement."""
  description: String
  ensIdImport: String
  formationIdImport: String

  """Le nombre de groupes."""
  groups: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupsAdjusted: Int
  groupsEffective: Int

  """Le nombre d'heures d'enseignement par groupe."""
  hours: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hoursAdjusted: Float
  hoursEffective: Int

  """L'identifiant unique de l'enseignement."""
  id: Int

  """Le nom de l'enseignement."""
  name: String

  """Le nom abrégé (optionnel)"""
  nameShort: String
  nomImport: String

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parentId: Int

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priorityRule: Int

  """L'identifiant de la mention de l'enseignement."""
  programId: Int

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: Int

  """L'identifiant du parcours de l'enseignement."""
  trackId: Int

  """Le type d'enseignement."""
  type: String

  """
  Indique si l'enseignement correspondant est visible par les utilisateurs.
  """
  visible: Boolean

  """L'année de l'enseignement."""
  year: Int
}

"""aggregate sum on columns"""
type CourseSumFields {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycleYear: Int

  """Le nombre de groupes."""
  groups: Int

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupsAdjusted: Int
  groupsEffective: Int

  """Le nombre d'heures d'enseignement par groupe."""
  hours: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hoursAdjusted: Float
  hoursEffective: Int

  """L'identifiant unique de l'enseignement."""
  id: Int

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parentId: Int

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priorityRule: Int

  """L'identifiant de la mention de l'enseignement."""
  programId: Int

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: Int

  """
  A computed field, executes function "total_hours_effective"
  """
  totalHoursEffective: Float

  """L'identifiant du parcours de l'enseignement."""
  trackId: Int

  """L'année de l'enseignement."""
  year: Int
}

"""
order by sum() on columns of table "course"
"""
input CourseSumOrderBy {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycleYear: OrderBy

  """Le nombre de groupes."""
  groups: OrderBy

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupsAdjusted: OrderBy
  groupsEffective: OrderBy

  """Le nombre d'heures d'enseignement par groupe."""
  hours: OrderBy

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hoursAdjusted: OrderBy
  hoursEffective: OrderBy

  """L'identifiant unique de l'enseignement."""
  id: OrderBy

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parentId: OrderBy

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priorityRule: OrderBy

  """L'identifiant de la mention de l'enseignement."""
  programId: OrderBy

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: OrderBy

  """L'identifiant du parcours de l'enseignement."""
  trackId: OrderBy

  """L'année de l'enseignement."""
  year: OrderBy
}

"""Table contenant les différents types d'enseignement (CM, TD, etc.)."""
type CourseType {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float!

  """An array relationship"""
  courses(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): [Course!]!

  """An aggregate relationship"""
  coursesAggregate(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): CourseAggregate!
  description: String

  """Le libellé type d'enseignement."""
  label: String!

  """La clé du type d'enseignement (unique)."""
  value: String!
}

"""
aggregated selection of "course_type"
"""
type CourseTypeAggregate {
  aggregate: CourseTypeAggregateFields
  nodes: [CourseType!]!
}

"""
aggregate fields of "course_type"
"""
type CourseTypeAggregateFields {
  avg: CourseTypeAvgFields
  count(columns: [CourseTypeSelectColumn!], distinct: Boolean): Int!
  max: CourseTypeMaxFields
  min: CourseTypeMinFields
  stddev: CourseTypeStddevFields
  stddevPop: CourseTypeStddevPopFields
  stddevSamp: CourseTypeStddevSampFields
  sum: CourseTypeSumFields
  varPop: CourseTypeVarPopFields
  varSamp: CourseTypeVarSampFields
  variance: CourseTypeVarianceFields
}

"""aggregate avg on columns"""
type CourseTypeAvgFields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""
Boolean expression to filter rows from the table "course_type". All fields are combined with a logical 'AND'.
"""
input CourseTypeBoolExp {
  _and: [CourseTypeBoolExp!]
  _not: CourseTypeBoolExp
  _or: [CourseTypeBoolExp!]
  coefficient: FloatComparisonExp
  courses: CourseBoolExp
  coursesAggregate: CourseAggregateBoolExp
  description: StringComparisonExp
  label: StringComparisonExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "course_type"
"""
enum CourseTypeConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  type_enseignement_pkey
}

"""
input type for incrementing numeric columns in table "course_type"
"""
input CourseTypeIncInput {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""
input type for inserting data into table "course_type"
"""
input CourseTypeInsertInput {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
  courses: CourseArrRelInsertInput
  description: String

  """Le libellé type d'enseignement."""
  label: String

  """La clé du type d'enseignement (unique)."""
  value: String
}

"""aggregate max on columns"""
type CourseTypeMaxFields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
  description: String

  """Le libellé type d'enseignement."""
  label: String

  """La clé du type d'enseignement (unique)."""
  value: String
}

"""aggregate min on columns"""
type CourseTypeMinFields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
  description: String

  """Le libellé type d'enseignement."""
  label: String

  """La clé du type d'enseignement (unique)."""
  value: String
}

"""
response of any mutation on the table "course_type"
"""
type CourseTypeMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [CourseType!]!
}

"""
input type for inserting object relation for remote table "course_type"
"""
input CourseTypeObjRelInsertInput {
  data: CourseTypeInsertInput!

  """upsert condition"""
  onConflict: CourseTypeOnConflict
}

"""
on_conflict condition type for table "course_type"
"""
input CourseTypeOnConflict {
  constraint: CourseTypeConstraint!
  updateColumns: [CourseTypeUpdateColumn!]! = []
  where: CourseTypeBoolExp
}

"""Ordering options when selecting data from "course_type"."""
input CourseTypeOrderBy {
  coefficient: OrderBy
  coursesAggregate: CourseAggregateOrderBy
  description: OrderBy
  label: OrderBy
  value: OrderBy
}

"""primary key columns input for table: course_type"""
input CourseTypePkColumnsInput {
  """La clé du type d'enseignement (unique)."""
  value: String!
}

"""
select columns of table "course_type"
"""
enum CourseTypeSelectColumn {
  """column name"""
  coefficient

  """column name"""
  description

  """column name"""
  label

  """column name"""
  value
}

"""
input type for updating data in table "course_type"
"""
input CourseTypeSetInput {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
  description: String

  """Le libellé type d'enseignement."""
  label: String

  """La clé du type d'enseignement (unique)."""
  value: String
}

"""aggregate stddev on columns"""
type CourseTypeStddevFields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""aggregate stddevPop on columns"""
type CourseTypeStddevPopFields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""aggregate stddevSamp on columns"""
type CourseTypeStddevSampFields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""
Streaming cursor of the table "course_type"
"""
input CourseTypeStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: CourseTypeStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input CourseTypeStreamCursorValueInput {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
  description: String

  """Le libellé type d'enseignement."""
  label: String

  """La clé du type d'enseignement (unique)."""
  value: String
}

"""aggregate sum on columns"""
type CourseTypeSumFields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""
update columns of table "course_type"
"""
enum CourseTypeUpdateColumn {
  """column name"""
  coefficient

  """column name"""
  description

  """column name"""
  label

  """column name"""
  value
}

input CourseTypeUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: CourseTypeIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: CourseTypeSetInput

  """filter the rows which have to be updated"""
  where: CourseTypeBoolExp!
}

"""aggregate varPop on columns"""
type CourseTypeVarPopFields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""aggregate varSamp on columns"""
type CourseTypeVarSampFields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""aggregate variance on columns"""
type CourseTypeVarianceFields {
  """
  Le coefficient multiplicateur pour obtenir le nombre d'heures EQTD à partir du nombre d'heures d'enseignement de ce type.
  """
  coefficient: Float
}

"""
update columns of table "course"
"""
enum CourseUpdateColumn {
  """column name"""
  description

  """column name"""
  ensIdImport

  """column name"""
  formationIdImport

  """column name"""
  groups

  """column name"""
  groupsAdjusted

  """column name"""
  hours

  """column name"""
  hoursAdjusted

  """column name"""
  id

  """column name"""
  name

  """column name"""
  nameShort

  """column name"""
  nomImport

  """column name"""
  parentId

  """column name"""
  priorityRule

  """column name"""
  programId

  """column name"""
  semester

  """column name"""
  trackId

  """column name"""
  type

  """column name"""
  visible

  """column name"""
  year
}

input CourseUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: CourseIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: CourseSetInput

  """filter the rows which have to be updated"""
  where: CourseBoolExp!
}

"""aggregate varPop on columns"""
type CourseVarPopFields {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycleYear: Float

  """Le nombre de groupes."""
  groups: Float

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupsAdjusted: Float
  groupsEffective: Float

  """Le nombre d'heures d'enseignement par groupe."""
  hours: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hoursAdjusted: Float
  hoursEffective: Float

  """L'identifiant unique de l'enseignement."""
  id: Float

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parentId: Float

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priorityRule: Float

  """L'identifiant de la mention de l'enseignement."""
  programId: Float

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: Float

  """
  A computed field, executes function "total_hours_effective"
  """
  totalHoursEffective: Float

  """L'identifiant du parcours de l'enseignement."""
  trackId: Float

  """L'année de l'enseignement."""
  year: Float
}

"""
order by varPop() on columns of table "course"
"""
input CourseVarPopOrderBy {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycleYear: OrderBy

  """Le nombre de groupes."""
  groups: OrderBy

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupsAdjusted: OrderBy
  groupsEffective: OrderBy

  """Le nombre d'heures d'enseignement par groupe."""
  hours: OrderBy

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hoursAdjusted: OrderBy
  hoursEffective: OrderBy

  """L'identifiant unique de l'enseignement."""
  id: OrderBy

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parentId: OrderBy

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priorityRule: OrderBy

  """L'identifiant de la mention de l'enseignement."""
  programId: OrderBy

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: OrderBy

  """L'identifiant du parcours de l'enseignement."""
  trackId: OrderBy

  """L'année de l'enseignement."""
  year: OrderBy
}

"""aggregate varSamp on columns"""
type CourseVarSampFields {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycleYear: Float

  """Le nombre de groupes."""
  groups: Float

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupsAdjusted: Float
  groupsEffective: Float

  """Le nombre d'heures d'enseignement par groupe."""
  hours: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hoursAdjusted: Float
  hoursEffective: Float

  """L'identifiant unique de l'enseignement."""
  id: Float

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parentId: Float

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priorityRule: Float

  """L'identifiant de la mention de l'enseignement."""
  programId: Float

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: Float

  """
  A computed field, executes function "total_hours_effective"
  """
  totalHoursEffective: Float

  """L'identifiant du parcours de l'enseignement."""
  trackId: Float

  """L'année de l'enseignement."""
  year: Float
}

"""
order by varSamp() on columns of table "course"
"""
input CourseVarSampOrderBy {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycleYear: OrderBy

  """Le nombre de groupes."""
  groups: OrderBy

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupsAdjusted: OrderBy
  groupsEffective: OrderBy

  """Le nombre d'heures d'enseignement par groupe."""
  hours: OrderBy

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hoursAdjusted: OrderBy
  hoursEffective: OrderBy

  """L'identifiant unique de l'enseignement."""
  id: OrderBy

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parentId: OrderBy

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priorityRule: OrderBy

  """L'identifiant de la mention de l'enseignement."""
  programId: OrderBy

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: OrderBy

  """L'identifiant du parcours de l'enseignement."""
  trackId: OrderBy

  """L'année de l'enseignement."""
  year: OrderBy
}

"""aggregate variance on columns"""
type CourseVarianceFields {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycleYear: Float

  """Le nombre de groupes."""
  groups: Float

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupsAdjusted: Float
  groupsEffective: Float

  """Le nombre d'heures d'enseignement par groupe."""
  hours: Float

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hoursAdjusted: Float
  hoursEffective: Float

  """L'identifiant unique de l'enseignement."""
  id: Float

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parentId: Float

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priorityRule: Float

  """L'identifiant de la mention de l'enseignement."""
  programId: Float

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: Float

  """
  A computed field, executes function "total_hours_effective"
  """
  totalHoursEffective: Float

  """L'identifiant du parcours de l'enseignement."""
  trackId: Float

  """L'année de l'enseignement."""
  year: Float
}

"""
order by variance() on columns of table "course"
"""
input CourseVarianceOrderBy {
  """
  L'année du cycle universitaire durant laquelle l'enseignement a lieu (calculée automatiquement à partir du semestre).
  """
  cycleYear: OrderBy

  """Le nombre de groupes."""
  groups: OrderBy

  """
  Le nombre de groupes ouverts (optionnel, si différent du nombre de groupes initial).
  """
  groupsAdjusted: OrderBy
  groupsEffective: OrderBy

  """Le nombre d'heures d'enseignement par groupe."""
  hours: OrderBy

  """
  Le nombre d'heures d'enseignement ouvertes par groupe (optionnel, si différent du nombre d'heures d'enseignement initial).
  """
  hoursAdjusted: OrderBy
  hoursEffective: OrderBy

  """L'identifiant unique de l'enseignement."""
  id: OrderBy

  """
  L'identifiant de l'enseignement parent, c'est-à-dire le même cours l'année précédente (optionnel).
  """
  parentId: OrderBy

  """
  Une règle de priorité (optionnelle) : nombre d'année pendant lesquelles un intervenant est prioritaire sur un enseignement (3 par défaut ; 1 si pas de priorité d'une année sur l'autre ; 0 si pas limite de priorité).
  """
  priorityRule: OrderBy

  """L'identifiant de la mention de l'enseignement."""
  programId: OrderBy

  """Le semestre durant lequel l'enseignement a lieu."""
  semester: OrderBy

  """L'identifiant du parcours de l'enseignement."""
  trackId: OrderBy

  """L'année de l'enseignement."""
  year: OrderBy
}

"""ordering argument of a cursor"""
enum CursorOrdering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""Table contenant les différents cursus (licence, master, etc.)."""
type Degree {
  """L'identifiant unique du cursus."""
  id: Int!

  """Le nom du cursus (unique)."""
  name: String!

  """Le nom abrégé (optionnel)."""
  nameShort: String

  """An array relationship"""
  programs(
    """distinct select on columns"""
    distinctOn: [ProgramSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProgramOrderBy!]

    """filter the rows returned"""
    where: ProgramBoolExp
  ): [Program!]!

  """An aggregate relationship"""
  programsAggregate(
    """distinct select on columns"""
    distinctOn: [ProgramSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProgramOrderBy!]

    """filter the rows returned"""
    where: ProgramBoolExp
  ): ProgramAggregate!

  """Indique si le cursus correspondant est visible par les utilisateurs."""
  visible: Boolean!
}

"""
aggregated selection of "degree"
"""
type DegreeAggregate {
  aggregate: DegreeAggregateFields
  nodes: [Degree!]!
}

"""
aggregate fields of "degree"
"""
type DegreeAggregateFields {
  avg: DegreeAvgFields
  count(columns: [DegreeSelectColumn!], distinct: Boolean): Int!
  max: DegreeMaxFields
  min: DegreeMinFields
  stddev: DegreeStddevFields
  stddevPop: DegreeStddevPopFields
  stddevSamp: DegreeStddevSampFields
  sum: DegreeSumFields
  varPop: DegreeVarPopFields
  varSamp: DegreeVarSampFields
  variance: DegreeVarianceFields
}

"""aggregate avg on columns"""
type DegreeAvgFields {
  """L'identifiant unique du cursus."""
  id: Float
}

"""
Boolean expression to filter rows from the table "degree". All fields are combined with a logical 'AND'.
"""
input DegreeBoolExp {
  _and: [DegreeBoolExp!]
  _not: DegreeBoolExp
  _or: [DegreeBoolExp!]
  id: IntComparisonExp
  name: StringComparisonExp
  nameShort: StringComparisonExp
  programs: ProgramBoolExp
  programsAggregate: ProgramAggregateBoolExp
  visible: BooleanComparisonExp
}

"""
unique or primary key constraints on table "degree"
"""
enum DegreeConstraint {
  """
  unique or primary key constraint on columns "name"
  """
  cursus_nom_key

  """
  unique or primary key constraint on columns "id"
  """
  cursus_pkey
}

"""
input type for incrementing numeric columns in table "degree"
"""
input DegreeIncInput {
  """L'identifiant unique du cursus."""
  id: Int
}

"""
input type for inserting data into table "degree"
"""
input DegreeInsertInput {
  """L'identifiant unique du cursus."""
  id: Int

  """Le nom du cursus (unique)."""
  name: String

  """Le nom abrégé (optionnel)."""
  nameShort: String
  programs: ProgramArrRelInsertInput

  """Indique si le cursus correspondant est visible par les utilisateurs."""
  visible: Boolean
}

"""aggregate max on columns"""
type DegreeMaxFields {
  """L'identifiant unique du cursus."""
  id: Int

  """Le nom du cursus (unique)."""
  name: String

  """Le nom abrégé (optionnel)."""
  nameShort: String
}

"""aggregate min on columns"""
type DegreeMinFields {
  """L'identifiant unique du cursus."""
  id: Int

  """Le nom du cursus (unique)."""
  name: String

  """Le nom abrégé (optionnel)."""
  nameShort: String
}

"""
response of any mutation on the table "degree"
"""
type DegreeMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Degree!]!
}

"""
input type for inserting object relation for remote table "degree"
"""
input DegreeObjRelInsertInput {
  data: DegreeInsertInput!

  """upsert condition"""
  onConflict: DegreeOnConflict
}

"""
on_conflict condition type for table "degree"
"""
input DegreeOnConflict {
  constraint: DegreeConstraint!
  updateColumns: [DegreeUpdateColumn!]! = []
  where: DegreeBoolExp
}

"""Ordering options when selecting data from "degree"."""
input DegreeOrderBy {
  id: OrderBy
  name: OrderBy
  nameShort: OrderBy
  programsAggregate: ProgramAggregateOrderBy
  visible: OrderBy
}

"""primary key columns input for table: degree"""
input DegreePkColumnsInput {
  """L'identifiant unique du cursus."""
  id: Int!
}

"""
select columns of table "degree"
"""
enum DegreeSelectColumn {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  nameShort

  """column name"""
  visible
}

"""
input type for updating data in table "degree"
"""
input DegreeSetInput {
  """L'identifiant unique du cursus."""
  id: Int

  """Le nom du cursus (unique)."""
  name: String

  """Le nom abrégé (optionnel)."""
  nameShort: String

  """Indique si le cursus correspondant est visible par les utilisateurs."""
  visible: Boolean
}

"""aggregate stddev on columns"""
type DegreeStddevFields {
  """L'identifiant unique du cursus."""
  id: Float
}

"""aggregate stddevPop on columns"""
type DegreeStddevPopFields {
  """L'identifiant unique du cursus."""
  id: Float
}

"""aggregate stddevSamp on columns"""
type DegreeStddevSampFields {
  """L'identifiant unique du cursus."""
  id: Float
}

"""
Streaming cursor of the table "degree"
"""
input DegreeStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: DegreeStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input DegreeStreamCursorValueInput {
  """L'identifiant unique du cursus."""
  id: Int

  """Le nom du cursus (unique)."""
  name: String

  """Le nom abrégé (optionnel)."""
  nameShort: String

  """Indique si le cursus correspondant est visible par les utilisateurs."""
  visible: Boolean
}

"""aggregate sum on columns"""
type DegreeSumFields {
  """L'identifiant unique du cursus."""
  id: Int
}

"""
update columns of table "degree"
"""
enum DegreeUpdateColumn {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  nameShort

  """column name"""
  visible
}

input DegreeUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: DegreeIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: DegreeSetInput

  """filter the rows which have to be updated"""
  where: DegreeBoolExp!
}

"""aggregate varPop on columns"""
type DegreeVarPopFields {
  """L'identifiant unique du cursus."""
  id: Float
}

"""aggregate varSamp on columns"""
type DegreeVarSampFields {
  """L'identifiant unique du cursus."""
  id: Float
}

"""aggregate variance on columns"""
type DegreeVarianceFields {
  """L'identifiant unique du cursus."""
  id: Float
}

"""
Boolean expression to compare columns of type "Float". All fields are combined with logical 'AND'.
"""
input FloatComparisonExp {
  _eq: Float
  _gt: Float
  _gte: Float
  _in: [Float!]
  _isNull: Boolean
  _lt: Float
  _lte: Float
  _neq: Float
  _nin: [Float!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input IntComparisonExp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _isNull: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""column ordering options"""
enum OrderBy {
  """in ascending order, nulls last"""
  ASC

  """in ascending order, nulls first"""
  ASC_NULLS_FIRST

  """in ascending order, nulls last"""
  ASC_NULLS_LAST

  """in descending order, nulls first"""
  DESC

  """in descending order, nulls first"""
  DESC_NULLS_FIRST

  """in descending order, nulls last"""
  DESC_NULLS_LAST
}

"""
Table containing the different phases: requests, assignments, results, and shutdown.
"""
type Phase {
  """
  Indicates if this is the current phase (TRUE) or not (NULL). Only one phase can be current at a time.
  """
  current: Boolean

  """Une brève description."""
  description: String

  """Phase identifier."""
  value: String!
}

"""
aggregated selection of "phase"
"""
type PhaseAggregate {
  aggregate: PhaseAggregateFields
  nodes: [Phase!]!
}

"""
aggregate fields of "phase"
"""
type PhaseAggregateFields {
  count(columns: [PhaseSelectColumn!], distinct: Boolean): Int!
  max: PhaseMaxFields
  min: PhaseMinFields
}

"""
Boolean expression to filter rows from the table "phase". All fields are combined with a logical 'AND'.
"""
input PhaseBoolExp {
  _and: [PhaseBoolExp!]
  _not: PhaseBoolExp
  _or: [PhaseBoolExp!]
  current: BooleanComparisonExp
  description: StringComparisonExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "phase"
"""
enum PhaseConstraint {
  """
  unique or primary key constraint on columns "current"
  """
  phase_en_cours_key

  """
  unique or primary key constraint on columns "value"
  """
  phase_pkey
}

"""
input type for inserting data into table "phase"
"""
input PhaseInsertInput {
  """
  Indicates if this is the current phase (TRUE) or not (NULL). Only one phase can be current at a time.
  """
  current: Boolean

  """Une brève description."""
  description: String

  """Phase identifier."""
  value: String
}

"""aggregate max on columns"""
type PhaseMaxFields {
  """Une brève description."""
  description: String

  """Phase identifier."""
  value: String
}

"""aggregate min on columns"""
type PhaseMinFields {
  """Une brève description."""
  description: String

  """Phase identifier."""
  value: String
}

"""
response of any mutation on the table "phase"
"""
type PhaseMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Phase!]!
}

"""
on_conflict condition type for table "phase"
"""
input PhaseOnConflict {
  constraint: PhaseConstraint!
  updateColumns: [PhaseUpdateColumn!]! = []
  where: PhaseBoolExp
}

"""Ordering options when selecting data from "phase"."""
input PhaseOrderBy {
  current: OrderBy
  description: OrderBy
  value: OrderBy
}

"""primary key columns input for table: phase"""
input PhasePkColumnsInput {
  """Phase identifier."""
  value: String!
}

"""
select columns of table "phase"
"""
enum PhaseSelectColumn {
  """column name"""
  current

  """column name"""
  description

  """column name"""
  value
}

"""
input type for updating data in table "phase"
"""
input PhaseSetInput {
  """
  Indicates if this is the current phase (TRUE) or not (NULL). Only one phase can be current at a time.
  """
  current: Boolean

  """Une brève description."""
  description: String

  """Phase identifier."""
  value: String
}

"""
Streaming cursor of the table "phase"
"""
input PhaseStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PhaseStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PhaseStreamCursorValueInput {
  """
  Indicates if this is the current phase (TRUE) or not (NULL). Only one phase can be current at a time.
  """
  current: Boolean

  """Une brève description."""
  description: String

  """Phase identifier."""
  value: String
}

"""
update columns of table "phase"
"""
enum PhaseUpdateColumn {
  """column name"""
  current

  """column name"""
  description

  """column name"""
  value
}

input PhaseUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: PhaseSetInput

  """filter the rows which have to be updated"""
  where: PhaseBoolExp!
}

"""
columns and relationships of "position"
"""
type Position {
  baseServiceHours: Float
  description: String
  label: String!

  """An array relationship"""
  teachers(
    """distinct select on columns"""
    distinctOn: [TeacherSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TeacherOrderBy!]

    """filter the rows returned"""
    where: TeacherBoolExp
  ): [Teacher!]!

  """An aggregate relationship"""
  teachersAggregate(
    """distinct select on columns"""
    distinctOn: [TeacherSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TeacherOrderBy!]

    """filter the rows returned"""
    where: TeacherBoolExp
  ): TeacherAggregate!
  value: String!
}

"""
aggregated selection of "position"
"""
type PositionAggregate {
  aggregate: PositionAggregateFields
  nodes: [Position!]!
}

"""
aggregate fields of "position"
"""
type PositionAggregateFields {
  avg: PositionAvgFields
  count(columns: [PositionSelectColumn!], distinct: Boolean): Int!
  max: PositionMaxFields
  min: PositionMinFields
  stddev: PositionStddevFields
  stddevPop: PositionStddevPopFields
  stddevSamp: PositionStddevSampFields
  sum: PositionSumFields
  varPop: PositionVarPopFields
  varSamp: PositionVarSampFields
  variance: PositionVarianceFields
}

"""aggregate avg on columns"""
type PositionAvgFields {
  baseServiceHours: Float
}

"""
Boolean expression to filter rows from the table "position". All fields are combined with a logical 'AND'.
"""
input PositionBoolExp {
  _and: [PositionBoolExp!]
  _not: PositionBoolExp
  _or: [PositionBoolExp!]
  baseServiceHours: FloatComparisonExp
  description: StringComparisonExp
  label: StringComparisonExp
  teachers: TeacherBoolExp
  teachersAggregate: TeacherAggregateBoolExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "position"
"""
enum PositionConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  fonction_pkey
}

"""
input type for incrementing numeric columns in table "position"
"""
input PositionIncInput {
  baseServiceHours: Float
}

"""
input type for inserting data into table "position"
"""
input PositionInsertInput {
  baseServiceHours: Float
  description: String
  label: String
  teachers: TeacherArrRelInsertInput
  value: String
}

"""aggregate max on columns"""
type PositionMaxFields {
  baseServiceHours: Float
  description: String
  label: String
  value: String
}

"""aggregate min on columns"""
type PositionMinFields {
  baseServiceHours: Float
  description: String
  label: String
  value: String
}

"""
response of any mutation on the table "position"
"""
type PositionMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Position!]!
}

"""
input type for inserting object relation for remote table "position"
"""
input PositionObjRelInsertInput {
  data: PositionInsertInput!

  """upsert condition"""
  onConflict: PositionOnConflict
}

"""
on_conflict condition type for table "position"
"""
input PositionOnConflict {
  constraint: PositionConstraint!
  updateColumns: [PositionUpdateColumn!]! = []
  where: PositionBoolExp
}

"""Ordering options when selecting data from "position"."""
input PositionOrderBy {
  baseServiceHours: OrderBy
  description: OrderBy
  label: OrderBy
  teachersAggregate: TeacherAggregateOrderBy
  value: OrderBy
}

"""primary key columns input for table: position"""
input PositionPkColumnsInput {
  value: String!
}

"""
select columns of table "position"
"""
enum PositionSelectColumn {
  """column name"""
  baseServiceHours

  """column name"""
  description

  """column name"""
  label

  """column name"""
  value
}

"""
input type for updating data in table "position"
"""
input PositionSetInput {
  baseServiceHours: Float
  description: String
  label: String
  value: String
}

"""aggregate stddev on columns"""
type PositionStddevFields {
  baseServiceHours: Float
}

"""aggregate stddevPop on columns"""
type PositionStddevPopFields {
  baseServiceHours: Float
}

"""aggregate stddevSamp on columns"""
type PositionStddevSampFields {
  baseServiceHours: Float
}

"""
Streaming cursor of the table "position"
"""
input PositionStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PositionStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PositionStreamCursorValueInput {
  baseServiceHours: Float
  description: String
  label: String
  value: String
}

"""aggregate sum on columns"""
type PositionSumFields {
  baseServiceHours: Float
}

"""
update columns of table "position"
"""
enum PositionUpdateColumn {
  """column name"""
  baseServiceHours

  """column name"""
  description

  """column name"""
  label

  """column name"""
  value
}

input PositionUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: PositionIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: PositionSetInput

  """filter the rows which have to be updated"""
  where: PositionBoolExp!
}

"""aggregate varPop on columns"""
type PositionVarPopFields {
  baseServiceHours: Float
}

"""aggregate varSamp on columns"""
type PositionVarSampFields {
  baseServiceHours: Float
}

"""aggregate variance on columns"""
type PositionVarianceFields {
  baseServiceHours: Float
}

"""
Table containing information about teacher seniority and priority for courses.
"""
type Priority {
  """An object relationship"""
  course: Course!

  """Associated course ID."""
  courseId: Int!

  """Unique identifier for the priority entry."""
  id: Int!

  """Indicates if the teacher has priority for this course."""
  isPriority: Boolean

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: Int

  """An object relationship"""
  service: Service!

  """Associated service ID."""
  serviceId: Int!
}

"""
aggregated selection of "priority"
"""
type PriorityAggregate {
  aggregate: PriorityAggregateFields
  nodes: [Priority!]!
}

input PriorityAggregateBoolExp {
  bool_and: priorityAggregateBoolExpBool_and
  bool_or: priorityAggregateBoolExpBool_or
  count: priorityAggregateBoolExpCount
}

"""
aggregate fields of "priority"
"""
type PriorityAggregateFields {
  avg: PriorityAvgFields
  count(columns: [PrioritySelectColumn!], distinct: Boolean): Int!
  max: PriorityMaxFields
  min: PriorityMinFields
  stddev: PriorityStddevFields
  stddevPop: PriorityStddevPopFields
  stddevSamp: PriorityStddevSampFields
  sum: PrioritySumFields
  varPop: PriorityVarPopFields
  varSamp: PriorityVarSampFields
  variance: PriorityVarianceFields
}

"""
order by aggregate values of table "priority"
"""
input PriorityAggregateOrderBy {
  avg: PriorityAvgOrderBy
  count: OrderBy
  max: PriorityMaxOrderBy
  min: PriorityMinOrderBy
  stddev: PriorityStddevOrderBy
  stddevPop: PriorityStddevPopOrderBy
  stddevSamp: PriorityStddevSampOrderBy
  sum: PrioritySumOrderBy
  varPop: PriorityVarPopOrderBy
  varSamp: PriorityVarSampOrderBy
  variance: PriorityVarianceOrderBy
}

"""
input type for inserting array relation for remote table "priority"
"""
input PriorityArrRelInsertInput {
  data: [PriorityInsertInput!]!

  """upsert condition"""
  onConflict: PriorityOnConflict
}

"""aggregate avg on columns"""
type PriorityAvgFields {
  """Associated course ID."""
  courseId: Float

  """Unique identifier for the priority entry."""
  id: Float

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: Float

  """Associated service ID."""
  serviceId: Float
}

"""
order by avg() on columns of table "priority"
"""
input PriorityAvgOrderBy {
  """Associated course ID."""
  courseId: OrderBy

  """Unique identifier for the priority entry."""
  id: OrderBy

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: OrderBy

  """Associated service ID."""
  serviceId: OrderBy
}

"""
Boolean expression to filter rows from the table "priority". All fields are combined with a logical 'AND'.
"""
input PriorityBoolExp {
  _and: [PriorityBoolExp!]
  _not: PriorityBoolExp
  _or: [PriorityBoolExp!]
  course: CourseBoolExp
  courseId: IntComparisonExp
  id: IntComparisonExp
  isPriority: BooleanComparisonExp
  seniority: IntComparisonExp
  service: ServiceBoolExp
  serviceId: IntComparisonExp
}

"""
unique or primary key constraints on table "priority"
"""
enum PriorityConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  priorite_pkey

  """
  unique or primary key constraint on columns "course_id", "service_id"
  """
  priorite_service_id_ens_id_key
}

"""
input type for incrementing numeric columns in table "priority"
"""
input PriorityIncInput {
  """Associated course ID."""
  courseId: Int

  """Unique identifier for the priority entry."""
  id: Int

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: Int

  """Associated service ID."""
  serviceId: Int
}

"""
input type for inserting data into table "priority"
"""
input PriorityInsertInput {
  course: CourseObjRelInsertInput

  """Associated course ID."""
  courseId: Int

  """Unique identifier for the priority entry."""
  id: Int

  """Indicates if the teacher has priority for this course."""
  isPriority: Boolean

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: Int
  service: ServiceObjRelInsertInput

  """Associated service ID."""
  serviceId: Int
}

"""aggregate max on columns"""
type PriorityMaxFields {
  """Associated course ID."""
  courseId: Int

  """Unique identifier for the priority entry."""
  id: Int

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: Int

  """Associated service ID."""
  serviceId: Int
}

"""
order by max() on columns of table "priority"
"""
input PriorityMaxOrderBy {
  """Associated course ID."""
  courseId: OrderBy

  """Unique identifier for the priority entry."""
  id: OrderBy

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: OrderBy

  """Associated service ID."""
  serviceId: OrderBy
}

"""aggregate min on columns"""
type PriorityMinFields {
  """Associated course ID."""
  courseId: Int

  """Unique identifier for the priority entry."""
  id: Int

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: Int

  """Associated service ID."""
  serviceId: Int
}

"""
order by min() on columns of table "priority"
"""
input PriorityMinOrderBy {
  """Associated course ID."""
  courseId: OrderBy

  """Unique identifier for the priority entry."""
  id: OrderBy

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: OrderBy

  """Associated service ID."""
  serviceId: OrderBy
}

"""
response of any mutation on the table "priority"
"""
type PriorityMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Priority!]!
}

"""
on_conflict condition type for table "priority"
"""
input PriorityOnConflict {
  constraint: PriorityConstraint!
  updateColumns: [PriorityUpdateColumn!]! = []
  where: PriorityBoolExp
}

"""Ordering options when selecting data from "priority"."""
input PriorityOrderBy {
  course: CourseOrderBy
  courseId: OrderBy
  id: OrderBy
  isPriority: OrderBy
  seniority: OrderBy
  service: ServiceOrderBy
  serviceId: OrderBy
}

"""primary key columns input for table: priority"""
input PriorityPkColumnsInput {
  """Unique identifier for the priority entry."""
  id: Int!
}

"""
select columns of table "priority"
"""
enum PrioritySelectColumn {
  """column name"""
  courseId

  """column name"""
  id

  """column name"""
  isPriority

  """column name"""
  seniority

  """column name"""
  serviceId
}

"""
select "priorityAggregateBoolExpBool_andArgumentsColumns" columns of table "priority"
"""
enum PrioritySelectColumnPriorityAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  isPriority
}

"""
select "priorityAggregateBoolExpBool_orArgumentsColumns" columns of table "priority"
"""
enum PrioritySelectColumnPriorityAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  isPriority
}

"""
input type for updating data in table "priority"
"""
input PrioritySetInput {
  """Associated course ID."""
  courseId: Int

  """Unique identifier for the priority entry."""
  id: Int

  """Indicates if the teacher has priority for this course."""
  isPriority: Boolean

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: Int

  """Associated service ID."""
  serviceId: Int
}

"""aggregate stddev on columns"""
type PriorityStddevFields {
  """Associated course ID."""
  courseId: Float

  """Unique identifier for the priority entry."""
  id: Float

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: Float

  """Associated service ID."""
  serviceId: Float
}

"""
order by stddev() on columns of table "priority"
"""
input PriorityStddevOrderBy {
  """Associated course ID."""
  courseId: OrderBy

  """Unique identifier for the priority entry."""
  id: OrderBy

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: OrderBy

  """Associated service ID."""
  serviceId: OrderBy
}

"""aggregate stddevPop on columns"""
type PriorityStddevPopFields {
  """Associated course ID."""
  courseId: Float

  """Unique identifier for the priority entry."""
  id: Float

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: Float

  """Associated service ID."""
  serviceId: Float
}

"""
order by stddevPop() on columns of table "priority"
"""
input PriorityStddevPopOrderBy {
  """Associated course ID."""
  courseId: OrderBy

  """Unique identifier for the priority entry."""
  id: OrderBy

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: OrderBy

  """Associated service ID."""
  serviceId: OrderBy
}

"""aggregate stddevSamp on columns"""
type PriorityStddevSampFields {
  """Associated course ID."""
  courseId: Float

  """Unique identifier for the priority entry."""
  id: Float

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: Float

  """Associated service ID."""
  serviceId: Float
}

"""
order by stddevSamp() on columns of table "priority"
"""
input PriorityStddevSampOrderBy {
  """Associated course ID."""
  courseId: OrderBy

  """Unique identifier for the priority entry."""
  id: OrderBy

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: OrderBy

  """Associated service ID."""
  serviceId: OrderBy
}

"""
Streaming cursor of the table "priority"
"""
input PriorityStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PriorityStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PriorityStreamCursorValueInput {
  """Associated course ID."""
  courseId: Int

  """Unique identifier for the priority entry."""
  id: Int

  """Indicates if the teacher has priority for this course."""
  isPriority: Boolean

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: Int

  """Associated service ID."""
  serviceId: Int
}

"""aggregate sum on columns"""
type PrioritySumFields {
  """Associated course ID."""
  courseId: Int

  """Unique identifier for the priority entry."""
  id: Int

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: Int

  """Associated service ID."""
  serviceId: Int
}

"""
order by sum() on columns of table "priority"
"""
input PrioritySumOrderBy {
  """Associated course ID."""
  courseId: OrderBy

  """Unique identifier for the priority entry."""
  id: OrderBy

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: OrderBy

  """Associated service ID."""
  serviceId: OrderBy
}

"""
update columns of table "priority"
"""
enum PriorityUpdateColumn {
  """column name"""
  courseId

  """column name"""
  id

  """column name"""
  isPriority

  """column name"""
  seniority

  """column name"""
  serviceId
}

input PriorityUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: PriorityIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: PrioritySetInput

  """filter the rows which have to be updated"""
  where: PriorityBoolExp!
}

"""aggregate varPop on columns"""
type PriorityVarPopFields {
  """Associated course ID."""
  courseId: Float

  """Unique identifier for the priority entry."""
  id: Float

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: Float

  """Associated service ID."""
  serviceId: Float
}

"""
order by varPop() on columns of table "priority"
"""
input PriorityVarPopOrderBy {
  """Associated course ID."""
  courseId: OrderBy

  """Unique identifier for the priority entry."""
  id: OrderBy

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: OrderBy

  """Associated service ID."""
  serviceId: OrderBy
}

"""aggregate varSamp on columns"""
type PriorityVarSampFields {
  """Associated course ID."""
  courseId: Float

  """Unique identifier for the priority entry."""
  id: Float

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: Float

  """Associated service ID."""
  serviceId: Float
}

"""
order by varSamp() on columns of table "priority"
"""
input PriorityVarSampOrderBy {
  """Associated course ID."""
  courseId: OrderBy

  """Unique identifier for the priority entry."""
  id: OrderBy

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: OrderBy

  """Associated service ID."""
  serviceId: OrderBy
}

"""aggregate variance on columns"""
type PriorityVarianceFields {
  """Associated course ID."""
  courseId: Float

  """Unique identifier for the priority entry."""
  id: Float

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: Float

  """Associated service ID."""
  serviceId: Float
}

"""
order by variance() on columns of table "priority"
"""
input PriorityVarianceOrderBy {
  """Associated course ID."""
  courseId: OrderBy

  """Unique identifier for the priority entry."""
  id: OrderBy

  """
  Number of consecutive years up to the current year (excluded) during which the course was assigned to the teacher.
  """
  seniority: OrderBy

  """Associated service ID."""
  serviceId: OrderBy
}

"""Table contenant les différentes mentions."""
type Program {
  """An array relationship"""
  coordinations(
    """distinct select on columns"""
    distinctOn: [CoordinationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CoordinationOrderBy!]

    """filter the rows returned"""
    where: CoordinationBoolExp
  ): [Coordination!]!

  """An aggregate relationship"""
  coordinationsAggregate(
    """distinct select on columns"""
    distinctOn: [CoordinationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CoordinationOrderBy!]

    """filter the rows returned"""
    where: CoordinationBoolExp
  ): CoordinationAggregate!

  """An array relationship"""
  courses(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): [Course!]!

  """An aggregate relationship"""
  coursesAggregate(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): CourseAggregate!

  """An object relationship"""
  degree: Degree!
  degreeId: Int!

  """L'identifiant unique de la mention."""
  id: Int!

  """Le nom de la mention (unique)."""
  name: String!

  """Le nom abrégé (optionnel)."""
  nameShort: String
  nomImport: String

  """An array relationship"""
  tracks(
    """distinct select on columns"""
    distinctOn: [TrackSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TrackOrderBy!]

    """filter the rows returned"""
    where: TrackBoolExp
  ): [Track!]!

  """An aggregate relationship"""
  tracksAggregate(
    """distinct select on columns"""
    distinctOn: [TrackSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TrackOrderBy!]

    """filter the rows returned"""
    where: TrackBoolExp
  ): TrackAggregate!

  """Indique si la mention correspondante est visible par les utilisateurs."""
  visible: Boolean!
}

"""
aggregated selection of "program"
"""
type ProgramAggregate {
  aggregate: ProgramAggregateFields
  nodes: [Program!]!
}

input ProgramAggregateBoolExp {
  bool_and: programAggregateBoolExpBool_and
  bool_or: programAggregateBoolExpBool_or
  count: programAggregateBoolExpCount
}

"""
aggregate fields of "program"
"""
type ProgramAggregateFields {
  avg: ProgramAvgFields
  count(columns: [ProgramSelectColumn!], distinct: Boolean): Int!
  max: ProgramMaxFields
  min: ProgramMinFields
  stddev: ProgramStddevFields
  stddevPop: ProgramStddevPopFields
  stddevSamp: ProgramStddevSampFields
  sum: ProgramSumFields
  varPop: ProgramVarPopFields
  varSamp: ProgramVarSampFields
  variance: ProgramVarianceFields
}

"""
order by aggregate values of table "program"
"""
input ProgramAggregateOrderBy {
  avg: ProgramAvgOrderBy
  count: OrderBy
  max: ProgramMaxOrderBy
  min: ProgramMinOrderBy
  stddev: ProgramStddevOrderBy
  stddevPop: ProgramStddevPopOrderBy
  stddevSamp: ProgramStddevSampOrderBy
  sum: ProgramSumOrderBy
  varPop: ProgramVarPopOrderBy
  varSamp: ProgramVarSampOrderBy
  variance: ProgramVarianceOrderBy
}

"""
input type for inserting array relation for remote table "program"
"""
input ProgramArrRelInsertInput {
  data: [ProgramInsertInput!]!

  """upsert condition"""
  onConflict: ProgramOnConflict
}

"""aggregate avg on columns"""
type ProgramAvgFields {
  degreeId: Float

  """L'identifiant unique de la mention."""
  id: Float
}

"""
order by avg() on columns of table "program"
"""
input ProgramAvgOrderBy {
  degreeId: OrderBy

  """L'identifiant unique de la mention."""
  id: OrderBy
}

"""
Boolean expression to filter rows from the table "program". All fields are combined with a logical 'AND'.
"""
input ProgramBoolExp {
  _and: [ProgramBoolExp!]
  _not: ProgramBoolExp
  _or: [ProgramBoolExp!]
  coordinations: CoordinationBoolExp
  coordinationsAggregate: CoordinationAggregateBoolExp
  courses: CourseBoolExp
  coursesAggregate: CourseAggregateBoolExp
  degree: DegreeBoolExp
  degreeId: IntComparisonExp
  id: IntComparisonExp
  name: StringComparisonExp
  nameShort: StringComparisonExp
  nomImport: StringComparisonExp
  tracks: TrackBoolExp
  tracksAggregate: TrackAggregateBoolExp
  visible: BooleanComparisonExp
}

"""
unique or primary key constraints on table "program"
"""
enum ProgramConstraint {
  """
  unique or primary key constraint on columns "degree_id", "name"
  """
  mention_cursus_id_nom_key

  """
  unique or primary key constraint on columns "id"
  """
  mention_pkey
}

"""
input type for incrementing numeric columns in table "program"
"""
input ProgramIncInput {
  degreeId: Int

  """L'identifiant unique de la mention."""
  id: Int
}

"""
input type for inserting data into table "program"
"""
input ProgramInsertInput {
  coordinations: CoordinationArrRelInsertInput
  courses: CourseArrRelInsertInput
  degree: DegreeObjRelInsertInput
  degreeId: Int

  """L'identifiant unique de la mention."""
  id: Int

  """Le nom de la mention (unique)."""
  name: String

  """Le nom abrégé (optionnel)."""
  nameShort: String
  nomImport: String
  tracks: TrackArrRelInsertInput

  """Indique si la mention correspondante est visible par les utilisateurs."""
  visible: Boolean
}

"""aggregate max on columns"""
type ProgramMaxFields {
  degreeId: Int

  """L'identifiant unique de la mention."""
  id: Int

  """Le nom de la mention (unique)."""
  name: String

  """Le nom abrégé (optionnel)."""
  nameShort: String
  nomImport: String
}

"""
order by max() on columns of table "program"
"""
input ProgramMaxOrderBy {
  degreeId: OrderBy

  """L'identifiant unique de la mention."""
  id: OrderBy

  """Le nom de la mention (unique)."""
  name: OrderBy

  """Le nom abrégé (optionnel)."""
  nameShort: OrderBy
  nomImport: OrderBy
}

"""aggregate min on columns"""
type ProgramMinFields {
  degreeId: Int

  """L'identifiant unique de la mention."""
  id: Int

  """Le nom de la mention (unique)."""
  name: String

  """Le nom abrégé (optionnel)."""
  nameShort: String
  nomImport: String
}

"""
order by min() on columns of table "program"
"""
input ProgramMinOrderBy {
  degreeId: OrderBy

  """L'identifiant unique de la mention."""
  id: OrderBy

  """Le nom de la mention (unique)."""
  name: OrderBy

  """Le nom abrégé (optionnel)."""
  nameShort: OrderBy
  nomImport: OrderBy
}

"""
response of any mutation on the table "program"
"""
type ProgramMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Program!]!
}

"""
input type for inserting object relation for remote table "program"
"""
input ProgramObjRelInsertInput {
  data: ProgramInsertInput!

  """upsert condition"""
  onConflict: ProgramOnConflict
}

"""
on_conflict condition type for table "program"
"""
input ProgramOnConflict {
  constraint: ProgramConstraint!
  updateColumns: [ProgramUpdateColumn!]! = []
  where: ProgramBoolExp
}

"""Ordering options when selecting data from "program"."""
input ProgramOrderBy {
  coordinationsAggregate: CoordinationAggregateOrderBy
  coursesAggregate: CourseAggregateOrderBy
  degree: DegreeOrderBy
  degreeId: OrderBy
  id: OrderBy
  name: OrderBy
  nameShort: OrderBy
  nomImport: OrderBy
  tracksAggregate: TrackAggregateOrderBy
  visible: OrderBy
}

"""primary key columns input for table: program"""
input ProgramPkColumnsInput {
  """L'identifiant unique de la mention."""
  id: Int!
}

"""
select columns of table "program"
"""
enum ProgramSelectColumn {
  """column name"""
  degreeId

  """column name"""
  id

  """column name"""
  name

  """column name"""
  nameShort

  """column name"""
  nomImport

  """column name"""
  visible
}

"""
select "programAggregateBoolExpBool_andArgumentsColumns" columns of table "program"
"""
enum ProgramSelectColumnProgramAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  visible
}

"""
select "programAggregateBoolExpBool_orArgumentsColumns" columns of table "program"
"""
enum ProgramSelectColumnProgramAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  visible
}

"""
input type for updating data in table "program"
"""
input ProgramSetInput {
  degreeId: Int

  """L'identifiant unique de la mention."""
  id: Int

  """Le nom de la mention (unique)."""
  name: String

  """Le nom abrégé (optionnel)."""
  nameShort: String
  nomImport: String

  """Indique si la mention correspondante est visible par les utilisateurs."""
  visible: Boolean
}

"""aggregate stddev on columns"""
type ProgramStddevFields {
  degreeId: Float

  """L'identifiant unique de la mention."""
  id: Float
}

"""
order by stddev() on columns of table "program"
"""
input ProgramStddevOrderBy {
  degreeId: OrderBy

  """L'identifiant unique de la mention."""
  id: OrderBy
}

"""aggregate stddevPop on columns"""
type ProgramStddevPopFields {
  degreeId: Float

  """L'identifiant unique de la mention."""
  id: Float
}

"""
order by stddevPop() on columns of table "program"
"""
input ProgramStddevPopOrderBy {
  degreeId: OrderBy

  """L'identifiant unique de la mention."""
  id: OrderBy
}

"""aggregate stddevSamp on columns"""
type ProgramStddevSampFields {
  degreeId: Float

  """L'identifiant unique de la mention."""
  id: Float
}

"""
order by stddevSamp() on columns of table "program"
"""
input ProgramStddevSampOrderBy {
  degreeId: OrderBy

  """L'identifiant unique de la mention."""
  id: OrderBy
}

"""
Streaming cursor of the table "program"
"""
input ProgramStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ProgramStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ProgramStreamCursorValueInput {
  degreeId: Int

  """L'identifiant unique de la mention."""
  id: Int

  """Le nom de la mention (unique)."""
  name: String

  """Le nom abrégé (optionnel)."""
  nameShort: String
  nomImport: String

  """Indique si la mention correspondante est visible par les utilisateurs."""
  visible: Boolean
}

"""aggregate sum on columns"""
type ProgramSumFields {
  degreeId: Int

  """L'identifiant unique de la mention."""
  id: Int
}

"""
order by sum() on columns of table "program"
"""
input ProgramSumOrderBy {
  degreeId: OrderBy

  """L'identifiant unique de la mention."""
  id: OrderBy
}

"""
update columns of table "program"
"""
enum ProgramUpdateColumn {
  """column name"""
  degreeId

  """column name"""
  id

  """column name"""
  name

  """column name"""
  nameShort

  """column name"""
  nomImport

  """column name"""
  visible
}

input ProgramUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: ProgramIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: ProgramSetInput

  """filter the rows which have to be updated"""
  where: ProgramBoolExp!
}

"""aggregate varPop on columns"""
type ProgramVarPopFields {
  degreeId: Float

  """L'identifiant unique de la mention."""
  id: Float
}

"""
order by varPop() on columns of table "program"
"""
input ProgramVarPopOrderBy {
  degreeId: OrderBy

  """L'identifiant unique de la mention."""
  id: OrderBy
}

"""aggregate varSamp on columns"""
type ProgramVarSampFields {
  degreeId: Float

  """L'identifiant unique de la mention."""
  id: Float
}

"""
order by varSamp() on columns of table "program"
"""
input ProgramVarSampOrderBy {
  degreeId: OrderBy

  """L'identifiant unique de la mention."""
  id: OrderBy
}

"""aggregate variance on columns"""
type ProgramVarianceFields {
  degreeId: Float

  """L'identifiant unique de la mention."""
  id: Float
}

"""
order by variance() on columns of table "program"
"""
input ProgramVarianceOrderBy {
  degreeId: OrderBy

  """L'identifiant unique de la mention."""
  id: OrderBy
}

"""Table contenant les demandes."""
type Request {
  """An object relationship"""
  course: Course!

  """L'identifiant de l'enseignement correspondant à la demande."""
  courseId: Int!
  createdAt: timestamptz!

  """Le nombre d'heures demandées."""
  hours: Float!

  """
  A computed field, executes function "hours_weighted"
  """
  hoursWeighted: Float
  id: Int!

  """
  A computed field, executes function "is_priority"
  """
  isPriority: Boolean

  """An object relationship"""
  service: Service!
  serviceId: Int!

  """Le type de demande."""
  type: String!

  """An object relationship"""
  typeByType: RequestType!
  updatedAt: timestamptz!
}

"""
aggregated selection of "request"
"""
type RequestAggregate {
  aggregate: RequestAggregateFields
  nodes: [Request!]!
}

input RequestAggregateBoolExp {
  count: requestAggregateBoolExpCount
}

"""
aggregate fields of "request"
"""
type RequestAggregateFields {
  avg: RequestAvgFields
  count(columns: [RequestSelectColumn!], distinct: Boolean): Int!
  max: RequestMaxFields
  min: RequestMinFields
  stddev: RequestStddevFields
  stddevPop: RequestStddevPopFields
  stddevSamp: RequestStddevSampFields
  sum: RequestSumFields
  varPop: RequestVarPopFields
  varSamp: RequestVarSampFields
  variance: RequestVarianceFields
}

"""
order by aggregate values of table "request"
"""
input RequestAggregateOrderBy {
  avg: RequestAvgOrderBy
  count: OrderBy
  max: RequestMaxOrderBy
  min: RequestMinOrderBy
  stddev: RequestStddevOrderBy
  stddevPop: RequestStddevPopOrderBy
  stddevSamp: RequestStddevSampOrderBy
  sum: RequestSumOrderBy
  varPop: RequestVarPopOrderBy
  varSamp: RequestVarSampOrderBy
  variance: RequestVarianceOrderBy
}

"""
input type for inserting array relation for remote table "request"
"""
input RequestArrRelInsertInput {
  data: [RequestInsertInput!]!

  """upsert condition"""
  onConflict: RequestOnConflict
}

"""aggregate avg on columns"""
type RequestAvgFields {
  """L'identifiant de l'enseignement correspondant à la demande."""
  courseId: Float

  """Le nombre d'heures demandées."""
  hours: Float

  """
  A computed field, executes function "hours_weighted"
  """
  hoursWeighted: Float
  id: Float
  serviceId: Float
}

"""
order by avg() on columns of table "request"
"""
input RequestAvgOrderBy {
  """L'identifiant de l'enseignement correspondant à la demande."""
  courseId: OrderBy

  """Le nombre d'heures demandées."""
  hours: OrderBy
  id: OrderBy
  serviceId: OrderBy
}

"""
Boolean expression to filter rows from the table "request". All fields are combined with a logical 'AND'.
"""
input RequestBoolExp {
  _and: [RequestBoolExp!]
  _not: RequestBoolExp
  _or: [RequestBoolExp!]
  course: CourseBoolExp
  courseId: IntComparisonExp
  createdAt: TimestamptzComparisonExp
  hours: FloatComparisonExp
  hoursWeighted: FloatComparisonExp
  id: IntComparisonExp
  isPriority: BooleanComparisonExp
  service: ServiceBoolExp
  serviceId: IntComparisonExp
  type: StringComparisonExp
  typeByType: RequestTypeBoolExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "request"
"""
enum RequestConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  demande_pkey

  """
  unique or primary key constraint on columns "type", "course_id", "service_id"
  """
  request_service_id_course_id_type_key
}

"""
input type for incrementing numeric columns in table "request"
"""
input RequestIncInput {
  """L'identifiant de l'enseignement correspondant à la demande."""
  courseId: Int

  """Le nombre d'heures demandées."""
  hours: Float
  id: Int
  serviceId: Int
}

"""
input type for inserting data into table "request"
"""
input RequestInsertInput {
  course: CourseObjRelInsertInput

  """L'identifiant de l'enseignement correspondant à la demande."""
  courseId: Int
  createdAt: timestamptz

  """Le nombre d'heures demandées."""
  hours: Float
  id: Int
  service: ServiceObjRelInsertInput
  serviceId: Int

  """Le type de demande."""
  type: String
  typeByType: RequestTypeObjRelInsertInput
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type RequestMaxFields {
  """L'identifiant de l'enseignement correspondant à la demande."""
  courseId: Int
  createdAt: timestamptz

  """Le nombre d'heures demandées."""
  hours: Float

  """
  A computed field, executes function "hours_weighted"
  """
  hoursWeighted: Float
  id: Int
  serviceId: Int

  """Le type de demande."""
  type: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "request"
"""
input RequestMaxOrderBy {
  """L'identifiant de l'enseignement correspondant à la demande."""
  courseId: OrderBy
  createdAt: OrderBy

  """Le nombre d'heures demandées."""
  hours: OrderBy
  id: OrderBy
  serviceId: OrderBy

  """Le type de demande."""
  type: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type RequestMinFields {
  """L'identifiant de l'enseignement correspondant à la demande."""
  courseId: Int
  createdAt: timestamptz

  """Le nombre d'heures demandées."""
  hours: Float

  """
  A computed field, executes function "hours_weighted"
  """
  hoursWeighted: Float
  id: Int
  serviceId: Int

  """Le type de demande."""
  type: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "request"
"""
input RequestMinOrderBy {
  """L'identifiant de l'enseignement correspondant à la demande."""
  courseId: OrderBy
  createdAt: OrderBy

  """Le nombre d'heures demandées."""
  hours: OrderBy
  id: OrderBy
  serviceId: OrderBy

  """Le type de demande."""
  type: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "request"
"""
type RequestMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Request!]!
}

"""
on_conflict condition type for table "request"
"""
input RequestOnConflict {
  constraint: RequestConstraint!
  updateColumns: [RequestUpdateColumn!]! = []
  where: RequestBoolExp
}

"""Ordering options when selecting data from "request"."""
input RequestOrderBy {
  course: CourseOrderBy
  courseId: OrderBy
  createdAt: OrderBy
  hours: OrderBy
  hoursWeighted: OrderBy
  id: OrderBy
  isPriority: OrderBy
  service: ServiceOrderBy
  serviceId: OrderBy
  type: OrderBy
  typeByType: RequestTypeOrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: request"""
input RequestPkColumnsInput {
  id: Int!
}

"""
select columns of table "request"
"""
enum RequestSelectColumn {
  """column name"""
  courseId

  """column name"""
  createdAt

  """column name"""
  hours

  """column name"""
  id

  """column name"""
  serviceId

  """column name"""
  type

  """column name"""
  updatedAt
}

"""
input type for updating data in table "request"
"""
input RequestSetInput {
  """L'identifiant de l'enseignement correspondant à la demande."""
  courseId: Int
  createdAt: timestamptz

  """Le nombre d'heures demandées."""
  hours: Float
  id: Int
  serviceId: Int

  """Le type de demande."""
  type: String
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type RequestStddevFields {
  """L'identifiant de l'enseignement correspondant à la demande."""
  courseId: Float

  """Le nombre d'heures demandées."""
  hours: Float

  """
  A computed field, executes function "hours_weighted"
  """
  hoursWeighted: Float
  id: Float
  serviceId: Float
}

"""
order by stddev() on columns of table "request"
"""
input RequestStddevOrderBy {
  """L'identifiant de l'enseignement correspondant à la demande."""
  courseId: OrderBy

  """Le nombre d'heures demandées."""
  hours: OrderBy
  id: OrderBy
  serviceId: OrderBy
}

"""aggregate stddevPop on columns"""
type RequestStddevPopFields {
  """L'identifiant de l'enseignement correspondant à la demande."""
  courseId: Float

  """Le nombre d'heures demandées."""
  hours: Float

  """
  A computed field, executes function "hours_weighted"
  """
  hoursWeighted: Float
  id: Float
  serviceId: Float
}

"""
order by stddevPop() on columns of table "request"
"""
input RequestStddevPopOrderBy {
  """L'identifiant de l'enseignement correspondant à la demande."""
  courseId: OrderBy

  """Le nombre d'heures demandées."""
  hours: OrderBy
  id: OrderBy
  serviceId: OrderBy
}

"""aggregate stddevSamp on columns"""
type RequestStddevSampFields {
  """L'identifiant de l'enseignement correspondant à la demande."""
  courseId: Float

  """Le nombre d'heures demandées."""
  hours: Float

  """
  A computed field, executes function "hours_weighted"
  """
  hoursWeighted: Float
  id: Float
  serviceId: Float
}

"""
order by stddevSamp() on columns of table "request"
"""
input RequestStddevSampOrderBy {
  """L'identifiant de l'enseignement correspondant à la demande."""
  courseId: OrderBy

  """Le nombre d'heures demandées."""
  hours: OrderBy
  id: OrderBy
  serviceId: OrderBy
}

"""
Streaming cursor of the table "request"
"""
input RequestStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: RequestStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input RequestStreamCursorValueInput {
  """L'identifiant de l'enseignement correspondant à la demande."""
  courseId: Int
  createdAt: timestamptz

  """Le nombre d'heures demandées."""
  hours: Float
  id: Int
  serviceId: Int

  """Le type de demande."""
  type: String
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type RequestSumFields {
  """L'identifiant de l'enseignement correspondant à la demande."""
  courseId: Int

  """Le nombre d'heures demandées."""
  hours: Float

  """
  A computed field, executes function "hours_weighted"
  """
  hoursWeighted: Float
  id: Int
  serviceId: Int
}

"""
order by sum() on columns of table "request"
"""
input RequestSumOrderBy {
  """L'identifiant de l'enseignement correspondant à la demande."""
  courseId: OrderBy

  """Le nombre d'heures demandées."""
  hours: OrderBy
  id: OrderBy
  serviceId: OrderBy
}

"""
Table contenant les différents types de demande (principale, secondaire, attribution).
"""
type RequestType {
  """Une brève description."""
  description: String

  """An array relationship"""
  requests(
    """distinct select on columns"""
    distinctOn: [RequestSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RequestOrderBy!]

    """filter the rows returned"""
    where: RequestBoolExp
  ): [Request!]!

  """An aggregate relationship"""
  requestsAggregate(
    """distinct select on columns"""
    distinctOn: [RequestSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RequestOrderBy!]

    """filter the rows returned"""
    where: RequestBoolExp
  ): RequestAggregate!

  """Le type de demande (unique)."""
  value: String!
}

"""
aggregated selection of "request_type"
"""
type RequestTypeAggregate {
  aggregate: RequestTypeAggregateFields
  nodes: [RequestType!]!
}

"""
aggregate fields of "request_type"
"""
type RequestTypeAggregateFields {
  count(columns: [RequestTypeSelectColumn!], distinct: Boolean): Int!
  max: RequestTypeMaxFields
  min: RequestTypeMinFields
}

"""
Boolean expression to filter rows from the table "request_type". All fields are combined with a logical 'AND'.
"""
input RequestTypeBoolExp {
  _and: [RequestTypeBoolExp!]
  _not: RequestTypeBoolExp
  _or: [RequestTypeBoolExp!]
  description: StringComparisonExp
  requests: RequestBoolExp
  requestsAggregate: RequestAggregateBoolExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "request_type"
"""
enum RequestTypeConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  type_demande_pkey
}

"""
input type for inserting data into table "request_type"
"""
input RequestTypeInsertInput {
  """Une brève description."""
  description: String
  requests: RequestArrRelInsertInput

  """Le type de demande (unique)."""
  value: String
}

"""aggregate max on columns"""
type RequestTypeMaxFields {
  """Une brève description."""
  description: String

  """Le type de demande (unique)."""
  value: String
}

"""aggregate min on columns"""
type RequestTypeMinFields {
  """Une brève description."""
  description: String

  """Le type de demande (unique)."""
  value: String
}

"""
response of any mutation on the table "request_type"
"""
type RequestTypeMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [RequestType!]!
}

"""
input type for inserting object relation for remote table "request_type"
"""
input RequestTypeObjRelInsertInput {
  data: RequestTypeInsertInput!

  """upsert condition"""
  onConflict: RequestTypeOnConflict
}

"""
on_conflict condition type for table "request_type"
"""
input RequestTypeOnConflict {
  constraint: RequestTypeConstraint!
  updateColumns: [RequestTypeUpdateColumn!]! = []
  where: RequestTypeBoolExp
}

"""Ordering options when selecting data from "request_type"."""
input RequestTypeOrderBy {
  description: OrderBy
  requestsAggregate: RequestAggregateOrderBy
  value: OrderBy
}

"""primary key columns input for table: request_type"""
input RequestTypePkColumnsInput {
  """Le type de demande (unique)."""
  value: String!
}

"""
select columns of table "request_type"
"""
enum RequestTypeSelectColumn {
  """column name"""
  description

  """column name"""
  value
}

"""
input type for updating data in table "request_type"
"""
input RequestTypeSetInput {
  """Une brève description."""
  description: String

  """Le type de demande (unique)."""
  value: String
}

"""
Streaming cursor of the table "request_type"
"""
input RequestTypeStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: RequestTypeStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input RequestTypeStreamCursorValueInput {
  """Une brève description."""
  description: String

  """Le type de demande (unique)."""
  value: String
}

"""
update columns of table "request_type"
"""
enum RequestTypeUpdateColumn {
  """column name"""
  description

  """column name"""
  value
}

input RequestTypeUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: RequestTypeSetInput

  """filter the rows which have to be updated"""
  where: RequestTypeBoolExp!
}

"""
update columns of table "request"
"""
enum RequestUpdateColumn {
  """column name"""
  courseId

  """column name"""
  createdAt

  """column name"""
  hours

  """column name"""
  id

  """column name"""
  serviceId

  """column name"""
  type

  """column name"""
  updatedAt
}

input RequestUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: RequestIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: RequestSetInput

  """filter the rows which have to be updated"""
  where: RequestBoolExp!
}

"""aggregate varPop on columns"""
type RequestVarPopFields {
  """L'identifiant de l'enseignement correspondant à la demande."""
  courseId: Float

  """Le nombre d'heures demandées."""
  hours: Float

  """
  A computed field, executes function "hours_weighted"
  """
  hoursWeighted: Float
  id: Float
  serviceId: Float
}

"""
order by varPop() on columns of table "request"
"""
input RequestVarPopOrderBy {
  """L'identifiant de l'enseignement correspondant à la demande."""
  courseId: OrderBy

  """Le nombre d'heures demandées."""
  hours: OrderBy
  id: OrderBy
  serviceId: OrderBy
}

"""aggregate varSamp on columns"""
type RequestVarSampFields {
  """L'identifiant de l'enseignement correspondant à la demande."""
  courseId: Float

  """Le nombre d'heures demandées."""
  hours: Float

  """
  A computed field, executes function "hours_weighted"
  """
  hoursWeighted: Float
  id: Float
  serviceId: Float
}

"""
order by varSamp() on columns of table "request"
"""
input RequestVarSampOrderBy {
  """L'identifiant de l'enseignement correspondant à la demande."""
  courseId: OrderBy

  """Le nombre d'heures demandées."""
  hours: OrderBy
  id: OrderBy
  serviceId: OrderBy
}

"""aggregate variance on columns"""
type RequestVarianceFields {
  """L'identifiant de l'enseignement correspondant à la demande."""
  courseId: Float

  """Le nombre d'heures demandées."""
  hours: Float

  """
  A computed field, executes function "hours_weighted"
  """
  hoursWeighted: Float
  id: Float
  serviceId: Float
}

"""
order by variance() on columns of table "request"
"""
input RequestVarianceOrderBy {
  """L'identifiant de l'enseignement correspondant à la demande."""
  courseId: OrderBy

  """Le nombre d'heures demandées."""
  hours: OrderBy
  id: OrderBy
  serviceId: OrderBy
}

"""
Table contenant les services de base, c'est-à-dire le nombre d'heures EQTD qu'un intervenant donné doit réaliser lors d'une année donnée avant modifications éventuelles.
"""
type Service {
  createdAt: timestamptz!

  """Le nombre d'heures EQTD du service."""
  hours: Float!

  """L'identifiant unique du service."""
  id: Int!
  message: String

  """An array relationship"""
  modifications(
    """distinct select on columns"""
    distinctOn: [ServiceModificationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceModificationOrderBy!]

    """filter the rows returned"""
    where: ServiceModificationBoolExp
  ): [ServiceModification!]!

  """An aggregate relationship"""
  modificationsAggregate(
    """distinct select on columns"""
    distinctOn: [ServiceModificationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceModificationOrderBy!]

    """filter the rows returned"""
    where: ServiceModificationBoolExp
  ): ServiceModificationAggregate!

  """An array relationship"""
  priorities(
    """distinct select on columns"""
    distinctOn: [PrioritySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PriorityOrderBy!]

    """filter the rows returned"""
    where: PriorityBoolExp
  ): [Priority!]!

  """An aggregate relationship"""
  prioritiesAggregate(
    """distinct select on columns"""
    distinctOn: [PrioritySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PriorityOrderBy!]

    """filter the rows returned"""
    where: PriorityBoolExp
  ): PriorityAggregate!

  """An array relationship"""
  requests(
    """distinct select on columns"""
    distinctOn: [RequestSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RequestOrderBy!]

    """filter the rows returned"""
    where: RequestBoolExp
  ): [Request!]!

  """An aggregate relationship"""
  requestsAggregate(
    """distinct select on columns"""
    distinctOn: [RequestSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RequestOrderBy!]

    """filter the rows returned"""
    where: RequestBoolExp
  ): RequestAggregate!

  """An object relationship"""
  teacher: Teacher!

  """L'identifiant de l'intervenant correspond au service."""
  uid: String!
  updatedAt: timestamptz!

  """L'année correspondant au service."""
  year: Int!

  """An object relationship"""
  yearByYear: Year!
}

"""
aggregated selection of "service"
"""
type ServiceAggregate {
  aggregate: ServiceAggregateFields
  nodes: [Service!]!
}

input ServiceAggregateBoolExp {
  count: serviceAggregateBoolExpCount
}

"""
aggregate fields of "service"
"""
type ServiceAggregateFields {
  avg: ServiceAvgFields
  count(columns: [ServiceSelectColumn!], distinct: Boolean): Int!
  max: ServiceMaxFields
  min: ServiceMinFields
  stddev: ServiceStddevFields
  stddevPop: ServiceStddevPopFields
  stddevSamp: ServiceStddevSampFields
  sum: ServiceSumFields
  varPop: ServiceVarPopFields
  varSamp: ServiceVarSampFields
  variance: ServiceVarianceFields
}

"""
order by aggregate values of table "service"
"""
input ServiceAggregateOrderBy {
  avg: ServiceAvgOrderBy
  count: OrderBy
  max: ServiceMaxOrderBy
  min: ServiceMinOrderBy
  stddev: ServiceStddevOrderBy
  stddevPop: ServiceStddevPopOrderBy
  stddevSamp: ServiceStddevSampOrderBy
  sum: ServiceSumOrderBy
  varPop: ServiceVarPopOrderBy
  varSamp: ServiceVarSampOrderBy
  variance: ServiceVarianceOrderBy
}

"""
input type for inserting array relation for remote table "service"
"""
input ServiceArrRelInsertInput {
  data: [ServiceInsertInput!]!

  """upsert condition"""
  onConflict: ServiceOnConflict
}

"""aggregate avg on columns"""
type ServiceAvgFields {
  """Le nombre d'heures EQTD du service."""
  hours: Float

  """L'identifiant unique du service."""
  id: Float

  """L'année correspondant au service."""
  year: Float
}

"""
order by avg() on columns of table "service"
"""
input ServiceAvgOrderBy {
  """Le nombre d'heures EQTD du service."""
  hours: OrderBy

  """L'identifiant unique du service."""
  id: OrderBy

  """L'année correspondant au service."""
  year: OrderBy
}

"""
Boolean expression to filter rows from the table "service". All fields are combined with a logical 'AND'.
"""
input ServiceBoolExp {
  _and: [ServiceBoolExp!]
  _not: ServiceBoolExp
  _or: [ServiceBoolExp!]
  createdAt: TimestamptzComparisonExp
  hours: FloatComparisonExp
  id: IntComparisonExp
  message: StringComparisonExp
  modifications: ServiceModificationBoolExp
  modificationsAggregate: ServiceModificationAggregateBoolExp
  priorities: PriorityBoolExp
  prioritiesAggregate: PriorityAggregateBoolExp
  requests: RequestBoolExp
  requestsAggregate: RequestAggregateBoolExp
  teacher: TeacherBoolExp
  uid: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  year: IntComparisonExp
  yearByYear: YearBoolExp
}

"""
unique or primary key constraints on table "service"
"""
enum ServiceConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  service_pkey

  """
  unique or primary key constraint on columns "uid", "year"
  """
  service_year_uid_key
}

"""
input type for incrementing numeric columns in table "service"
"""
input ServiceIncInput {
  """Le nombre d'heures EQTD du service."""
  hours: Float

  """L'identifiant unique du service."""
  id: Int

  """L'année correspondant au service."""
  year: Int
}

"""
input type for inserting data into table "service"
"""
input ServiceInsertInput {
  createdAt: timestamptz

  """Le nombre d'heures EQTD du service."""
  hours: Float

  """L'identifiant unique du service."""
  id: Int
  message: String
  modifications: ServiceModificationArrRelInsertInput
  priorities: PriorityArrRelInsertInput
  requests: RequestArrRelInsertInput
  teacher: TeacherObjRelInsertInput

  """L'identifiant de l'intervenant correspond au service."""
  uid: String
  updatedAt: timestamptz

  """L'année correspondant au service."""
  year: Int
  yearByYear: YearObjRelInsertInput
}

"""aggregate max on columns"""
type ServiceMaxFields {
  createdAt: timestamptz

  """Le nombre d'heures EQTD du service."""
  hours: Float

  """L'identifiant unique du service."""
  id: Int
  message: String

  """L'identifiant de l'intervenant correspond au service."""
  uid: String
  updatedAt: timestamptz

  """L'année correspondant au service."""
  year: Int
}

"""
order by max() on columns of table "service"
"""
input ServiceMaxOrderBy {
  createdAt: OrderBy

  """Le nombre d'heures EQTD du service."""
  hours: OrderBy

  """L'identifiant unique du service."""
  id: OrderBy
  message: OrderBy

  """L'identifiant de l'intervenant correspond au service."""
  uid: OrderBy
  updatedAt: OrderBy

  """L'année correspondant au service."""
  year: OrderBy
}

"""aggregate min on columns"""
type ServiceMinFields {
  createdAt: timestamptz

  """Le nombre d'heures EQTD du service."""
  hours: Float

  """L'identifiant unique du service."""
  id: Int
  message: String

  """L'identifiant de l'intervenant correspond au service."""
  uid: String
  updatedAt: timestamptz

  """L'année correspondant au service."""
  year: Int
}

"""
order by min() on columns of table "service"
"""
input ServiceMinOrderBy {
  createdAt: OrderBy

  """Le nombre d'heures EQTD du service."""
  hours: OrderBy

  """L'identifiant unique du service."""
  id: OrderBy
  message: OrderBy

  """L'identifiant de l'intervenant correspond au service."""
  uid: OrderBy
  updatedAt: OrderBy

  """L'année correspondant au service."""
  year: OrderBy
}

"""
Table containing modifications to a teacher's base service for a given year.
"""
type ServiceModification {
  """Timestamp of when the modification was created."""
  createdAt: timestamptz!

  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: Float!

  """Unique identifier for the modification."""
  id: Int!

  """An object relationship"""
  service: Service!

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  serviceId: Int!

  """Type of modification."""
  type: String!

  """An object relationship"""
  typeByType: ServiceModificationType!

  """Timestamp of when the modification was last updated."""
  updatedAt: timestamptz!
}

"""
aggregated selection of "service_modification"
"""
type ServiceModificationAggregate {
  aggregate: ServiceModificationAggregateFields
  nodes: [ServiceModification!]!
}

input ServiceModificationAggregateBoolExp {
  count: serviceModificationAggregateBoolExpCount
}

"""
aggregate fields of "service_modification"
"""
type ServiceModificationAggregateFields {
  avg: ServiceModificationAvgFields
  count(columns: [ServiceModificationSelectColumn!], distinct: Boolean): Int!
  max: ServiceModificationMaxFields
  min: ServiceModificationMinFields
  stddev: ServiceModificationStddevFields
  stddevPop: ServiceModificationStddevPopFields
  stddevSamp: ServiceModificationStddevSampFields
  sum: ServiceModificationSumFields
  varPop: ServiceModificationVarPopFields
  varSamp: ServiceModificationVarSampFields
  variance: ServiceModificationVarianceFields
}

"""
order by aggregate values of table "service_modification"
"""
input ServiceModificationAggregateOrderBy {
  avg: ServiceModificationAvgOrderBy
  count: OrderBy
  max: ServiceModificationMaxOrderBy
  min: ServiceModificationMinOrderBy
  stddev: ServiceModificationStddevOrderBy
  stddevPop: ServiceModificationStddevPopOrderBy
  stddevSamp: ServiceModificationStddevSampOrderBy
  sum: ServiceModificationSumOrderBy
  varPop: ServiceModificationVarPopOrderBy
  varSamp: ServiceModificationVarSampOrderBy
  variance: ServiceModificationVarianceOrderBy
}

"""
input type for inserting array relation for remote table "service_modification"
"""
input ServiceModificationArrRelInsertInput {
  data: [ServiceModificationInsertInput!]!

  """upsert condition"""
  onConflict: ServiceModificationOnConflict
}

"""aggregate avg on columns"""
type ServiceModificationAvgFields {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: Float

  """Unique identifier for the modification."""
  id: Float

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  serviceId: Float
}

"""
order by avg() on columns of table "service_modification"
"""
input ServiceModificationAvgOrderBy {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: OrderBy

  """Unique identifier for the modification."""
  id: OrderBy

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  serviceId: OrderBy
}

"""
Boolean expression to filter rows from the table "service_modification". All fields are combined with a logical 'AND'.
"""
input ServiceModificationBoolExp {
  _and: [ServiceModificationBoolExp!]
  _not: ServiceModificationBoolExp
  _or: [ServiceModificationBoolExp!]
  createdAt: TimestamptzComparisonExp
  hours: FloatComparisonExp
  id: IntComparisonExp
  service: ServiceBoolExp
  serviceId: IntComparisonExp
  type: StringComparisonExp
  typeByType: ServiceModificationTypeBoolExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "service_modification"
"""
enum ServiceModificationConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  modification_service_pkey
}

"""
input type for incrementing numeric columns in table "service_modification"
"""
input ServiceModificationIncInput {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: Float

  """Unique identifier for the modification."""
  id: Int

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  serviceId: Int
}

"""
input type for inserting data into table "service_modification"
"""
input ServiceModificationInsertInput {
  """Timestamp of when the modification was created."""
  createdAt: timestamptz

  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: Float

  """Unique identifier for the modification."""
  id: Int
  service: ServiceObjRelInsertInput

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  serviceId: Int

  """Type of modification."""
  type: String
  typeByType: ServiceModificationTypeObjRelInsertInput

  """Timestamp of when the modification was last updated."""
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type ServiceModificationMaxFields {
  """Timestamp of when the modification was created."""
  createdAt: timestamptz

  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: Float

  """Unique identifier for the modification."""
  id: Int

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  serviceId: Int

  """Type of modification."""
  type: String

  """Timestamp of when the modification was last updated."""
  updatedAt: timestamptz
}

"""
order by max() on columns of table "service_modification"
"""
input ServiceModificationMaxOrderBy {
  """Timestamp of when the modification was created."""
  createdAt: OrderBy

  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: OrderBy

  """Unique identifier for the modification."""
  id: OrderBy

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  serviceId: OrderBy

  """Type of modification."""
  type: OrderBy

  """Timestamp of when the modification was last updated."""
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type ServiceModificationMinFields {
  """Timestamp of when the modification was created."""
  createdAt: timestamptz

  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: Float

  """Unique identifier for the modification."""
  id: Int

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  serviceId: Int

  """Type of modification."""
  type: String

  """Timestamp of when the modification was last updated."""
  updatedAt: timestamptz
}

"""
order by min() on columns of table "service_modification"
"""
input ServiceModificationMinOrderBy {
  """Timestamp of when the modification was created."""
  createdAt: OrderBy

  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: OrderBy

  """Unique identifier for the modification."""
  id: OrderBy

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  serviceId: OrderBy

  """Type of modification."""
  type: OrderBy

  """Timestamp of when the modification was last updated."""
  updatedAt: OrderBy
}

"""
response of any mutation on the table "service_modification"
"""
type ServiceModificationMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ServiceModification!]!
}

"""
on_conflict condition type for table "service_modification"
"""
input ServiceModificationOnConflict {
  constraint: ServiceModificationConstraint!
  updateColumns: [ServiceModificationUpdateColumn!]! = []
  where: ServiceModificationBoolExp
}

"""Ordering options when selecting data from "service_modification"."""
input ServiceModificationOrderBy {
  createdAt: OrderBy
  hours: OrderBy
  id: OrderBy
  service: ServiceOrderBy
  serviceId: OrderBy
  type: OrderBy
  typeByType: ServiceModificationTypeOrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: service_modification"""
input ServiceModificationPkColumnsInput {
  """Unique identifier for the modification."""
  id: Int!
}

"""
select columns of table "service_modification"
"""
enum ServiceModificationSelectColumn {
  """column name"""
  createdAt

  """column name"""
  hours

  """column name"""
  id

  """column name"""
  serviceId

  """column name"""
  type

  """column name"""
  updatedAt
}

"""
input type for updating data in table "service_modification"
"""
input ServiceModificationSetInput {
  """Timestamp of when the modification was created."""
  createdAt: timestamptz

  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: Float

  """Unique identifier for the modification."""
  id: Int

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  serviceId: Int

  """Type of modification."""
  type: String

  """Timestamp of when the modification was last updated."""
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type ServiceModificationStddevFields {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: Float

  """Unique identifier for the modification."""
  id: Float

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  serviceId: Float
}

"""
order by stddev() on columns of table "service_modification"
"""
input ServiceModificationStddevOrderBy {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: OrderBy

  """Unique identifier for the modification."""
  id: OrderBy

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  serviceId: OrderBy
}

"""aggregate stddevPop on columns"""
type ServiceModificationStddevPopFields {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: Float

  """Unique identifier for the modification."""
  id: Float

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  serviceId: Float
}

"""
order by stddevPop() on columns of table "service_modification"
"""
input ServiceModificationStddevPopOrderBy {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: OrderBy

  """Unique identifier for the modification."""
  id: OrderBy

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  serviceId: OrderBy
}

"""aggregate stddevSamp on columns"""
type ServiceModificationStddevSampFields {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: Float

  """Unique identifier for the modification."""
  id: Float

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  serviceId: Float
}

"""
order by stddevSamp() on columns of table "service_modification"
"""
input ServiceModificationStddevSampOrderBy {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: OrderBy

  """Unique identifier for the modification."""
  id: OrderBy

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  serviceId: OrderBy
}

"""
Streaming cursor of the table "service_modification"
"""
input ServiceModificationStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ServiceModificationStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ServiceModificationStreamCursorValueInput {
  """Timestamp of when the modification was created."""
  createdAt: timestamptz

  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: Float

  """Unique identifier for the modification."""
  id: Int

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  serviceId: Int

  """Type of modification."""
  type: String

  """Timestamp of when the modification was last updated."""
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type ServiceModificationSumFields {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: Float

  """Unique identifier for the modification."""
  id: Int

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  serviceId: Int
}

"""
order by sum() on columns of table "service_modification"
"""
input ServiceModificationSumOrderBy {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: OrderBy

  """Unique identifier for the modification."""
  id: OrderBy

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  serviceId: OrderBy
}

"""Table containing different types of service modifications."""
type ServiceModificationType {
  """Brief description."""
  description: String

  """Display label for the modification type."""
  label: String!

  """An aggregate relationship"""
  modificationsServiceAggregate(
    """distinct select on columns"""
    distinctOn: [ServiceModificationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceModificationOrderBy!]

    """filter the rows returned"""
    where: ServiceModificationBoolExp
  ): ServiceModificationAggregate!

  """An array relationship"""
  modifications_service(
    """distinct select on columns"""
    distinctOn: [ServiceModificationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceModificationOrderBy!]

    """filter the rows returned"""
    where: ServiceModificationBoolExp
  ): [ServiceModification!]!

  """Modification type (unique)."""
  value: String!
}

"""
aggregated selection of "service_modification_type"
"""
type ServiceModificationTypeAggregate {
  aggregate: ServiceModificationTypeAggregateFields
  nodes: [ServiceModificationType!]!
}

"""
aggregate fields of "service_modification_type"
"""
type ServiceModificationTypeAggregateFields {
  count(columns: [ServiceModificationTypeSelectColumn!], distinct: Boolean): Int!
  max: ServiceModificationTypeMaxFields
  min: ServiceModificationTypeMinFields
}

"""
Boolean expression to filter rows from the table "service_modification_type". All fields are combined with a logical 'AND'.
"""
input ServiceModificationTypeBoolExp {
  _and: [ServiceModificationTypeBoolExp!]
  _not: ServiceModificationTypeBoolExp
  _or: [ServiceModificationTypeBoolExp!]
  description: StringComparisonExp
  label: StringComparisonExp
  modifications_service: ServiceModificationBoolExp
  modifications_serviceAggregate: ServiceModificationAggregateBoolExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "service_modification_type"
"""
enum ServiceModificationTypeConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  type_modification_pkey
}

"""
input type for inserting data into table "service_modification_type"
"""
input ServiceModificationTypeInsertInput {
  """Brief description."""
  description: String

  """Display label for the modification type."""
  label: String
  modifications_service: ServiceModificationArrRelInsertInput

  """Modification type (unique)."""
  value: String
}

"""aggregate max on columns"""
type ServiceModificationTypeMaxFields {
  """Brief description."""
  description: String

  """Display label for the modification type."""
  label: String

  """Modification type (unique)."""
  value: String
}

"""aggregate min on columns"""
type ServiceModificationTypeMinFields {
  """Brief description."""
  description: String

  """Display label for the modification type."""
  label: String

  """Modification type (unique)."""
  value: String
}

"""
response of any mutation on the table "service_modification_type"
"""
type ServiceModificationTypeMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ServiceModificationType!]!
}

"""
input type for inserting object relation for remote table "service_modification_type"
"""
input ServiceModificationTypeObjRelInsertInput {
  data: ServiceModificationTypeInsertInput!

  """upsert condition"""
  onConflict: ServiceModificationTypeOnConflict
}

"""
on_conflict condition type for table "service_modification_type"
"""
input ServiceModificationTypeOnConflict {
  constraint: ServiceModificationTypeConstraint!
  updateColumns: [ServiceModificationTypeUpdateColumn!]! = []
  where: ServiceModificationTypeBoolExp
}

"""Ordering options when selecting data from "service_modification_type"."""
input ServiceModificationTypeOrderBy {
  description: OrderBy
  label: OrderBy
  modifications_serviceAggregate: ServiceModificationAggregateOrderBy
  value: OrderBy
}

"""primary key columns input for table: service_modification_type"""
input ServiceModificationTypePkColumnsInput {
  """Modification type (unique)."""
  value: String!
}

"""
select columns of table "service_modification_type"
"""
enum ServiceModificationTypeSelectColumn {
  """column name"""
  description

  """column name"""
  label

  """column name"""
  value
}

"""
input type for updating data in table "service_modification_type"
"""
input ServiceModificationTypeSetInput {
  """Brief description."""
  description: String

  """Display label for the modification type."""
  label: String

  """Modification type (unique)."""
  value: String
}

"""
Streaming cursor of the table "service_modification_type"
"""
input ServiceModificationTypeStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ServiceModificationTypeStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ServiceModificationTypeStreamCursorValueInput {
  """Brief description."""
  description: String

  """Display label for the modification type."""
  label: String

  """Modification type (unique)."""
  value: String
}

"""
update columns of table "service_modification_type"
"""
enum ServiceModificationTypeUpdateColumn {
  """column name"""
  description

  """column name"""
  label

  """column name"""
  value
}

input ServiceModificationTypeUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: ServiceModificationTypeSetInput

  """filter the rows which have to be updated"""
  where: ServiceModificationTypeBoolExp!
}

"""
update columns of table "service_modification"
"""
enum ServiceModificationUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  hours

  """column name"""
  id

  """column name"""
  serviceId

  """column name"""
  type

  """column name"""
  updatedAt
}

input ServiceModificationUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: ServiceModificationIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: ServiceModificationSetInput

  """filter the rows which have to be updated"""
  where: ServiceModificationBoolExp!
}

"""aggregate varPop on columns"""
type ServiceModificationVarPopFields {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: Float

  """Unique identifier for the modification."""
  id: Float

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  serviceId: Float
}

"""
order by varPop() on columns of table "service_modification"
"""
input ServiceModificationVarPopOrderBy {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: OrderBy

  """Unique identifier for the modification."""
  id: OrderBy

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  serviceId: OrderBy
}

"""aggregate varSamp on columns"""
type ServiceModificationVarSampFields {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: Float

  """Unique identifier for the modification."""
  id: Float

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  serviceId: Float
}

"""
order by varSamp() on columns of table "service_modification"
"""
input ServiceModificationVarSampOrderBy {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: OrderBy

  """Unique identifier for the modification."""
  id: OrderBy

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  serviceId: OrderBy
}

"""aggregate variance on columns"""
type ServiceModificationVarianceFields {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: Float

  """Unique identifier for the modification."""
  id: Float

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  serviceId: Float
}

"""
order by variance() on columns of table "service_modification"
"""
input ServiceModificationVarianceOrderBy {
  """
  Number of hours by which the service is modified (negative number indicates service increase).
  """
  hours: OrderBy

  """Unique identifier for the modification."""
  id: OrderBy

  """
  Reference to the service being modified. Links the modification to a specific teacher's service for a given year.
  """
  serviceId: OrderBy
}

"""
response of any mutation on the table "service"
"""
type ServiceMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Service!]!
}

"""
input type for inserting object relation for remote table "service"
"""
input ServiceObjRelInsertInput {
  data: ServiceInsertInput!

  """upsert condition"""
  onConflict: ServiceOnConflict
}

"""
on_conflict condition type for table "service"
"""
input ServiceOnConflict {
  constraint: ServiceConstraint!
  updateColumns: [ServiceUpdateColumn!]! = []
  where: ServiceBoolExp
}

"""Ordering options when selecting data from "service"."""
input ServiceOrderBy {
  createdAt: OrderBy
  hours: OrderBy
  id: OrderBy
  message: OrderBy
  modificationsAggregate: ServiceModificationAggregateOrderBy
  prioritiesAggregate: PriorityAggregateOrderBy
  requestsAggregate: RequestAggregateOrderBy
  teacher: TeacherOrderBy
  uid: OrderBy
  updatedAt: OrderBy
  year: OrderBy
  yearByYear: YearOrderBy
}

"""primary key columns input for table: service"""
input ServicePkColumnsInput {
  """L'identifiant unique du service."""
  id: Int!
}

"""
select columns of table "service"
"""
enum ServiceSelectColumn {
  """column name"""
  createdAt

  """column name"""
  hours

  """column name"""
  id

  """column name"""
  message

  """column name"""
  uid

  """column name"""
  updatedAt

  """column name"""
  year
}

"""
input type for updating data in table "service"
"""
input ServiceSetInput {
  createdAt: timestamptz

  """Le nombre d'heures EQTD du service."""
  hours: Float

  """L'identifiant unique du service."""
  id: Int
  message: String

  """L'identifiant de l'intervenant correspond au service."""
  uid: String
  updatedAt: timestamptz

  """L'année correspondant au service."""
  year: Int
}

"""aggregate stddev on columns"""
type ServiceStddevFields {
  """Le nombre d'heures EQTD du service."""
  hours: Float

  """L'identifiant unique du service."""
  id: Float

  """L'année correspondant au service."""
  year: Float
}

"""
order by stddev() on columns of table "service"
"""
input ServiceStddevOrderBy {
  """Le nombre d'heures EQTD du service."""
  hours: OrderBy

  """L'identifiant unique du service."""
  id: OrderBy

  """L'année correspondant au service."""
  year: OrderBy
}

"""aggregate stddevPop on columns"""
type ServiceStddevPopFields {
  """Le nombre d'heures EQTD du service."""
  hours: Float

  """L'identifiant unique du service."""
  id: Float

  """L'année correspondant au service."""
  year: Float
}

"""
order by stddevPop() on columns of table "service"
"""
input ServiceStddevPopOrderBy {
  """Le nombre d'heures EQTD du service."""
  hours: OrderBy

  """L'identifiant unique du service."""
  id: OrderBy

  """L'année correspondant au service."""
  year: OrderBy
}

"""aggregate stddevSamp on columns"""
type ServiceStddevSampFields {
  """Le nombre d'heures EQTD du service."""
  hours: Float

  """L'identifiant unique du service."""
  id: Float

  """L'année correspondant au service."""
  year: Float
}

"""
order by stddevSamp() on columns of table "service"
"""
input ServiceStddevSampOrderBy {
  """Le nombre d'heures EQTD du service."""
  hours: OrderBy

  """L'identifiant unique du service."""
  id: OrderBy

  """L'année correspondant au service."""
  year: OrderBy
}

"""
Streaming cursor of the table "service"
"""
input ServiceStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ServiceStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ServiceStreamCursorValueInput {
  createdAt: timestamptz

  """Le nombre d'heures EQTD du service."""
  hours: Float

  """L'identifiant unique du service."""
  id: Int
  message: String

  """L'identifiant de l'intervenant correspond au service."""
  uid: String
  updatedAt: timestamptz

  """L'année correspondant au service."""
  year: Int
}

"""aggregate sum on columns"""
type ServiceSumFields {
  """Le nombre d'heures EQTD du service."""
  hours: Float

  """L'identifiant unique du service."""
  id: Int

  """L'année correspondant au service."""
  year: Int
}

"""
order by sum() on columns of table "service"
"""
input ServiceSumOrderBy {
  """Le nombre d'heures EQTD du service."""
  hours: OrderBy

  """L'identifiant unique du service."""
  id: OrderBy

  """L'année correspondant au service."""
  year: OrderBy
}

"""
update columns of table "service"
"""
enum ServiceUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  hours

  """column name"""
  id

  """column name"""
  message

  """column name"""
  uid

  """column name"""
  updatedAt

  """column name"""
  year
}

input ServiceUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: ServiceIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: ServiceSetInput

  """filter the rows which have to be updated"""
  where: ServiceBoolExp!
}

"""aggregate varPop on columns"""
type ServiceVarPopFields {
  """Le nombre d'heures EQTD du service."""
  hours: Float

  """L'identifiant unique du service."""
  id: Float

  """L'année correspondant au service."""
  year: Float
}

"""
order by varPop() on columns of table "service"
"""
input ServiceVarPopOrderBy {
  """Le nombre d'heures EQTD du service."""
  hours: OrderBy

  """L'identifiant unique du service."""
  id: OrderBy

  """L'année correspondant au service."""
  year: OrderBy
}

"""aggregate varSamp on columns"""
type ServiceVarSampFields {
  """Le nombre d'heures EQTD du service."""
  hours: Float

  """L'identifiant unique du service."""
  id: Float

  """L'année correspondant au service."""
  year: Float
}

"""
order by varSamp() on columns of table "service"
"""
input ServiceVarSampOrderBy {
  """Le nombre d'heures EQTD du service."""
  hours: OrderBy

  """L'identifiant unique du service."""
  id: OrderBy

  """L'année correspondant au service."""
  year: OrderBy
}

"""aggregate variance on columns"""
type ServiceVarianceFields {
  """Le nombre d'heures EQTD du service."""
  hours: Float

  """L'identifiant unique du service."""
  id: Float

  """L'année correspondant au service."""
  year: Float
}

"""
order by variance() on columns of table "service"
"""
input ServiceVarianceOrderBy {
  """Le nombre d'heures EQTD du service."""
  hours: OrderBy

  """L'identifiant unique du service."""
  id: OrderBy

  """L'année correspondant au service."""
  year: OrderBy
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input StringComparisonExp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _isNull: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""Table contenant les intervenants."""
type Teacher {
  """
  Indique si un service doit être automatiquement créé pour l'intervenant lors de la prochaine année.
  """
  active: Boolean!

  """
  Un alias pour l'intervenant à afficher à la place du nom et prénom (optionnel).
  """
  alias: String

  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  baseServiceHours: Float

  """An array relationship"""
  coordinations(
    """distinct select on columns"""
    distinctOn: [CoordinationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CoordinationOrderBy!]

    """filter the rows returned"""
    where: CoordinationBoolExp
  ): [Coordination!]!

  """An aggregate relationship"""
  coordinationsAggregate(
    """distinct select on columns"""
    distinctOn: [CoordinationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CoordinationOrderBy!]

    """filter the rows returned"""
    where: CoordinationBoolExp
  ): CoordinationAggregate!

  """Le prénom de l'intervenant."""
  firstname: String!

  """Le nom de l'intervenant."""
  lastname: String!
  position: String

  """An object relationship"""
  positionByPosition: Position

  """An array relationship"""
  services(
    """distinct select on columns"""
    distinctOn: [ServiceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceOrderBy!]

    """filter the rows returned"""
    where: ServiceBoolExp
  ): [Service!]!

  """An aggregate relationship"""
  servicesAggregate(
    """distinct select on columns"""
    distinctOn: [ServiceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceOrderBy!]

    """filter the rows returned"""
    where: ServiceBoolExp
  ): ServiceAggregate!

  """L'identifiant unique de l'intervenant."""
  uid: String!

  """Indique si l'intervenant est visible par les utilisateurs."""
  visible: Boolean!
}

"""
aggregated selection of "teacher"
"""
type TeacherAggregate {
  aggregate: TeacherAggregateFields
  nodes: [Teacher!]!
}

input TeacherAggregateBoolExp {
  bool_and: teacherAggregateBoolExpBool_and
  bool_or: teacherAggregateBoolExpBool_or
  count: teacherAggregateBoolExpCount
}

"""
aggregate fields of "teacher"
"""
type TeacherAggregateFields {
  avg: TeacherAvgFields
  count(columns: [TeacherSelectColumn!], distinct: Boolean): Int!
  max: TeacherMaxFields
  min: TeacherMinFields
  stddev: TeacherStddevFields
  stddevPop: TeacherStddevPopFields
  stddevSamp: TeacherStddevSampFields
  sum: TeacherSumFields
  varPop: TeacherVarPopFields
  varSamp: TeacherVarSampFields
  variance: TeacherVarianceFields
}

"""
order by aggregate values of table "teacher"
"""
input TeacherAggregateOrderBy {
  avg: TeacherAvgOrderBy
  count: OrderBy
  max: TeacherMaxOrderBy
  min: TeacherMinOrderBy
  stddev: TeacherStddevOrderBy
  stddevPop: TeacherStddevPopOrderBy
  stddevSamp: TeacherStddevSampOrderBy
  sum: TeacherSumOrderBy
  varPop: TeacherVarPopOrderBy
  varSamp: TeacherVarSampOrderBy
  variance: TeacherVarianceOrderBy
}

"""
input type for inserting array relation for remote table "teacher"
"""
input TeacherArrRelInsertInput {
  data: [TeacherInsertInput!]!

  """upsert condition"""
  onConflict: TeacherOnConflict
}

"""aggregate avg on columns"""
type TeacherAvgFields {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  baseServiceHours: Float
}

"""
order by avg() on columns of table "teacher"
"""
input TeacherAvgOrderBy {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  baseServiceHours: OrderBy
}

"""
Boolean expression to filter rows from the table "teacher". All fields are combined with a logical 'AND'.
"""
input TeacherBoolExp {
  _and: [TeacherBoolExp!]
  _not: TeacherBoolExp
  _or: [TeacherBoolExp!]
  active: BooleanComparisonExp
  alias: StringComparisonExp
  baseServiceHours: FloatComparisonExp
  coordinations: CoordinationBoolExp
  coordinationsAggregate: CoordinationAggregateBoolExp
  firstname: StringComparisonExp
  lastname: StringComparisonExp
  position: StringComparisonExp
  positionByPosition: PositionBoolExp
  services: ServiceBoolExp
  servicesAggregate: ServiceAggregateBoolExp
  uid: StringComparisonExp
  visible: BooleanComparisonExp
}

"""
unique or primary key constraints on table "teacher"
"""
enum TeacherConstraint {
  """
  unique or primary key constraint on columns "uid"
  """
  intervenant_pkey
}

"""
input type for incrementing numeric columns in table "teacher"
"""
input TeacherIncInput {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  baseServiceHours: Float
}

"""
input type for inserting data into table "teacher"
"""
input TeacherInsertInput {
  """
  Indique si un service doit être automatiquement créé pour l'intervenant lors de la prochaine année.
  """
  active: Boolean

  """
  Un alias pour l'intervenant à afficher à la place du nom et prénom (optionnel).
  """
  alias: String

  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  baseServiceHours: Float
  coordinations: CoordinationArrRelInsertInput

  """Le prénom de l'intervenant."""
  firstname: String

  """Le nom de l'intervenant."""
  lastname: String
  position: String
  positionByPosition: PositionObjRelInsertInput
  services: ServiceArrRelInsertInput

  """L'identifiant unique de l'intervenant."""
  uid: String

  """Indique si l'intervenant est visible par les utilisateurs."""
  visible: Boolean
}

"""aggregate max on columns"""
type TeacherMaxFields {
  """
  Un alias pour l'intervenant à afficher à la place du nom et prénom (optionnel).
  """
  alias: String

  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  baseServiceHours: Float

  """Le prénom de l'intervenant."""
  firstname: String

  """Le nom de l'intervenant."""
  lastname: String
  position: String

  """L'identifiant unique de l'intervenant."""
  uid: String
}

"""
order by max() on columns of table "teacher"
"""
input TeacherMaxOrderBy {
  """
  Un alias pour l'intervenant à afficher à la place du nom et prénom (optionnel).
  """
  alias: OrderBy

  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  baseServiceHours: OrderBy

  """Le prénom de l'intervenant."""
  firstname: OrderBy

  """Le nom de l'intervenant."""
  lastname: OrderBy
  position: OrderBy

  """L'identifiant unique de l'intervenant."""
  uid: OrderBy
}

"""aggregate min on columns"""
type TeacherMinFields {
  """
  Un alias pour l'intervenant à afficher à la place du nom et prénom (optionnel).
  """
  alias: String

  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  baseServiceHours: Float

  """Le prénom de l'intervenant."""
  firstname: String

  """Le nom de l'intervenant."""
  lastname: String
  position: String

  """L'identifiant unique de l'intervenant."""
  uid: String
}

"""
order by min() on columns of table "teacher"
"""
input TeacherMinOrderBy {
  """
  Un alias pour l'intervenant à afficher à la place du nom et prénom (optionnel).
  """
  alias: OrderBy

  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  baseServiceHours: OrderBy

  """Le prénom de l'intervenant."""
  firstname: OrderBy

  """Le nom de l'intervenant."""
  lastname: OrderBy
  position: OrderBy

  """L'identifiant unique de l'intervenant."""
  uid: OrderBy
}

"""
response of any mutation on the table "teacher"
"""
type TeacherMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Teacher!]!
}

"""
input type for inserting object relation for remote table "teacher"
"""
input TeacherObjRelInsertInput {
  data: TeacherInsertInput!

  """upsert condition"""
  onConflict: TeacherOnConflict
}

"""
on_conflict condition type for table "teacher"
"""
input TeacherOnConflict {
  constraint: TeacherConstraint!
  updateColumns: [TeacherUpdateColumn!]! = []
  where: TeacherBoolExp
}

"""Ordering options when selecting data from "teacher"."""
input TeacherOrderBy {
  active: OrderBy
  alias: OrderBy
  baseServiceHours: OrderBy
  coordinationsAggregate: CoordinationAggregateOrderBy
  firstname: OrderBy
  lastname: OrderBy
  position: OrderBy
  positionByPosition: PositionOrderBy
  servicesAggregate: ServiceAggregateOrderBy
  uid: OrderBy
  visible: OrderBy
}

"""primary key columns input for table: teacher"""
input TeacherPkColumnsInput {
  """L'identifiant unique de l'intervenant."""
  uid: String!
}

"""
select columns of table "teacher"
"""
enum TeacherSelectColumn {
  """column name"""
  active

  """column name"""
  alias

  """column name"""
  baseServiceHours

  """column name"""
  firstname

  """column name"""
  lastname

  """column name"""
  position

  """column name"""
  uid

  """column name"""
  visible
}

"""
select "teacherAggregateBoolExpBool_andArgumentsColumns" columns of table "teacher"
"""
enum TeacherSelectColumnTeacherAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  active

  """column name"""
  visible
}

"""
select "teacherAggregateBoolExpBool_orArgumentsColumns" columns of table "teacher"
"""
enum TeacherSelectColumnTeacherAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  active

  """column name"""
  visible
}

"""
input type for updating data in table "teacher"
"""
input TeacherSetInput {
  """
  Indique si un service doit être automatiquement créé pour l'intervenant lors de la prochaine année.
  """
  active: Boolean

  """
  Un alias pour l'intervenant à afficher à la place du nom et prénom (optionnel).
  """
  alias: String

  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  baseServiceHours: Float

  """Le prénom de l'intervenant."""
  firstname: String

  """Le nom de l'intervenant."""
  lastname: String
  position: String

  """L'identifiant unique de l'intervenant."""
  uid: String

  """Indique si l'intervenant est visible par les utilisateurs."""
  visible: Boolean
}

"""aggregate stddev on columns"""
type TeacherStddevFields {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  baseServiceHours: Float
}

"""
order by stddev() on columns of table "teacher"
"""
input TeacherStddevOrderBy {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  baseServiceHours: OrderBy
}

"""aggregate stddevPop on columns"""
type TeacherStddevPopFields {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  baseServiceHours: Float
}

"""
order by stddevPop() on columns of table "teacher"
"""
input TeacherStddevPopOrderBy {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  baseServiceHours: OrderBy
}

"""aggregate stddevSamp on columns"""
type TeacherStddevSampFields {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  baseServiceHours: Float
}

"""
order by stddevSamp() on columns of table "teacher"
"""
input TeacherStddevSampOrderBy {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  baseServiceHours: OrderBy
}

"""
Streaming cursor of the table "teacher"
"""
input TeacherStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: TeacherStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input TeacherStreamCursorValueInput {
  """
  Indique si un service doit être automatiquement créé pour l'intervenant lors de la prochaine année.
  """
  active: Boolean

  """
  Un alias pour l'intervenant à afficher à la place du nom et prénom (optionnel).
  """
  alias: String

  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  baseServiceHours: Float

  """Le prénom de l'intervenant."""
  firstname: String

  """Le nom de l'intervenant."""
  lastname: String
  position: String

  """L'identifiant unique de l'intervenant."""
  uid: String

  """Indique si l'intervenant est visible par les utilisateurs."""
  visible: Boolean
}

"""aggregate sum on columns"""
type TeacherSumFields {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  baseServiceHours: Float
}

"""
order by sum() on columns of table "teacher"
"""
input TeacherSumOrderBy {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  baseServiceHours: OrderBy
}

"""
update columns of table "teacher"
"""
enum TeacherUpdateColumn {
  """column name"""
  active

  """column name"""
  alias

  """column name"""
  baseServiceHours

  """column name"""
  firstname

  """column name"""
  lastname

  """column name"""
  position

  """column name"""
  uid

  """column name"""
  visible
}

input TeacherUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: TeacherIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: TeacherSetInput

  """filter the rows which have to be updated"""
  where: TeacherBoolExp!
}

"""aggregate varPop on columns"""
type TeacherVarPopFields {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  baseServiceHours: Float
}

"""
order by varPop() on columns of table "teacher"
"""
input TeacherVarPopOrderBy {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  baseServiceHours: OrderBy
}

"""aggregate varSamp on columns"""
type TeacherVarSampFields {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  baseServiceHours: Float
}

"""
order by varSamp() on columns of table "teacher"
"""
input TeacherVarSampOrderBy {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  baseServiceHours: OrderBy
}

"""aggregate variance on columns"""
type TeacherVarianceFields {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  baseServiceHours: Float
}

"""
order by variance() on columns of table "teacher"
"""
input TeacherVarianceOrderBy {
  """Le service de base en heures EQTD de l'intervenant (optionnel)."""
  baseServiceHours: OrderBy
}

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input TimestamptzComparisonExp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _isNull: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""Table contenant les différents parcours."""
type Track {
  """An array relationship"""
  coordinations(
    """distinct select on columns"""
    distinctOn: [CoordinationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CoordinationOrderBy!]

    """filter the rows returned"""
    where: CoordinationBoolExp
  ): [Coordination!]!

  """An aggregate relationship"""
  coordinationsAggregate(
    """distinct select on columns"""
    distinctOn: [CoordinationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CoordinationOrderBy!]

    """filter the rows returned"""
    where: CoordinationBoolExp
  ): CoordinationAggregate!

  """An array relationship"""
  courses(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): [Course!]!

  """An aggregate relationship"""
  coursesAggregate(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): CourseAggregate!

  """L'identifiant unique du parcours."""
  id: Int!

  """Le nom du parcours (unique)."""
  name: String!

  """Le nom abrégé (optionnel)."""
  nameShort: String
  nomImport: String

  """An object relationship"""
  program: Program!
  programId: Int!

  """Indique si le parcours correspondant est visible par les utilisateurs."""
  visible: Boolean!
}

"""
aggregated selection of "track"
"""
type TrackAggregate {
  aggregate: TrackAggregateFields
  nodes: [Track!]!
}

input TrackAggregateBoolExp {
  bool_and: trackAggregateBoolExpBool_and
  bool_or: trackAggregateBoolExpBool_or
  count: trackAggregateBoolExpCount
}

"""
aggregate fields of "track"
"""
type TrackAggregateFields {
  avg: TrackAvgFields
  count(columns: [TrackSelectColumn!], distinct: Boolean): Int!
  max: TrackMaxFields
  min: TrackMinFields
  stddev: TrackStddevFields
  stddevPop: TrackStddevPopFields
  stddevSamp: TrackStddevSampFields
  sum: TrackSumFields
  varPop: TrackVarPopFields
  varSamp: TrackVarSampFields
  variance: TrackVarianceFields
}

"""
order by aggregate values of table "track"
"""
input TrackAggregateOrderBy {
  avg: TrackAvgOrderBy
  count: OrderBy
  max: TrackMaxOrderBy
  min: TrackMinOrderBy
  stddev: TrackStddevOrderBy
  stddevPop: TrackStddevPopOrderBy
  stddevSamp: TrackStddevSampOrderBy
  sum: TrackSumOrderBy
  varPop: TrackVarPopOrderBy
  varSamp: TrackVarSampOrderBy
  variance: TrackVarianceOrderBy
}

"""
input type for inserting array relation for remote table "track"
"""
input TrackArrRelInsertInput {
  data: [TrackInsertInput!]!

  """upsert condition"""
  onConflict: TrackOnConflict
}

"""aggregate avg on columns"""
type TrackAvgFields {
  """L'identifiant unique du parcours."""
  id: Float
  programId: Float
}

"""
order by avg() on columns of table "track"
"""
input TrackAvgOrderBy {
  """L'identifiant unique du parcours."""
  id: OrderBy
  programId: OrderBy
}

"""
Boolean expression to filter rows from the table "track". All fields are combined with a logical 'AND'.
"""
input TrackBoolExp {
  _and: [TrackBoolExp!]
  _not: TrackBoolExp
  _or: [TrackBoolExp!]
  coordinations: CoordinationBoolExp
  coordinationsAggregate: CoordinationAggregateBoolExp
  courses: CourseBoolExp
  coursesAggregate: CourseAggregateBoolExp
  id: IntComparisonExp
  name: StringComparisonExp
  nameShort: StringComparisonExp
  nomImport: StringComparisonExp
  program: ProgramBoolExp
  programId: IntComparisonExp
  visible: BooleanComparisonExp
}

"""
unique or primary key constraints on table "track"
"""
enum TrackConstraint {
  """
  unique or primary key constraint on columns "program_id", "name"
  """
  parcours_mention_id_nom_key

  """
  unique or primary key constraint on columns "id"
  """
  parcours_pkey
}

"""
input type for incrementing numeric columns in table "track"
"""
input TrackIncInput {
  """L'identifiant unique du parcours."""
  id: Int
  programId: Int
}

"""
input type for inserting data into table "track"
"""
input TrackInsertInput {
  coordinations: CoordinationArrRelInsertInput
  courses: CourseArrRelInsertInput

  """L'identifiant unique du parcours."""
  id: Int

  """Le nom du parcours (unique)."""
  name: String

  """Le nom abrégé (optionnel)."""
  nameShort: String
  nomImport: String
  program: ProgramObjRelInsertInput
  programId: Int

  """Indique si le parcours correspondant est visible par les utilisateurs."""
  visible: Boolean
}

"""aggregate max on columns"""
type TrackMaxFields {
  """L'identifiant unique du parcours."""
  id: Int

  """Le nom du parcours (unique)."""
  name: String

  """Le nom abrégé (optionnel)."""
  nameShort: String
  nomImport: String
  programId: Int
}

"""
order by max() on columns of table "track"
"""
input TrackMaxOrderBy {
  """L'identifiant unique du parcours."""
  id: OrderBy

  """Le nom du parcours (unique)."""
  name: OrderBy

  """Le nom abrégé (optionnel)."""
  nameShort: OrderBy
  nomImport: OrderBy
  programId: OrderBy
}

"""aggregate min on columns"""
type TrackMinFields {
  """L'identifiant unique du parcours."""
  id: Int

  """Le nom du parcours (unique)."""
  name: String

  """Le nom abrégé (optionnel)."""
  nameShort: String
  nomImport: String
  programId: Int
}

"""
order by min() on columns of table "track"
"""
input TrackMinOrderBy {
  """L'identifiant unique du parcours."""
  id: OrderBy

  """Le nom du parcours (unique)."""
  name: OrderBy

  """Le nom abrégé (optionnel)."""
  nameShort: OrderBy
  nomImport: OrderBy
  programId: OrderBy
}

"""
response of any mutation on the table "track"
"""
type TrackMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Track!]!
}

"""
input type for inserting object relation for remote table "track"
"""
input TrackObjRelInsertInput {
  data: TrackInsertInput!

  """upsert condition"""
  onConflict: TrackOnConflict
}

"""
on_conflict condition type for table "track"
"""
input TrackOnConflict {
  constraint: TrackConstraint!
  updateColumns: [TrackUpdateColumn!]! = []
  where: TrackBoolExp
}

"""Ordering options when selecting data from "track"."""
input TrackOrderBy {
  coordinationsAggregate: CoordinationAggregateOrderBy
  coursesAggregate: CourseAggregateOrderBy
  id: OrderBy
  name: OrderBy
  nameShort: OrderBy
  nomImport: OrderBy
  program: ProgramOrderBy
  programId: OrderBy
  visible: OrderBy
}

"""primary key columns input for table: track"""
input TrackPkColumnsInput {
  """L'identifiant unique du parcours."""
  id: Int!
}

"""
select columns of table "track"
"""
enum TrackSelectColumn {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  nameShort

  """column name"""
  nomImport

  """column name"""
  programId

  """column name"""
  visible
}

"""
select "trackAggregateBoolExpBool_andArgumentsColumns" columns of table "track"
"""
enum TrackSelectColumnTrackAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  visible
}

"""
select "trackAggregateBoolExpBool_orArgumentsColumns" columns of table "track"
"""
enum TrackSelectColumnTrackAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  visible
}

"""
input type for updating data in table "track"
"""
input TrackSetInput {
  """L'identifiant unique du parcours."""
  id: Int

  """Le nom du parcours (unique)."""
  name: String

  """Le nom abrégé (optionnel)."""
  nameShort: String
  nomImport: String
  programId: Int

  """Indique si le parcours correspondant est visible par les utilisateurs."""
  visible: Boolean
}

"""aggregate stddev on columns"""
type TrackStddevFields {
  """L'identifiant unique du parcours."""
  id: Float
  programId: Float
}

"""
order by stddev() on columns of table "track"
"""
input TrackStddevOrderBy {
  """L'identifiant unique du parcours."""
  id: OrderBy
  programId: OrderBy
}

"""aggregate stddevPop on columns"""
type TrackStddevPopFields {
  """L'identifiant unique du parcours."""
  id: Float
  programId: Float
}

"""
order by stddevPop() on columns of table "track"
"""
input TrackStddevPopOrderBy {
  """L'identifiant unique du parcours."""
  id: OrderBy
  programId: OrderBy
}

"""aggregate stddevSamp on columns"""
type TrackStddevSampFields {
  """L'identifiant unique du parcours."""
  id: Float
  programId: Float
}

"""
order by stddevSamp() on columns of table "track"
"""
input TrackStddevSampOrderBy {
  """L'identifiant unique du parcours."""
  id: OrderBy
  programId: OrderBy
}

"""
Streaming cursor of the table "track"
"""
input TrackStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: TrackStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input TrackStreamCursorValueInput {
  """L'identifiant unique du parcours."""
  id: Int

  """Le nom du parcours (unique)."""
  name: String

  """Le nom abrégé (optionnel)."""
  nameShort: String
  nomImport: String
  programId: Int

  """Indique si le parcours correspondant est visible par les utilisateurs."""
  visible: Boolean
}

"""aggregate sum on columns"""
type TrackSumFields {
  """L'identifiant unique du parcours."""
  id: Int
  programId: Int
}

"""
order by sum() on columns of table "track"
"""
input TrackSumOrderBy {
  """L'identifiant unique du parcours."""
  id: OrderBy
  programId: OrderBy
}

"""
update columns of table "track"
"""
enum TrackUpdateColumn {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  nameShort

  """column name"""
  nomImport

  """column name"""
  programId

  """column name"""
  visible
}

input TrackUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: TrackIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: TrackSetInput

  """filter the rows which have to be updated"""
  where: TrackBoolExp!
}

"""aggregate varPop on columns"""
type TrackVarPopFields {
  """L'identifiant unique du parcours."""
  id: Float
  programId: Float
}

"""
order by varPop() on columns of table "track"
"""
input TrackVarPopOrderBy {
  """L'identifiant unique du parcours."""
  id: OrderBy
  programId: OrderBy
}

"""aggregate varSamp on columns"""
type TrackVarSampFields {
  """L'identifiant unique du parcours."""
  id: Float
  programId: Float
}

"""
order by varSamp() on columns of table "track"
"""
input TrackVarSampOrderBy {
  """L'identifiant unique du parcours."""
  id: OrderBy
  programId: OrderBy
}

"""aggregate variance on columns"""
type TrackVarianceFields {
  """L'identifiant unique du parcours."""
  id: Float
  programId: Float
}

"""
order by variance() on columns of table "track"
"""
input TrackVarianceOrderBy {
  """L'identifiant unique du parcours."""
  id: OrderBy
  programId: OrderBy
}

"""Table contenant les différentes années."""
type Year {
  """An array relationship"""
  courses(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): [Course!]!

  """An aggregate relationship"""
  coursesAggregate(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): CourseAggregate!

  """
  Indique si l'année correspondante est l'année en cours (TRUE) ou non (NULL). Une seule année peut être en cours à la fois.
  """
  current: Boolean

  """An array relationship"""
  services(
    """distinct select on columns"""
    distinctOn: [ServiceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceOrderBy!]

    """filter the rows returned"""
    where: ServiceBoolExp
  ): [Service!]!

  """An aggregate relationship"""
  servicesAggregate(
    """distinct select on columns"""
    distinctOn: [ServiceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceOrderBy!]

    """filter the rows returned"""
    where: ServiceBoolExp
  ): ServiceAggregate!

  """Le numéro de l'année (unique)."""
  value: Int!

  """Indique si l'année correspondante est visible par les utilisateurs."""
  visible: Boolean!
}

"""
aggregated selection of "year"
"""
type YearAggregate {
  aggregate: YearAggregateFields
  nodes: [Year!]!
}

"""
aggregate fields of "year"
"""
type YearAggregateFields {
  avg: YearAvgFields
  count(columns: [YearSelectColumn!], distinct: Boolean): Int!
  max: YearMaxFields
  min: YearMinFields
  stddev: YearStddevFields
  stddevPop: YearStddevPopFields
  stddevSamp: YearStddevSampFields
  sum: YearSumFields
  varPop: YearVarPopFields
  varSamp: YearVarSampFields
  variance: YearVarianceFields
}

"""aggregate avg on columns"""
type YearAvgFields {
  """Le numéro de l'année (unique)."""
  value: Float
}

"""
Boolean expression to filter rows from the table "year". All fields are combined with a logical 'AND'.
"""
input YearBoolExp {
  _and: [YearBoolExp!]
  _not: YearBoolExp
  _or: [YearBoolExp!]
  courses: CourseBoolExp
  coursesAggregate: CourseAggregateBoolExp
  current: BooleanComparisonExp
  services: ServiceBoolExp
  servicesAggregate: ServiceAggregateBoolExp
  value: IntComparisonExp
  visible: BooleanComparisonExp
}

"""
unique or primary key constraints on table "year"
"""
enum YearConstraint {
  """
  unique or primary key constraint on columns "current"
  """
  annee_en_cours_key

  """
  unique or primary key constraint on columns "value"
  """
  annee_pkey
}

"""
input type for incrementing numeric columns in table "year"
"""
input YearIncInput {
  """Le numéro de l'année (unique)."""
  value: Int
}

"""
input type for inserting data into table "year"
"""
input YearInsertInput {
  courses: CourseArrRelInsertInput

  """
  Indique si l'année correspondante est l'année en cours (TRUE) ou non (NULL). Une seule année peut être en cours à la fois.
  """
  current: Boolean
  services: ServiceArrRelInsertInput

  """Le numéro de l'année (unique)."""
  value: Int

  """Indique si l'année correspondante est visible par les utilisateurs."""
  visible: Boolean
}

"""aggregate max on columns"""
type YearMaxFields {
  """Le numéro de l'année (unique)."""
  value: Int
}

"""aggregate min on columns"""
type YearMinFields {
  """Le numéro de l'année (unique)."""
  value: Int
}

"""
response of any mutation on the table "year"
"""
type YearMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Year!]!
}

"""
input type for inserting object relation for remote table "year"
"""
input YearObjRelInsertInput {
  data: YearInsertInput!

  """upsert condition"""
  onConflict: YearOnConflict
}

"""
on_conflict condition type for table "year"
"""
input YearOnConflict {
  constraint: YearConstraint!
  updateColumns: [YearUpdateColumn!]! = []
  where: YearBoolExp
}

"""Ordering options when selecting data from "year"."""
input YearOrderBy {
  coursesAggregate: CourseAggregateOrderBy
  current: OrderBy
  servicesAggregate: ServiceAggregateOrderBy
  value: OrderBy
  visible: OrderBy
}

"""primary key columns input for table: year"""
input YearPkColumnsInput {
  """Le numéro de l'année (unique)."""
  value: Int!
}

"""
select columns of table "year"
"""
enum YearSelectColumn {
  """column name"""
  current

  """column name"""
  value

  """column name"""
  visible
}

"""
input type for updating data in table "year"
"""
input YearSetInput {
  """
  Indique si l'année correspondante est l'année en cours (TRUE) ou non (NULL). Une seule année peut être en cours à la fois.
  """
  current: Boolean

  """Le numéro de l'année (unique)."""
  value: Int

  """Indique si l'année correspondante est visible par les utilisateurs."""
  visible: Boolean
}

"""aggregate stddev on columns"""
type YearStddevFields {
  """Le numéro de l'année (unique)."""
  value: Float
}

"""aggregate stddevPop on columns"""
type YearStddevPopFields {
  """Le numéro de l'année (unique)."""
  value: Float
}

"""aggregate stddevSamp on columns"""
type YearStddevSampFields {
  """Le numéro de l'année (unique)."""
  value: Float
}

"""
Streaming cursor of the table "year"
"""
input YearStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: YearStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input YearStreamCursorValueInput {
  """
  Indique si l'année correspondante est l'année en cours (TRUE) ou non (NULL). Une seule année peut être en cours à la fois.
  """
  current: Boolean

  """Le numéro de l'année (unique)."""
  value: Int

  """Indique si l'année correspondante est visible par les utilisateurs."""
  visible: Boolean
}

"""aggregate sum on columns"""
type YearSumFields {
  """Le numéro de l'année (unique)."""
  value: Int
}

"""
update columns of table "year"
"""
enum YearUpdateColumn {
  """column name"""
  current

  """column name"""
  value

  """column name"""
  visible
}

input YearUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: YearIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: YearSetInput

  """filter the rows which have to be updated"""
  where: YearBoolExp!
}

"""aggregate varPop on columns"""
type YearVarPopFields {
  """Le numéro de l'année (unique)."""
  value: Float
}

"""aggregate varSamp on columns"""
type YearVarSampFields {
  """Le numéro de l'année (unique)."""
  value: Float
}

"""aggregate variance on columns"""
type YearVarianceFields {
  """Le numéro de l'année (unique)."""
  value: Float
}

input coordinationAggregateBoolExpCount {
  arguments: [CoordinationSelectColumn!]
  distinct: Boolean
  filter: CoordinationBoolExp
  predicate: IntComparisonExp!
}

input courseAggregateBoolExpBool_and {
  arguments: CourseSelectColumnCourseAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: CourseBoolExp
  predicate: BooleanComparisonExp!
}

input courseAggregateBoolExpBool_or {
  arguments: CourseSelectColumnCourseAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: CourseBoolExp
  predicate: BooleanComparisonExp!
}

input courseAggregateBoolExpCount {
  arguments: [CourseSelectColumn!]
  distinct: Boolean
  filter: CourseBoolExp
  predicate: IntComparisonExp!
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "coordination"
  """
  deleteCoordination(
    """filter the rows which have to be deleted"""
    where: CoordinationBoolExp!
  ): CoordinationMutationResponse

  """
  delete single row from the table: "coordination"
  """
  deleteCoordinationByPk(
    """Unique identifier for the coordinator entry."""
    id: Int!
  ): Coordination

  """
  delete data from the table: "course"
  """
  deleteCourse(
    """filter the rows which have to be deleted"""
    where: CourseBoolExp!
  ): CourseMutationResponse

  """
  delete single row from the table: "course"
  """
  deleteCourseByPk(
    """L'identifiant unique de l'enseignement."""
    id: Int!
  ): Course

  """
  delete data from the table: "course_type"
  """
  deleteCourseType(
    """filter the rows which have to be deleted"""
    where: CourseTypeBoolExp!
  ): CourseTypeMutationResponse

  """
  delete single row from the table: "course_type"
  """
  deleteCourseTypeByPk(
    """La clé du type d'enseignement (unique)."""
    value: String!
  ): CourseType

  """
  delete data from the table: "degree"
  """
  deleteDegree(
    """filter the rows which have to be deleted"""
    where: DegreeBoolExp!
  ): DegreeMutationResponse

  """
  delete single row from the table: "degree"
  """
  deleteDegreeByPk(
    """L'identifiant unique du cursus."""
    id: Int!
  ): Degree

  """
  delete data from the table: "phase"
  """
  deletePhase(
    """filter the rows which have to be deleted"""
    where: PhaseBoolExp!
  ): PhaseMutationResponse

  """
  delete single row from the table: "phase"
  """
  deletePhaseByPk(
    """Phase identifier."""
    value: String!
  ): Phase

  """
  delete data from the table: "position"
  """
  deletePosition(
    """filter the rows which have to be deleted"""
    where: PositionBoolExp!
  ): PositionMutationResponse

  """
  delete single row from the table: "position"
  """
  deletePositionByPk(value: String!): Position

  """
  delete data from the table: "priority"
  """
  deletePriority(
    """filter the rows which have to be deleted"""
    where: PriorityBoolExp!
  ): PriorityMutationResponse

  """
  delete single row from the table: "priority"
  """
  deletePriorityByPk(
    """Unique identifier for the priority entry."""
    id: Int!
  ): Priority

  """
  delete data from the table: "program"
  """
  deleteProgram(
    """filter the rows which have to be deleted"""
    where: ProgramBoolExp!
  ): ProgramMutationResponse

  """
  delete single row from the table: "program"
  """
  deleteProgramByPk(
    """L'identifiant unique de la mention."""
    id: Int!
  ): Program

  """
  delete data from the table: "request"
  """
  deleteRequest(
    """filter the rows which have to be deleted"""
    where: RequestBoolExp!
  ): RequestMutationResponse

  """
  delete single row from the table: "request"
  """
  deleteRequestByPk(id: Int!): Request

  """
  delete data from the table: "request_type"
  """
  deleteRequestType(
    """filter the rows which have to be deleted"""
    where: RequestTypeBoolExp!
  ): RequestTypeMutationResponse

  """
  delete single row from the table: "request_type"
  """
  deleteRequestTypeByPk(
    """Le type de demande (unique)."""
    value: String!
  ): RequestType

  """
  delete data from the table: "service"
  """
  deleteService(
    """filter the rows which have to be deleted"""
    where: ServiceBoolExp!
  ): ServiceMutationResponse

  """
  delete single row from the table: "service"
  """
  deleteServiceByPk(
    """L'identifiant unique du service."""
    id: Int!
  ): Service

  """
  delete data from the table: "service_modification"
  """
  deleteServiceModification(
    """filter the rows which have to be deleted"""
    where: ServiceModificationBoolExp!
  ): ServiceModificationMutationResponse

  """
  delete single row from the table: "service_modification"
  """
  deleteServiceModificationByPk(
    """Unique identifier for the modification."""
    id: Int!
  ): ServiceModification

  """
  delete data from the table: "service_modification_type"
  """
  deleteServiceModificationType(
    """filter the rows which have to be deleted"""
    where: ServiceModificationTypeBoolExp!
  ): ServiceModificationTypeMutationResponse

  """
  delete single row from the table: "service_modification_type"
  """
  deleteServiceModificationTypeByPk(
    """Modification type (unique)."""
    value: String!
  ): ServiceModificationType

  """
  delete data from the table: "teacher"
  """
  deleteTeacher(
    """filter the rows which have to be deleted"""
    where: TeacherBoolExp!
  ): TeacherMutationResponse

  """
  delete single row from the table: "teacher"
  """
  deleteTeacherByPk(
    """L'identifiant unique de l'intervenant."""
    uid: String!
  ): Teacher

  """
  delete data from the table: "track"
  """
  deleteTrack(
    """filter the rows which have to be deleted"""
    where: TrackBoolExp!
  ): TrackMutationResponse

  """
  delete single row from the table: "track"
  """
  deleteTrackByPk(
    """L'identifiant unique du parcours."""
    id: Int!
  ): Track

  """
  delete data from the table: "year"
  """
  deleteYear(
    """filter the rows which have to be deleted"""
    where: YearBoolExp!
  ): YearMutationResponse

  """
  delete single row from the table: "year"
  """
  deleteYearByPk(
    """Le numéro de l'année (unique)."""
    value: Int!
  ): Year

  """
  insert data into the table: "coordination"
  """
  insertCoordination(
    """the rows to be inserted"""
    objects: [CoordinationInsertInput!]!

    """upsert condition"""
    onConflict: CoordinationOnConflict
  ): CoordinationMutationResponse

  """
  insert a single row into the table: "coordination"
  """
  insertCoordinationOne(
    """the row to be inserted"""
    object: CoordinationInsertInput!

    """upsert condition"""
    onConflict: CoordinationOnConflict
  ): Coordination

  """
  insert data into the table: "course"
  """
  insertCourse(
    """the rows to be inserted"""
    objects: [CourseInsertInput!]!

    """upsert condition"""
    onConflict: CourseOnConflict
  ): CourseMutationResponse

  """
  insert a single row into the table: "course"
  """
  insertCourseOne(
    """the row to be inserted"""
    object: CourseInsertInput!

    """upsert condition"""
    onConflict: CourseOnConflict
  ): Course

  """
  insert data into the table: "course_type"
  """
  insertCourseType(
    """the rows to be inserted"""
    objects: [CourseTypeInsertInput!]!

    """upsert condition"""
    onConflict: CourseTypeOnConflict
  ): CourseTypeMutationResponse

  """
  insert a single row into the table: "course_type"
  """
  insertCourseTypeOne(
    """the row to be inserted"""
    object: CourseTypeInsertInput!

    """upsert condition"""
    onConflict: CourseTypeOnConflict
  ): CourseType

  """
  insert data into the table: "degree"
  """
  insertDegree(
    """the rows to be inserted"""
    objects: [DegreeInsertInput!]!

    """upsert condition"""
    onConflict: DegreeOnConflict
  ): DegreeMutationResponse

  """
  insert a single row into the table: "degree"
  """
  insertDegreeOne(
    """the row to be inserted"""
    object: DegreeInsertInput!

    """upsert condition"""
    onConflict: DegreeOnConflict
  ): Degree

  """
  insert data into the table: "phase"
  """
  insertPhase(
    """the rows to be inserted"""
    objects: [PhaseInsertInput!]!

    """upsert condition"""
    onConflict: PhaseOnConflict
  ): PhaseMutationResponse

  """
  insert a single row into the table: "phase"
  """
  insertPhaseOne(
    """the row to be inserted"""
    object: PhaseInsertInput!

    """upsert condition"""
    onConflict: PhaseOnConflict
  ): Phase

  """
  insert data into the table: "position"
  """
  insertPosition(
    """the rows to be inserted"""
    objects: [PositionInsertInput!]!

    """upsert condition"""
    onConflict: PositionOnConflict
  ): PositionMutationResponse

  """
  insert a single row into the table: "position"
  """
  insertPositionOne(
    """the row to be inserted"""
    object: PositionInsertInput!

    """upsert condition"""
    onConflict: PositionOnConflict
  ): Position

  """
  insert data into the table: "priority"
  """
  insertPriority(
    """the rows to be inserted"""
    objects: [PriorityInsertInput!]!

    """upsert condition"""
    onConflict: PriorityOnConflict
  ): PriorityMutationResponse

  """
  insert a single row into the table: "priority"
  """
  insertPriorityOne(
    """the row to be inserted"""
    object: PriorityInsertInput!

    """upsert condition"""
    onConflict: PriorityOnConflict
  ): Priority

  """
  insert data into the table: "program"
  """
  insertProgram(
    """the rows to be inserted"""
    objects: [ProgramInsertInput!]!

    """upsert condition"""
    onConflict: ProgramOnConflict
  ): ProgramMutationResponse

  """
  insert a single row into the table: "program"
  """
  insertProgramOne(
    """the row to be inserted"""
    object: ProgramInsertInput!

    """upsert condition"""
    onConflict: ProgramOnConflict
  ): Program

  """
  insert data into the table: "request"
  """
  insertRequest(
    """the rows to be inserted"""
    objects: [RequestInsertInput!]!

    """upsert condition"""
    onConflict: RequestOnConflict
  ): RequestMutationResponse

  """
  insert a single row into the table: "request"
  """
  insertRequestOne(
    """the row to be inserted"""
    object: RequestInsertInput!

    """upsert condition"""
    onConflict: RequestOnConflict
  ): Request

  """
  insert data into the table: "request_type"
  """
  insertRequestType(
    """the rows to be inserted"""
    objects: [RequestTypeInsertInput!]!

    """upsert condition"""
    onConflict: RequestTypeOnConflict
  ): RequestTypeMutationResponse

  """
  insert a single row into the table: "request_type"
  """
  insertRequestTypeOne(
    """the row to be inserted"""
    object: RequestTypeInsertInput!

    """upsert condition"""
    onConflict: RequestTypeOnConflict
  ): RequestType

  """
  insert data into the table: "service"
  """
  insertService(
    """the rows to be inserted"""
    objects: [ServiceInsertInput!]!

    """upsert condition"""
    onConflict: ServiceOnConflict
  ): ServiceMutationResponse

  """
  insert data into the table: "service_modification"
  """
  insertServiceModification(
    """the rows to be inserted"""
    objects: [ServiceModificationInsertInput!]!

    """upsert condition"""
    onConflict: ServiceModificationOnConflict
  ): ServiceModificationMutationResponse

  """
  insert a single row into the table: "service_modification"
  """
  insertServiceModificationOne(
    """the row to be inserted"""
    object: ServiceModificationInsertInput!

    """upsert condition"""
    onConflict: ServiceModificationOnConflict
  ): ServiceModification

  """
  insert data into the table: "service_modification_type"
  """
  insertServiceModificationType(
    """the rows to be inserted"""
    objects: [ServiceModificationTypeInsertInput!]!

    """upsert condition"""
    onConflict: ServiceModificationTypeOnConflict
  ): ServiceModificationTypeMutationResponse

  """
  insert a single row into the table: "service_modification_type"
  """
  insertServiceModificationTypeOne(
    """the row to be inserted"""
    object: ServiceModificationTypeInsertInput!

    """upsert condition"""
    onConflict: ServiceModificationTypeOnConflict
  ): ServiceModificationType

  """
  insert a single row into the table: "service"
  """
  insertServiceOne(
    """the row to be inserted"""
    object: ServiceInsertInput!

    """upsert condition"""
    onConflict: ServiceOnConflict
  ): Service

  """
  insert data into the table: "teacher"
  """
  insertTeacher(
    """the rows to be inserted"""
    objects: [TeacherInsertInput!]!

    """upsert condition"""
    onConflict: TeacherOnConflict
  ): TeacherMutationResponse

  """
  insert a single row into the table: "teacher"
  """
  insertTeacherOne(
    """the row to be inserted"""
    object: TeacherInsertInput!

    """upsert condition"""
    onConflict: TeacherOnConflict
  ): Teacher

  """
  insert data into the table: "track"
  """
  insertTrack(
    """the rows to be inserted"""
    objects: [TrackInsertInput!]!

    """upsert condition"""
    onConflict: TrackOnConflict
  ): TrackMutationResponse

  """
  insert a single row into the table: "track"
  """
  insertTrackOne(
    """the row to be inserted"""
    object: TrackInsertInput!

    """upsert condition"""
    onConflict: TrackOnConflict
  ): Track

  """
  insert data into the table: "year"
  """
  insertYear(
    """the rows to be inserted"""
    objects: [YearInsertInput!]!

    """upsert condition"""
    onConflict: YearOnConflict
  ): YearMutationResponse

  """
  insert a single row into the table: "year"
  """
  insertYearOne(
    """the row to be inserted"""
    object: YearInsertInput!

    """upsert condition"""
    onConflict: YearOnConflict
  ): Year

  """
  update data of the table: "coordination"
  """
  updateCoordination(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CoordinationIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: CoordinationSetInput

    """filter the rows which have to be updated"""
    where: CoordinationBoolExp!
  ): CoordinationMutationResponse

  """
  update single row of the table: "coordination"
  """
  updateCoordinationByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CoordinationIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: CoordinationSetInput
    pkColumns: CoordinationPkColumnsInput!
  ): Coordination

  """
  update multiples rows of table: "coordination"
  """
  updateCoordinationMany(
    """updates to execute, in order"""
    updates: [CoordinationUpdates!]!
  ): [CoordinationMutationResponse]

  """
  update data of the table: "course"
  """
  updateCourse(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CourseIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: CourseSetInput

    """filter the rows which have to be updated"""
    where: CourseBoolExp!
  ): CourseMutationResponse

  """
  update single row of the table: "course"
  """
  updateCourseByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CourseIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: CourseSetInput
    pkColumns: CoursePkColumnsInput!
  ): Course

  """
  update multiples rows of table: "course"
  """
  updateCourseMany(
    """updates to execute, in order"""
    updates: [CourseUpdates!]!
  ): [CourseMutationResponse]

  """
  update data of the table: "course_type"
  """
  updateCourseType(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CourseTypeIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: CourseTypeSetInput

    """filter the rows which have to be updated"""
    where: CourseTypeBoolExp!
  ): CourseTypeMutationResponse

  """
  update single row of the table: "course_type"
  """
  updateCourseTypeByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CourseTypeIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: CourseTypeSetInput
    pkColumns: CourseTypePkColumnsInput!
  ): CourseType

  """
  update multiples rows of table: "course_type"
  """
  updateCourseTypeMany(
    """updates to execute, in order"""
    updates: [CourseTypeUpdates!]!
  ): [CourseTypeMutationResponse]

  """
  update data of the table: "degree"
  """
  updateDegree(
    """increments the numeric columns with given value of the filtered values"""
    _inc: DegreeIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: DegreeSetInput

    """filter the rows which have to be updated"""
    where: DegreeBoolExp!
  ): DegreeMutationResponse

  """
  update single row of the table: "degree"
  """
  updateDegreeByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: DegreeIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: DegreeSetInput
    pkColumns: DegreePkColumnsInput!
  ): Degree

  """
  update multiples rows of table: "degree"
  """
  updateDegreeMany(
    """updates to execute, in order"""
    updates: [DegreeUpdates!]!
  ): [DegreeMutationResponse]

  """
  update data of the table: "phase"
  """
  updatePhase(
    """sets the columns of the filtered rows to the given values"""
    _set: PhaseSetInput

    """filter the rows which have to be updated"""
    where: PhaseBoolExp!
  ): PhaseMutationResponse

  """
  update single row of the table: "phase"
  """
  updatePhaseByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: PhaseSetInput
    pkColumns: PhasePkColumnsInput!
  ): Phase

  """
  update multiples rows of table: "phase"
  """
  updatePhaseMany(
    """updates to execute, in order"""
    updates: [PhaseUpdates!]!
  ): [PhaseMutationResponse]

  """
  update data of the table: "position"
  """
  updatePosition(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PositionIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: PositionSetInput

    """filter the rows which have to be updated"""
    where: PositionBoolExp!
  ): PositionMutationResponse

  """
  update single row of the table: "position"
  """
  updatePositionByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PositionIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: PositionSetInput
    pkColumns: PositionPkColumnsInput!
  ): Position

  """
  update multiples rows of table: "position"
  """
  updatePositionMany(
    """updates to execute, in order"""
    updates: [PositionUpdates!]!
  ): [PositionMutationResponse]

  """
  update data of the table: "priority"
  """
  updatePriority(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PriorityIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: PrioritySetInput

    """filter the rows which have to be updated"""
    where: PriorityBoolExp!
  ): PriorityMutationResponse

  """
  update single row of the table: "priority"
  """
  updatePriorityByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PriorityIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: PrioritySetInput
    pkColumns: PriorityPkColumnsInput!
  ): Priority

  """
  update multiples rows of table: "priority"
  """
  updatePriorityMany(
    """updates to execute, in order"""
    updates: [PriorityUpdates!]!
  ): [PriorityMutationResponse]

  """
  update data of the table: "program"
  """
  updateProgram(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ProgramIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ProgramSetInput

    """filter the rows which have to be updated"""
    where: ProgramBoolExp!
  ): ProgramMutationResponse

  """
  update single row of the table: "program"
  """
  updateProgramByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ProgramIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ProgramSetInput
    pkColumns: ProgramPkColumnsInput!
  ): Program

  """
  update multiples rows of table: "program"
  """
  updateProgramMany(
    """updates to execute, in order"""
    updates: [ProgramUpdates!]!
  ): [ProgramMutationResponse]

  """
  update data of the table: "request"
  """
  updateRequest(
    """increments the numeric columns with given value of the filtered values"""
    _inc: RequestIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: RequestSetInput

    """filter the rows which have to be updated"""
    where: RequestBoolExp!
  ): RequestMutationResponse

  """
  update single row of the table: "request"
  """
  updateRequestByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: RequestIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: RequestSetInput
    pkColumns: RequestPkColumnsInput!
  ): Request

  """
  update multiples rows of table: "request"
  """
  updateRequestMany(
    """updates to execute, in order"""
    updates: [RequestUpdates!]!
  ): [RequestMutationResponse]

  """
  update data of the table: "request_type"
  """
  updateRequestType(
    """sets the columns of the filtered rows to the given values"""
    _set: RequestTypeSetInput

    """filter the rows which have to be updated"""
    where: RequestTypeBoolExp!
  ): RequestTypeMutationResponse

  """
  update single row of the table: "request_type"
  """
  updateRequestTypeByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: RequestTypeSetInput
    pkColumns: RequestTypePkColumnsInput!
  ): RequestType

  """
  update multiples rows of table: "request_type"
  """
  updateRequestTypeMany(
    """updates to execute, in order"""
    updates: [RequestTypeUpdates!]!
  ): [RequestTypeMutationResponse]

  """
  update data of the table: "service"
  """
  updateService(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ServiceIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ServiceSetInput

    """filter the rows which have to be updated"""
    where: ServiceBoolExp!
  ): ServiceMutationResponse

  """
  update single row of the table: "service"
  """
  updateServiceByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ServiceIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ServiceSetInput
    pkColumns: ServicePkColumnsInput!
  ): Service

  """
  update multiples rows of table: "service"
  """
  updateServiceMany(
    """updates to execute, in order"""
    updates: [ServiceUpdates!]!
  ): [ServiceMutationResponse]

  """
  update data of the table: "service_modification"
  """
  updateServiceModification(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ServiceModificationIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ServiceModificationSetInput

    """filter the rows which have to be updated"""
    where: ServiceModificationBoolExp!
  ): ServiceModificationMutationResponse

  """
  update single row of the table: "service_modification"
  """
  updateServiceModificationByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ServiceModificationIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ServiceModificationSetInput
    pkColumns: ServiceModificationPkColumnsInput!
  ): ServiceModification

  """
  update multiples rows of table: "service_modification"
  """
  updateServiceModificationMany(
    """updates to execute, in order"""
    updates: [ServiceModificationUpdates!]!
  ): [ServiceModificationMutationResponse]

  """
  update data of the table: "service_modification_type"
  """
  updateServiceModificationType(
    """sets the columns of the filtered rows to the given values"""
    _set: ServiceModificationTypeSetInput

    """filter the rows which have to be updated"""
    where: ServiceModificationTypeBoolExp!
  ): ServiceModificationTypeMutationResponse

  """
  update single row of the table: "service_modification_type"
  """
  updateServiceModificationTypeByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: ServiceModificationTypeSetInput
    pkColumns: ServiceModificationTypePkColumnsInput!
  ): ServiceModificationType

  """
  update multiples rows of table: "service_modification_type"
  """
  updateServiceModificationTypeMany(
    """updates to execute, in order"""
    updates: [ServiceModificationTypeUpdates!]!
  ): [ServiceModificationTypeMutationResponse]

  """
  update data of the table: "teacher"
  """
  updateTeacher(
    """increments the numeric columns with given value of the filtered values"""
    _inc: TeacherIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: TeacherSetInput

    """filter the rows which have to be updated"""
    where: TeacherBoolExp!
  ): TeacherMutationResponse

  """
  update single row of the table: "teacher"
  """
  updateTeacherByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: TeacherIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: TeacherSetInput
    pkColumns: TeacherPkColumnsInput!
  ): Teacher

  """
  update multiples rows of table: "teacher"
  """
  updateTeacherMany(
    """updates to execute, in order"""
    updates: [TeacherUpdates!]!
  ): [TeacherMutationResponse]

  """
  update data of the table: "track"
  """
  updateTrack(
    """increments the numeric columns with given value of the filtered values"""
    _inc: TrackIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: TrackSetInput

    """filter the rows which have to be updated"""
    where: TrackBoolExp!
  ): TrackMutationResponse

  """
  update single row of the table: "track"
  """
  updateTrackByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: TrackIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: TrackSetInput
    pkColumns: TrackPkColumnsInput!
  ): Track

  """
  update multiples rows of table: "track"
  """
  updateTrackMany(
    """updates to execute, in order"""
    updates: [TrackUpdates!]!
  ): [TrackMutationResponse]

  """
  update data of the table: "year"
  """
  updateYear(
    """increments the numeric columns with given value of the filtered values"""
    _inc: YearIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: YearSetInput

    """filter the rows which have to be updated"""
    where: YearBoolExp!
  ): YearMutationResponse

  """
  update single row of the table: "year"
  """
  updateYearByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: YearIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: YearSetInput
    pkColumns: YearPkColumnsInput!
  ): Year

  """
  update multiples rows of table: "year"
  """
  updateYearMany(
    """updates to execute, in order"""
    updates: [YearUpdates!]!
  ): [YearMutationResponse]
}

input priorityAggregateBoolExpBool_and {
  arguments: PrioritySelectColumnPriorityAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: PriorityBoolExp
  predicate: BooleanComparisonExp!
}

input priorityAggregateBoolExpBool_or {
  arguments: PrioritySelectColumnPriorityAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: PriorityBoolExp
  predicate: BooleanComparisonExp!
}

input priorityAggregateBoolExpCount {
  arguments: [PrioritySelectColumn!]
  distinct: Boolean
  filter: PriorityBoolExp
  predicate: IntComparisonExp!
}

input programAggregateBoolExpBool_and {
  arguments: ProgramSelectColumnProgramAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: ProgramBoolExp
  predicate: BooleanComparisonExp!
}

input programAggregateBoolExpBool_or {
  arguments: ProgramSelectColumnProgramAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: ProgramBoolExp
  predicate: BooleanComparisonExp!
}

input programAggregateBoolExpCount {
  arguments: [ProgramSelectColumn!]
  distinct: Boolean
  filter: ProgramBoolExp
  predicate: IntComparisonExp!
}

type query_root {
  """
  fetch data from the table: "coordination"
  """
  coordination(
    """distinct select on columns"""
    distinctOn: [CoordinationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CoordinationOrderBy!]

    """filter the rows returned"""
    where: CoordinationBoolExp
  ): [Coordination!]!

  """
  fetch aggregated fields from the table: "coordination"
  """
  coordinationAggregate(
    """distinct select on columns"""
    distinctOn: [CoordinationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CoordinationOrderBy!]

    """filter the rows returned"""
    where: CoordinationBoolExp
  ): CoordinationAggregate!

  """fetch data from the table: "coordination" using primary key columns"""
  coordinationByPk(
    """Unique identifier for the coordinator entry."""
    id: Int!
  ): Coordination

  """
  fetch data from the table: "course"
  """
  course(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): [Course!]!

  """
  fetch aggregated fields from the table: "course"
  """
  courseAggregate(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): CourseAggregate!

  """fetch data from the table: "course" using primary key columns"""
  courseByPk(
    """L'identifiant unique de l'enseignement."""
    id: Int!
  ): Course

  """
  fetch data from the table: "course_type"
  """
  courseType(
    """distinct select on columns"""
    distinctOn: [CourseTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseTypeOrderBy!]

    """filter the rows returned"""
    where: CourseTypeBoolExp
  ): [CourseType!]!

  """
  fetch aggregated fields from the table: "course_type"
  """
  courseTypeAggregate(
    """distinct select on columns"""
    distinctOn: [CourseTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseTypeOrderBy!]

    """filter the rows returned"""
    where: CourseTypeBoolExp
  ): CourseTypeAggregate!

  """fetch data from the table: "course_type" using primary key columns"""
  courseTypeByPk(
    """La clé du type d'enseignement (unique)."""
    value: String!
  ): CourseType

  """
  fetch data from the table: "degree"
  """
  degree(
    """distinct select on columns"""
    distinctOn: [DegreeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DegreeOrderBy!]

    """filter the rows returned"""
    where: DegreeBoolExp
  ): [Degree!]!

  """
  fetch aggregated fields from the table: "degree"
  """
  degreeAggregate(
    """distinct select on columns"""
    distinctOn: [DegreeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DegreeOrderBy!]

    """filter the rows returned"""
    where: DegreeBoolExp
  ): DegreeAggregate!

  """fetch data from the table: "degree" using primary key columns"""
  degreeByPk(
    """L'identifiant unique du cursus."""
    id: Int!
  ): Degree

  """
  fetch data from the table: "phase"
  """
  phase(
    """distinct select on columns"""
    distinctOn: [PhaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PhaseOrderBy!]

    """filter the rows returned"""
    where: PhaseBoolExp
  ): [Phase!]!

  """
  fetch aggregated fields from the table: "phase"
  """
  phaseAggregate(
    """distinct select on columns"""
    distinctOn: [PhaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PhaseOrderBy!]

    """filter the rows returned"""
    where: PhaseBoolExp
  ): PhaseAggregate!

  """fetch data from the table: "phase" using primary key columns"""
  phaseByPk(
    """Phase identifier."""
    value: String!
  ): Phase

  """
  fetch data from the table: "position"
  """
  position(
    """distinct select on columns"""
    distinctOn: [PositionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PositionOrderBy!]

    """filter the rows returned"""
    where: PositionBoolExp
  ): [Position!]!

  """
  fetch aggregated fields from the table: "position"
  """
  positionAggregate(
    """distinct select on columns"""
    distinctOn: [PositionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PositionOrderBy!]

    """filter the rows returned"""
    where: PositionBoolExp
  ): PositionAggregate!

  """fetch data from the table: "position" using primary key columns"""
  positionByPk(value: String!): Position

  """
  fetch data from the table: "priority"
  """
  priority(
    """distinct select on columns"""
    distinctOn: [PrioritySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PriorityOrderBy!]

    """filter the rows returned"""
    where: PriorityBoolExp
  ): [Priority!]!

  """
  fetch aggregated fields from the table: "priority"
  """
  priorityAggregate(
    """distinct select on columns"""
    distinctOn: [PrioritySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PriorityOrderBy!]

    """filter the rows returned"""
    where: PriorityBoolExp
  ): PriorityAggregate!

  """fetch data from the table: "priority" using primary key columns"""
  priorityByPk(
    """Unique identifier for the priority entry."""
    id: Int!
  ): Priority

  """
  fetch data from the table: "program"
  """
  program(
    """distinct select on columns"""
    distinctOn: [ProgramSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProgramOrderBy!]

    """filter the rows returned"""
    where: ProgramBoolExp
  ): [Program!]!

  """
  fetch aggregated fields from the table: "program"
  """
  programAggregate(
    """distinct select on columns"""
    distinctOn: [ProgramSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProgramOrderBy!]

    """filter the rows returned"""
    where: ProgramBoolExp
  ): ProgramAggregate!

  """fetch data from the table: "program" using primary key columns"""
  programByPk(
    """L'identifiant unique de la mention."""
    id: Int!
  ): Program

  """
  fetch data from the table: "request"
  """
  request(
    """distinct select on columns"""
    distinctOn: [RequestSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RequestOrderBy!]

    """filter the rows returned"""
    where: RequestBoolExp
  ): [Request!]!

  """
  fetch aggregated fields from the table: "request"
  """
  requestAggregate(
    """distinct select on columns"""
    distinctOn: [RequestSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RequestOrderBy!]

    """filter the rows returned"""
    where: RequestBoolExp
  ): RequestAggregate!

  """fetch data from the table: "request" using primary key columns"""
  requestByPk(id: Int!): Request

  """
  fetch data from the table: "request_type"
  """
  requestType(
    """distinct select on columns"""
    distinctOn: [RequestTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RequestTypeOrderBy!]

    """filter the rows returned"""
    where: RequestTypeBoolExp
  ): [RequestType!]!

  """
  fetch aggregated fields from the table: "request_type"
  """
  requestTypeAggregate(
    """distinct select on columns"""
    distinctOn: [RequestTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RequestTypeOrderBy!]

    """filter the rows returned"""
    where: RequestTypeBoolExp
  ): RequestTypeAggregate!

  """fetch data from the table: "request_type" using primary key columns"""
  requestTypeByPk(
    """Le type de demande (unique)."""
    value: String!
  ): RequestType

  """
  fetch data from the table: "service"
  """
  service(
    """distinct select on columns"""
    distinctOn: [ServiceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceOrderBy!]

    """filter the rows returned"""
    where: ServiceBoolExp
  ): [Service!]!

  """
  fetch aggregated fields from the table: "service"
  """
  serviceAggregate(
    """distinct select on columns"""
    distinctOn: [ServiceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceOrderBy!]

    """filter the rows returned"""
    where: ServiceBoolExp
  ): ServiceAggregate!

  """fetch data from the table: "service" using primary key columns"""
  serviceByPk(
    """L'identifiant unique du service."""
    id: Int!
  ): Service

  """
  fetch data from the table: "service_modification"
  """
  serviceModification(
    """distinct select on columns"""
    distinctOn: [ServiceModificationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceModificationOrderBy!]

    """filter the rows returned"""
    where: ServiceModificationBoolExp
  ): [ServiceModification!]!

  """
  fetch aggregated fields from the table: "service_modification"
  """
  serviceModificationAggregate(
    """distinct select on columns"""
    distinctOn: [ServiceModificationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceModificationOrderBy!]

    """filter the rows returned"""
    where: ServiceModificationBoolExp
  ): ServiceModificationAggregate!

  """
  fetch data from the table: "service_modification" using primary key columns
  """
  serviceModificationByPk(
    """Unique identifier for the modification."""
    id: Int!
  ): ServiceModification

  """
  fetch data from the table: "service_modification_type"
  """
  serviceModificationType(
    """distinct select on columns"""
    distinctOn: [ServiceModificationTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceModificationTypeOrderBy!]

    """filter the rows returned"""
    where: ServiceModificationTypeBoolExp
  ): [ServiceModificationType!]!

  """
  fetch aggregated fields from the table: "service_modification_type"
  """
  serviceModificationTypeAggregate(
    """distinct select on columns"""
    distinctOn: [ServiceModificationTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceModificationTypeOrderBy!]

    """filter the rows returned"""
    where: ServiceModificationTypeBoolExp
  ): ServiceModificationTypeAggregate!

  """
  fetch data from the table: "service_modification_type" using primary key columns
  """
  serviceModificationTypeByPk(
    """Modification type (unique)."""
    value: String!
  ): ServiceModificationType

  """
  fetch data from the table: "teacher"
  """
  teacher(
    """distinct select on columns"""
    distinctOn: [TeacherSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TeacherOrderBy!]

    """filter the rows returned"""
    where: TeacherBoolExp
  ): [Teacher!]!

  """
  fetch aggregated fields from the table: "teacher"
  """
  teacherAggregate(
    """distinct select on columns"""
    distinctOn: [TeacherSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TeacherOrderBy!]

    """filter the rows returned"""
    where: TeacherBoolExp
  ): TeacherAggregate!

  """fetch data from the table: "teacher" using primary key columns"""
  teacherByPk(
    """L'identifiant unique de l'intervenant."""
    uid: String!
  ): Teacher

  """
  fetch data from the table: "track"
  """
  track(
    """distinct select on columns"""
    distinctOn: [TrackSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TrackOrderBy!]

    """filter the rows returned"""
    where: TrackBoolExp
  ): [Track!]!

  """
  fetch aggregated fields from the table: "track"
  """
  trackAggregate(
    """distinct select on columns"""
    distinctOn: [TrackSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TrackOrderBy!]

    """filter the rows returned"""
    where: TrackBoolExp
  ): TrackAggregate!

  """fetch data from the table: "track" using primary key columns"""
  trackByPk(
    """L'identifiant unique du parcours."""
    id: Int!
  ): Track

  """
  fetch data from the table: "year"
  """
  year(
    """distinct select on columns"""
    distinctOn: [YearSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [YearOrderBy!]

    """filter the rows returned"""
    where: YearBoolExp
  ): [Year!]!

  """
  fetch aggregated fields from the table: "year"
  """
  yearAggregate(
    """distinct select on columns"""
    distinctOn: [YearSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [YearOrderBy!]

    """filter the rows returned"""
    where: YearBoolExp
  ): YearAggregate!

  """fetch data from the table: "year" using primary key columns"""
  yearByPk(
    """Le numéro de l'année (unique)."""
    value: Int!
  ): Year
}

input requestAggregateBoolExpCount {
  arguments: [RequestSelectColumn!]
  distinct: Boolean
  filter: RequestBoolExp
  predicate: IntComparisonExp!
}

input serviceAggregateBoolExpCount {
  arguments: [ServiceSelectColumn!]
  distinct: Boolean
  filter: ServiceBoolExp
  predicate: IntComparisonExp!
}

input serviceModificationAggregateBoolExpCount {
  arguments: [ServiceModificationSelectColumn!]
  distinct: Boolean
  filter: ServiceModificationBoolExp
  predicate: IntComparisonExp!
}

type subscription_root {
  """
  fetch data from the table: "coordination"
  """
  coordination(
    """distinct select on columns"""
    distinctOn: [CoordinationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CoordinationOrderBy!]

    """filter the rows returned"""
    where: CoordinationBoolExp
  ): [Coordination!]!

  """
  fetch aggregated fields from the table: "coordination"
  """
  coordinationAggregate(
    """distinct select on columns"""
    distinctOn: [CoordinationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CoordinationOrderBy!]

    """filter the rows returned"""
    where: CoordinationBoolExp
  ): CoordinationAggregate!

  """fetch data from the table: "coordination" using primary key columns"""
  coordinationByPk(
    """Unique identifier for the coordinator entry."""
    id: Int!
  ): Coordination

  """
  fetch data from the table in a streaming manner: "coordination"
  """
  coordinationStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CoordinationStreamCursorInput]!

    """filter the rows returned"""
    where: CoordinationBoolExp
  ): [Coordination!]!

  """
  fetch data from the table: "course"
  """
  course(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): [Course!]!

  """
  fetch aggregated fields from the table: "course"
  """
  courseAggregate(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): CourseAggregate!

  """fetch data from the table: "course" using primary key columns"""
  courseByPk(
    """L'identifiant unique de l'enseignement."""
    id: Int!
  ): Course

  """
  fetch data from the table in a streaming manner: "course"
  """
  courseStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CourseStreamCursorInput]!

    """filter the rows returned"""
    where: CourseBoolExp
  ): [Course!]!

  """
  fetch data from the table: "course_type"
  """
  courseType(
    """distinct select on columns"""
    distinctOn: [CourseTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseTypeOrderBy!]

    """filter the rows returned"""
    where: CourseTypeBoolExp
  ): [CourseType!]!

  """
  fetch aggregated fields from the table: "course_type"
  """
  courseTypeAggregate(
    """distinct select on columns"""
    distinctOn: [CourseTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseTypeOrderBy!]

    """filter the rows returned"""
    where: CourseTypeBoolExp
  ): CourseTypeAggregate!

  """fetch data from the table: "course_type" using primary key columns"""
  courseTypeByPk(
    """La clé du type d'enseignement (unique)."""
    value: String!
  ): CourseType

  """
  fetch data from the table in a streaming manner: "course_type"
  """
  courseTypeStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CourseTypeStreamCursorInput]!

    """filter the rows returned"""
    where: CourseTypeBoolExp
  ): [CourseType!]!

  """
  fetch data from the table: "degree"
  """
  degree(
    """distinct select on columns"""
    distinctOn: [DegreeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DegreeOrderBy!]

    """filter the rows returned"""
    where: DegreeBoolExp
  ): [Degree!]!

  """
  fetch aggregated fields from the table: "degree"
  """
  degreeAggregate(
    """distinct select on columns"""
    distinctOn: [DegreeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DegreeOrderBy!]

    """filter the rows returned"""
    where: DegreeBoolExp
  ): DegreeAggregate!

  """fetch data from the table: "degree" using primary key columns"""
  degreeByPk(
    """L'identifiant unique du cursus."""
    id: Int!
  ): Degree

  """
  fetch data from the table in a streaming manner: "degree"
  """
  degreeStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [DegreeStreamCursorInput]!

    """filter the rows returned"""
    where: DegreeBoolExp
  ): [Degree!]!

  """
  fetch data from the table: "phase"
  """
  phase(
    """distinct select on columns"""
    distinctOn: [PhaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PhaseOrderBy!]

    """filter the rows returned"""
    where: PhaseBoolExp
  ): [Phase!]!

  """
  fetch aggregated fields from the table: "phase"
  """
  phaseAggregate(
    """distinct select on columns"""
    distinctOn: [PhaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PhaseOrderBy!]

    """filter the rows returned"""
    where: PhaseBoolExp
  ): PhaseAggregate!

  """fetch data from the table: "phase" using primary key columns"""
  phaseByPk(
    """Phase identifier."""
    value: String!
  ): Phase

  """
  fetch data from the table in a streaming manner: "phase"
  """
  phaseStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PhaseStreamCursorInput]!

    """filter the rows returned"""
    where: PhaseBoolExp
  ): [Phase!]!

  """
  fetch data from the table: "position"
  """
  position(
    """distinct select on columns"""
    distinctOn: [PositionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PositionOrderBy!]

    """filter the rows returned"""
    where: PositionBoolExp
  ): [Position!]!

  """
  fetch aggregated fields from the table: "position"
  """
  positionAggregate(
    """distinct select on columns"""
    distinctOn: [PositionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PositionOrderBy!]

    """filter the rows returned"""
    where: PositionBoolExp
  ): PositionAggregate!

  """fetch data from the table: "position" using primary key columns"""
  positionByPk(value: String!): Position

  """
  fetch data from the table in a streaming manner: "position"
  """
  positionStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PositionStreamCursorInput]!

    """filter the rows returned"""
    where: PositionBoolExp
  ): [Position!]!

  """
  fetch data from the table: "priority"
  """
  priority(
    """distinct select on columns"""
    distinctOn: [PrioritySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PriorityOrderBy!]

    """filter the rows returned"""
    where: PriorityBoolExp
  ): [Priority!]!

  """
  fetch aggregated fields from the table: "priority"
  """
  priorityAggregate(
    """distinct select on columns"""
    distinctOn: [PrioritySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PriorityOrderBy!]

    """filter the rows returned"""
    where: PriorityBoolExp
  ): PriorityAggregate!

  """fetch data from the table: "priority" using primary key columns"""
  priorityByPk(
    """Unique identifier for the priority entry."""
    id: Int!
  ): Priority

  """
  fetch data from the table in a streaming manner: "priority"
  """
  priorityStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PriorityStreamCursorInput]!

    """filter the rows returned"""
    where: PriorityBoolExp
  ): [Priority!]!

  """
  fetch data from the table: "program"
  """
  program(
    """distinct select on columns"""
    distinctOn: [ProgramSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProgramOrderBy!]

    """filter the rows returned"""
    where: ProgramBoolExp
  ): [Program!]!

  """
  fetch aggregated fields from the table: "program"
  """
  programAggregate(
    """distinct select on columns"""
    distinctOn: [ProgramSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProgramOrderBy!]

    """filter the rows returned"""
    where: ProgramBoolExp
  ): ProgramAggregate!

  """fetch data from the table: "program" using primary key columns"""
  programByPk(
    """L'identifiant unique de la mention."""
    id: Int!
  ): Program

  """
  fetch data from the table in a streaming manner: "program"
  """
  programStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ProgramStreamCursorInput]!

    """filter the rows returned"""
    where: ProgramBoolExp
  ): [Program!]!

  """
  fetch data from the table: "request"
  """
  request(
    """distinct select on columns"""
    distinctOn: [RequestSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RequestOrderBy!]

    """filter the rows returned"""
    where: RequestBoolExp
  ): [Request!]!

  """
  fetch aggregated fields from the table: "request"
  """
  requestAggregate(
    """distinct select on columns"""
    distinctOn: [RequestSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RequestOrderBy!]

    """filter the rows returned"""
    where: RequestBoolExp
  ): RequestAggregate!

  """fetch data from the table: "request" using primary key columns"""
  requestByPk(id: Int!): Request

  """
  fetch data from the table in a streaming manner: "request"
  """
  requestStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [RequestStreamCursorInput]!

    """filter the rows returned"""
    where: RequestBoolExp
  ): [Request!]!

  """
  fetch data from the table: "request_type"
  """
  requestType(
    """distinct select on columns"""
    distinctOn: [RequestTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RequestTypeOrderBy!]

    """filter the rows returned"""
    where: RequestTypeBoolExp
  ): [RequestType!]!

  """
  fetch aggregated fields from the table: "request_type"
  """
  requestTypeAggregate(
    """distinct select on columns"""
    distinctOn: [RequestTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RequestTypeOrderBy!]

    """filter the rows returned"""
    where: RequestTypeBoolExp
  ): RequestTypeAggregate!

  """fetch data from the table: "request_type" using primary key columns"""
  requestTypeByPk(
    """Le type de demande (unique)."""
    value: String!
  ): RequestType

  """
  fetch data from the table in a streaming manner: "request_type"
  """
  requestTypeStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [RequestTypeStreamCursorInput]!

    """filter the rows returned"""
    where: RequestTypeBoolExp
  ): [RequestType!]!

  """
  fetch data from the table: "service"
  """
  service(
    """distinct select on columns"""
    distinctOn: [ServiceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceOrderBy!]

    """filter the rows returned"""
    where: ServiceBoolExp
  ): [Service!]!

  """
  fetch aggregated fields from the table: "service"
  """
  serviceAggregate(
    """distinct select on columns"""
    distinctOn: [ServiceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceOrderBy!]

    """filter the rows returned"""
    where: ServiceBoolExp
  ): ServiceAggregate!

  """fetch data from the table: "service" using primary key columns"""
  serviceByPk(
    """L'identifiant unique du service."""
    id: Int!
  ): Service

  """
  fetch data from the table: "service_modification"
  """
  serviceModification(
    """distinct select on columns"""
    distinctOn: [ServiceModificationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceModificationOrderBy!]

    """filter the rows returned"""
    where: ServiceModificationBoolExp
  ): [ServiceModification!]!

  """
  fetch aggregated fields from the table: "service_modification"
  """
  serviceModificationAggregate(
    """distinct select on columns"""
    distinctOn: [ServiceModificationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceModificationOrderBy!]

    """filter the rows returned"""
    where: ServiceModificationBoolExp
  ): ServiceModificationAggregate!

  """
  fetch data from the table: "service_modification" using primary key columns
  """
  serviceModificationByPk(
    """Unique identifier for the modification."""
    id: Int!
  ): ServiceModification

  """
  fetch data from the table in a streaming manner: "service_modification"
  """
  serviceModificationStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ServiceModificationStreamCursorInput]!

    """filter the rows returned"""
    where: ServiceModificationBoolExp
  ): [ServiceModification!]!

  """
  fetch data from the table: "service_modification_type"
  """
  serviceModificationType(
    """distinct select on columns"""
    distinctOn: [ServiceModificationTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceModificationTypeOrderBy!]

    """filter the rows returned"""
    where: ServiceModificationTypeBoolExp
  ): [ServiceModificationType!]!

  """
  fetch aggregated fields from the table: "service_modification_type"
  """
  serviceModificationTypeAggregate(
    """distinct select on columns"""
    distinctOn: [ServiceModificationTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceModificationTypeOrderBy!]

    """filter the rows returned"""
    where: ServiceModificationTypeBoolExp
  ): ServiceModificationTypeAggregate!

  """
  fetch data from the table: "service_modification_type" using primary key columns
  """
  serviceModificationTypeByPk(
    """Modification type (unique)."""
    value: String!
  ): ServiceModificationType

  """
  fetch data from the table in a streaming manner: "service_modification_type"
  """
  serviceModificationTypeStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ServiceModificationTypeStreamCursorInput]!

    """filter the rows returned"""
    where: ServiceModificationTypeBoolExp
  ): [ServiceModificationType!]!

  """
  fetch data from the table in a streaming manner: "service"
  """
  serviceStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ServiceStreamCursorInput]!

    """filter the rows returned"""
    where: ServiceBoolExp
  ): [Service!]!

  """
  fetch data from the table: "teacher"
  """
  teacher(
    """distinct select on columns"""
    distinctOn: [TeacherSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TeacherOrderBy!]

    """filter the rows returned"""
    where: TeacherBoolExp
  ): [Teacher!]!

  """
  fetch aggregated fields from the table: "teacher"
  """
  teacherAggregate(
    """distinct select on columns"""
    distinctOn: [TeacherSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TeacherOrderBy!]

    """filter the rows returned"""
    where: TeacherBoolExp
  ): TeacherAggregate!

  """fetch data from the table: "teacher" using primary key columns"""
  teacherByPk(
    """L'identifiant unique de l'intervenant."""
    uid: String!
  ): Teacher

  """
  fetch data from the table in a streaming manner: "teacher"
  """
  teacherStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [TeacherStreamCursorInput]!

    """filter the rows returned"""
    where: TeacherBoolExp
  ): [Teacher!]!

  """
  fetch data from the table: "track"
  """
  track(
    """distinct select on columns"""
    distinctOn: [TrackSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TrackOrderBy!]

    """filter the rows returned"""
    where: TrackBoolExp
  ): [Track!]!

  """
  fetch aggregated fields from the table: "track"
  """
  trackAggregate(
    """distinct select on columns"""
    distinctOn: [TrackSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TrackOrderBy!]

    """filter the rows returned"""
    where: TrackBoolExp
  ): TrackAggregate!

  """fetch data from the table: "track" using primary key columns"""
  trackByPk(
    """L'identifiant unique du parcours."""
    id: Int!
  ): Track

  """
  fetch data from the table in a streaming manner: "track"
  """
  trackStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [TrackStreamCursorInput]!

    """filter the rows returned"""
    where: TrackBoolExp
  ): [Track!]!

  """
  fetch data from the table: "year"
  """
  year(
    """distinct select on columns"""
    distinctOn: [YearSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [YearOrderBy!]

    """filter the rows returned"""
    where: YearBoolExp
  ): [Year!]!

  """
  fetch aggregated fields from the table: "year"
  """
  yearAggregate(
    """distinct select on columns"""
    distinctOn: [YearSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [YearOrderBy!]

    """filter the rows returned"""
    where: YearBoolExp
  ): YearAggregate!

  """fetch data from the table: "year" using primary key columns"""
  yearByPk(
    """Le numéro de l'année (unique)."""
    value: Int!
  ): Year

  """
  fetch data from the table in a streaming manner: "year"
  """
  yearStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [YearStreamCursorInput]!

    """filter the rows returned"""
    where: YearBoolExp
  ): [Year!]!
}

input teacherAggregateBoolExpBool_and {
  arguments: TeacherSelectColumnTeacherAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: TeacherBoolExp
  predicate: BooleanComparisonExp!
}

input teacherAggregateBoolExpBool_or {
  arguments: TeacherSelectColumnTeacherAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: TeacherBoolExp
  predicate: BooleanComparisonExp!
}

input teacherAggregateBoolExpCount {
  arguments: [TeacherSelectColumn!]
  distinct: Boolean
  filter: TeacherBoolExp
  predicate: IntComparisonExp!
}

scalar timestamptz

input trackAggregateBoolExpBool_and {
  arguments: TrackSelectColumnTrackAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: TrackBoolExp
  predicate: BooleanComparisonExp!
}

input trackAggregateBoolExpBool_or {
  arguments: TrackSelectColumnTrackAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: TrackBoolExp
  predicate: BooleanComparisonExp!
}

input trackAggregateBoolExpCount {
  arguments: [TrackSelectColumn!]
  distinct: Boolean
  filter: TrackBoolExp
  predicate: IntComparisonExp!
}