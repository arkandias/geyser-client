schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """refresh the cache entry"""
  refresh: Boolean! = false

  """measured in seconds"""
  ttl: Int! = 60
) on QUERY

"""Custom application configuration settings"""
type AppSetting {
  """Timestamp when the record was created"""
  createdAt: timestamptz!

  """Setting identifier"""
  key: String!

  """Human-readable setting name for display purposes"""
  label: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz!

  """Setting value stored as text"""
  value: String
}

"""
aggregated selection of "app_setting"
"""
type AppSettingAggregate {
  aggregate: AppSettingAggregateFields
  nodes: [AppSetting!]!
}

"""
aggregate fields of "app_setting"
"""
type AppSettingAggregateFields {
  count(columns: [AppSettingSelectColumn!], distinct: Boolean): Int!
  max: AppSettingMaxFields
  min: AppSettingMinFields
}

"""
Boolean expression to filter rows from the table "app_setting". All fields are combined with a logical 'AND'.
"""
input AppSettingBoolExp {
  _and: [AppSettingBoolExp!]
  _not: AppSettingBoolExp
  _or: [AppSettingBoolExp!]
  createdAt: TimestamptzComparisonExp
  key: StringComparisonExp
  label: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "app_setting"
"""
enum AppSettingConstraint {
  """
  unique or primary key constraint on columns "key"
  """
  app_settings_pkey
}

"""
input type for inserting data into table "app_setting"
"""
input AppSettingInsertInput {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Setting identifier"""
  key: String

  """Human-readable setting name for display purposes"""
  label: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Setting value stored as text"""
  value: String
}

"""aggregate max on columns"""
type AppSettingMaxFields {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Setting identifier"""
  key: String

  """Human-readable setting name for display purposes"""
  label: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Setting value stored as text"""
  value: String
}

"""aggregate min on columns"""
type AppSettingMinFields {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Setting identifier"""
  key: String

  """Human-readable setting name for display purposes"""
  label: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Setting value stored as text"""
  value: String
}

"""
response of any mutation on the table "app_setting"
"""
type AppSettingMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [AppSetting!]!
}

"""
on_conflict condition type for table "app_setting"
"""
input AppSettingOnConflict {
  constraint: AppSettingConstraint!
  updateColumns: [AppSettingUpdateColumn!]! = []
  where: AppSettingBoolExp
}

"""Ordering options when selecting data from "app_setting"."""
input AppSettingOrderBy {
  createdAt: OrderBy
  key: OrderBy
  label: OrderBy
  updatedAt: OrderBy
  value: OrderBy
}

"""primary key columns input for table: app_setting"""
input AppSettingPkColumnsInput {
  """Setting identifier"""
  key: String!
}

"""
select columns of table "app_setting"
"""
enum AppSettingSelectColumn {
  """column name"""
  createdAt

  """column name"""
  key

  """column name"""
  label

  """column name"""
  updatedAt

  """column name"""
  value
}

"""
input type for updating data in table "app_setting"
"""
input AppSettingSetInput {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Setting identifier"""
  key: String

  """Human-readable setting name for display purposes"""
  label: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Setting value stored as text"""
  value: String
}

"""
Streaming cursor of the table "app_setting"
"""
input AppSettingStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: AppSettingStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input AppSettingStreamCursorValueInput {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Setting identifier"""
  key: String

  """Human-readable setting name for display purposes"""
  label: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Setting value stored as text"""
  value: String
}

"""
update columns of table "app_setting"
"""
enum AppSettingUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  key

  """column name"""
  label

  """column name"""
  updatedAt

  """column name"""
  value
}

input AppSettingUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: AppSettingSetInput

  """filter the rows which have to be updated"""
  where: AppSettingBoolExp!
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input BooleanComparisonExp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _isNull: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""Academic coordination assignments at program, track, or course level"""
type Coordination {
  """Additional coordination details"""
  comment: String

  """An object relationship"""
  course: Course

  """
  Course being coordinated (mutually exclusive with program_id and track_id)
  """
  courseId: Int

  """Timestamp when the record was created"""
  createdAt: timestamptz!

  """Unique coordination identifier"""
  id: Int!

  """An object relationship"""
  program: Program

  """
  Program being coordinated (mutually exclusive with track_id and course_id)
  """
  programId: Int

  """An object relationship"""
  teacher: Teacher!

  """An object relationship"""
  track: Track

  """
  Track being coordinated (mutually exclusive with program_id and course_id)
  """
  trackId: Int

  """Coordinating teacher"""
  uid: String!

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz!
}

"""
aggregated selection of "coordination"
"""
type CoordinationAggregate {
  aggregate: CoordinationAggregateFields
  nodes: [Coordination!]!
}

input CoordinationAggregateBoolExp {
  count: coordinationAggregateBoolExpCount
}

"""
aggregate fields of "coordination"
"""
type CoordinationAggregateFields {
  avg: CoordinationAvgFields
  count(columns: [CoordinationSelectColumn!], distinct: Boolean): Int!
  max: CoordinationMaxFields
  min: CoordinationMinFields
  stddev: CoordinationStddevFields
  stddevPop: CoordinationStddevPopFields
  stddevSamp: CoordinationStddevSampFields
  sum: CoordinationSumFields
  varPop: CoordinationVarPopFields
  varSamp: CoordinationVarSampFields
  variance: CoordinationVarianceFields
}

"""
order by aggregate values of table "coordination"
"""
input CoordinationAggregateOrderBy {
  avg: CoordinationAvgOrderBy
  count: OrderBy
  max: CoordinationMaxOrderBy
  min: CoordinationMinOrderBy
  stddev: CoordinationStddevOrderBy
  stddevPop: CoordinationStddevPopOrderBy
  stddevSamp: CoordinationStddevSampOrderBy
  sum: CoordinationSumOrderBy
  varPop: CoordinationVarPopOrderBy
  varSamp: CoordinationVarSampOrderBy
  variance: CoordinationVarianceOrderBy
}

"""
input type for inserting array relation for remote table "coordination"
"""
input CoordinationArrRelInsertInput {
  data: [CoordinationInsertInput!]!

  """upsert condition"""
  onConflict: CoordinationOnConflict
}

"""aggregate avg on columns"""
type CoordinationAvgFields {
  """
  Course being coordinated (mutually exclusive with program_id and track_id)
  """
  courseId: Float

  """Unique coordination identifier"""
  id: Float

  """
  Program being coordinated (mutually exclusive with track_id and course_id)
  """
  programId: Float

  """
  Track being coordinated (mutually exclusive with program_id and course_id)
  """
  trackId: Float
}

"""
order by avg() on columns of table "coordination"
"""
input CoordinationAvgOrderBy {
  """
  Course being coordinated (mutually exclusive with program_id and track_id)
  """
  courseId: OrderBy

  """Unique coordination identifier"""
  id: OrderBy

  """
  Program being coordinated (mutually exclusive with track_id and course_id)
  """
  programId: OrderBy

  """
  Track being coordinated (mutually exclusive with program_id and course_id)
  """
  trackId: OrderBy
}

"""
Boolean expression to filter rows from the table "coordination". All fields are combined with a logical 'AND'.
"""
input CoordinationBoolExp {
  _and: [CoordinationBoolExp!]
  _not: CoordinationBoolExp
  _or: [CoordinationBoolExp!]
  comment: StringComparisonExp
  course: CourseBoolExp
  courseId: IntComparisonExp
  createdAt: TimestamptzComparisonExp
  id: IntComparisonExp
  program: ProgramBoolExp
  programId: IntComparisonExp
  teacher: TeacherBoolExp
  track: TrackBoolExp
  trackId: IntComparisonExp
  uid: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "coordination"
"""
enum CoordinationConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  coordination_pkey

  """
  unique or primary key constraint on columns "track_id", "uid", "course_id", "program_id"
  """
  coordination_uid_course_id_track_id_program_id_key
}

"""
input type for incrementing numeric columns in table "coordination"
"""
input CoordinationIncInput {
  """
  Course being coordinated (mutually exclusive with program_id and track_id)
  """
  courseId: Int

  """Unique coordination identifier"""
  id: Int

  """
  Program being coordinated (mutually exclusive with track_id and course_id)
  """
  programId: Int

  """
  Track being coordinated (mutually exclusive with program_id and course_id)
  """
  trackId: Int
}

"""
input type for inserting data into table "coordination"
"""
input CoordinationInsertInput {
  """Additional coordination details"""
  comment: String
  course: CourseObjRelInsertInput

  """
  Course being coordinated (mutually exclusive with program_id and track_id)
  """
  courseId: Int

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Unique coordination identifier"""
  id: Int
  program: ProgramObjRelInsertInput

  """
  Program being coordinated (mutually exclusive with track_id and course_id)
  """
  programId: Int
  teacher: TeacherObjRelInsertInput
  track: TrackObjRelInsertInput

  """
  Track being coordinated (mutually exclusive with program_id and course_id)
  """
  trackId: Int

  """Coordinating teacher"""
  uid: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type CoordinationMaxFields {
  """Additional coordination details"""
  comment: String

  """
  Course being coordinated (mutually exclusive with program_id and track_id)
  """
  courseId: Int

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Unique coordination identifier"""
  id: Int

  """
  Program being coordinated (mutually exclusive with track_id and course_id)
  """
  programId: Int

  """
  Track being coordinated (mutually exclusive with program_id and course_id)
  """
  trackId: Int

  """Coordinating teacher"""
  uid: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""
order by max() on columns of table "coordination"
"""
input CoordinationMaxOrderBy {
  """Additional coordination details"""
  comment: OrderBy

  """
  Course being coordinated (mutually exclusive with program_id and track_id)
  """
  courseId: OrderBy

  """Timestamp when the record was created"""
  createdAt: OrderBy

  """Unique coordination identifier"""
  id: OrderBy

  """
  Program being coordinated (mutually exclusive with track_id and course_id)
  """
  programId: OrderBy

  """
  Track being coordinated (mutually exclusive with program_id and course_id)
  """
  trackId: OrderBy

  """Coordinating teacher"""
  uid: OrderBy

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type CoordinationMinFields {
  """Additional coordination details"""
  comment: String

  """
  Course being coordinated (mutually exclusive with program_id and track_id)
  """
  courseId: Int

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Unique coordination identifier"""
  id: Int

  """
  Program being coordinated (mutually exclusive with track_id and course_id)
  """
  programId: Int

  """
  Track being coordinated (mutually exclusive with program_id and course_id)
  """
  trackId: Int

  """Coordinating teacher"""
  uid: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""
order by min() on columns of table "coordination"
"""
input CoordinationMinOrderBy {
  """Additional coordination details"""
  comment: OrderBy

  """
  Course being coordinated (mutually exclusive with program_id and track_id)
  """
  courseId: OrderBy

  """Timestamp when the record was created"""
  createdAt: OrderBy

  """Unique coordination identifier"""
  id: OrderBy

  """
  Program being coordinated (mutually exclusive with track_id and course_id)
  """
  programId: OrderBy

  """
  Track being coordinated (mutually exclusive with program_id and course_id)
  """
  trackId: OrderBy

  """Coordinating teacher"""
  uid: OrderBy

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: OrderBy
}

"""
response of any mutation on the table "coordination"
"""
type CoordinationMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Coordination!]!
}

"""
on_conflict condition type for table "coordination"
"""
input CoordinationOnConflict {
  constraint: CoordinationConstraint!
  updateColumns: [CoordinationUpdateColumn!]! = []
  where: CoordinationBoolExp
}

"""Ordering options when selecting data from "coordination"."""
input CoordinationOrderBy {
  comment: OrderBy
  course: CourseOrderBy
  courseId: OrderBy
  createdAt: OrderBy
  id: OrderBy
  program: ProgramOrderBy
  programId: OrderBy
  teacher: TeacherOrderBy
  track: TrackOrderBy
  trackId: OrderBy
  uid: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: coordination"""
input CoordinationPkColumnsInput {
  """Unique coordination identifier"""
  id: Int!
}

"""
select columns of table "coordination"
"""
enum CoordinationSelectColumn {
  """column name"""
  comment

  """column name"""
  courseId

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  programId

  """column name"""
  trackId

  """column name"""
  uid

  """column name"""
  updatedAt
}

"""
input type for updating data in table "coordination"
"""
input CoordinationSetInput {
  """Additional coordination details"""
  comment: String

  """
  Course being coordinated (mutually exclusive with program_id and track_id)
  """
  courseId: Int

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Unique coordination identifier"""
  id: Int

  """
  Program being coordinated (mutually exclusive with track_id and course_id)
  """
  programId: Int

  """
  Track being coordinated (mutually exclusive with program_id and course_id)
  """
  trackId: Int

  """Coordinating teacher"""
  uid: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type CoordinationStddevFields {
  """
  Course being coordinated (mutually exclusive with program_id and track_id)
  """
  courseId: Float

  """Unique coordination identifier"""
  id: Float

  """
  Program being coordinated (mutually exclusive with track_id and course_id)
  """
  programId: Float

  """
  Track being coordinated (mutually exclusive with program_id and course_id)
  """
  trackId: Float
}

"""
order by stddev() on columns of table "coordination"
"""
input CoordinationStddevOrderBy {
  """
  Course being coordinated (mutually exclusive with program_id and track_id)
  """
  courseId: OrderBy

  """Unique coordination identifier"""
  id: OrderBy

  """
  Program being coordinated (mutually exclusive with track_id and course_id)
  """
  programId: OrderBy

  """
  Track being coordinated (mutually exclusive with program_id and course_id)
  """
  trackId: OrderBy
}

"""aggregate stddevPop on columns"""
type CoordinationStddevPopFields {
  """
  Course being coordinated (mutually exclusive with program_id and track_id)
  """
  courseId: Float

  """Unique coordination identifier"""
  id: Float

  """
  Program being coordinated (mutually exclusive with track_id and course_id)
  """
  programId: Float

  """
  Track being coordinated (mutually exclusive with program_id and course_id)
  """
  trackId: Float
}

"""
order by stddevPop() on columns of table "coordination"
"""
input CoordinationStddevPopOrderBy {
  """
  Course being coordinated (mutually exclusive with program_id and track_id)
  """
  courseId: OrderBy

  """Unique coordination identifier"""
  id: OrderBy

  """
  Program being coordinated (mutually exclusive with track_id and course_id)
  """
  programId: OrderBy

  """
  Track being coordinated (mutually exclusive with program_id and course_id)
  """
  trackId: OrderBy
}

"""aggregate stddevSamp on columns"""
type CoordinationStddevSampFields {
  """
  Course being coordinated (mutually exclusive with program_id and track_id)
  """
  courseId: Float

  """Unique coordination identifier"""
  id: Float

  """
  Program being coordinated (mutually exclusive with track_id and course_id)
  """
  programId: Float

  """
  Track being coordinated (mutually exclusive with program_id and course_id)
  """
  trackId: Float
}

"""
order by stddevSamp() on columns of table "coordination"
"""
input CoordinationStddevSampOrderBy {
  """
  Course being coordinated (mutually exclusive with program_id and track_id)
  """
  courseId: OrderBy

  """Unique coordination identifier"""
  id: OrderBy

  """
  Program being coordinated (mutually exclusive with track_id and course_id)
  """
  programId: OrderBy

  """
  Track being coordinated (mutually exclusive with program_id and course_id)
  """
  trackId: OrderBy
}

"""
Streaming cursor of the table "coordination"
"""
input CoordinationStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: CoordinationStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input CoordinationStreamCursorValueInput {
  """Additional coordination details"""
  comment: String

  """
  Course being coordinated (mutually exclusive with program_id and track_id)
  """
  courseId: Int

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Unique coordination identifier"""
  id: Int

  """
  Program being coordinated (mutually exclusive with track_id and course_id)
  """
  programId: Int

  """
  Track being coordinated (mutually exclusive with program_id and course_id)
  """
  trackId: Int

  """Coordinating teacher"""
  uid: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type CoordinationSumFields {
  """
  Course being coordinated (mutually exclusive with program_id and track_id)
  """
  courseId: Int

  """Unique coordination identifier"""
  id: Int

  """
  Program being coordinated (mutually exclusive with track_id and course_id)
  """
  programId: Int

  """
  Track being coordinated (mutually exclusive with program_id and course_id)
  """
  trackId: Int
}

"""
order by sum() on columns of table "coordination"
"""
input CoordinationSumOrderBy {
  """
  Course being coordinated (mutually exclusive with program_id and track_id)
  """
  courseId: OrderBy

  """Unique coordination identifier"""
  id: OrderBy

  """
  Program being coordinated (mutually exclusive with track_id and course_id)
  """
  programId: OrderBy

  """
  Track being coordinated (mutually exclusive with program_id and course_id)
  """
  trackId: OrderBy
}

"""
update columns of table "coordination"
"""
enum CoordinationUpdateColumn {
  """column name"""
  comment

  """column name"""
  courseId

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  programId

  """column name"""
  trackId

  """column name"""
  uid

  """column name"""
  updatedAt
}

input CoordinationUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: CoordinationIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: CoordinationSetInput

  """filter the rows which have to be updated"""
  where: CoordinationBoolExp!
}

"""aggregate varPop on columns"""
type CoordinationVarPopFields {
  """
  Course being coordinated (mutually exclusive with program_id and track_id)
  """
  courseId: Float

  """Unique coordination identifier"""
  id: Float

  """
  Program being coordinated (mutually exclusive with track_id and course_id)
  """
  programId: Float

  """
  Track being coordinated (mutually exclusive with program_id and course_id)
  """
  trackId: Float
}

"""
order by varPop() on columns of table "coordination"
"""
input CoordinationVarPopOrderBy {
  """
  Course being coordinated (mutually exclusive with program_id and track_id)
  """
  courseId: OrderBy

  """Unique coordination identifier"""
  id: OrderBy

  """
  Program being coordinated (mutually exclusive with track_id and course_id)
  """
  programId: OrderBy

  """
  Track being coordinated (mutually exclusive with program_id and course_id)
  """
  trackId: OrderBy
}

"""aggregate varSamp on columns"""
type CoordinationVarSampFields {
  """
  Course being coordinated (mutually exclusive with program_id and track_id)
  """
  courseId: Float

  """Unique coordination identifier"""
  id: Float

  """
  Program being coordinated (mutually exclusive with track_id and course_id)
  """
  programId: Float

  """
  Track being coordinated (mutually exclusive with program_id and course_id)
  """
  trackId: Float
}

"""
order by varSamp() on columns of table "coordination"
"""
input CoordinationVarSampOrderBy {
  """
  Course being coordinated (mutually exclusive with program_id and track_id)
  """
  courseId: OrderBy

  """Unique coordination identifier"""
  id: OrderBy

  """
  Program being coordinated (mutually exclusive with track_id and course_id)
  """
  programId: OrderBy

  """
  Track being coordinated (mutually exclusive with program_id and course_id)
  """
  trackId: OrderBy
}

"""aggregate variance on columns"""
type CoordinationVarianceFields {
  """
  Course being coordinated (mutually exclusive with program_id and track_id)
  """
  courseId: Float

  """Unique coordination identifier"""
  id: Float

  """
  Program being coordinated (mutually exclusive with track_id and course_id)
  """
  programId: Float

  """
  Track being coordinated (mutually exclusive with program_id and course_id)
  """
  trackId: Float
}

"""
order by variance() on columns of table "coordination"
"""
input CoordinationVarianceOrderBy {
  """
  Course being coordinated (mutually exclusive with program_id and track_id)
  """
  courseId: OrderBy

  """Unique coordination identifier"""
  id: OrderBy

  """
  Program being coordinated (mutually exclusive with track_id and course_id)
  """
  programId: OrderBy

  """
  Track being coordinated (mutually exclusive with program_id and course_id)
  """
  trackId: OrderBy
}

"""Detailed course definitions and configurations"""
type Course {
  """An array relationship"""
  children(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): [Course!]!

  """An aggregate relationship"""
  childrenAggregate(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): CourseAggregate!

  """An array relationship"""
  coordinations(
    """distinct select on columns"""
    distinctOn: [CoordinationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CoordinationOrderBy!]

    """filter the rows returned"""
    where: CoordinationBoolExp
  ): [Coordination!]!

  """An aggregate relationship"""
  coordinationsAggregate(
    """distinct select on columns"""
    distinctOn: [CoordinationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CoordinationOrderBy!]

    """filter the rows returned"""
    where: CoordinationBoolExp
  ): CoordinationAggregate!

  """Timestamp when the record was created"""
  createdAt: timestamptz!

  """Computed study year (1-3) based on semester"""
  cycleYear: Int!

  """Detailed course description and objectives"""
  description: String
  ensIdImport: String
  formationIdImport: String

  """Standard number of student groups"""
  groups: Int!

  """Modified number of groups if different from standard"""
  groupsAdjusted: Int

  """Actual number of groups used, defaulting to standard if no adjustment"""
  groupsEffective: Int

  """Standard teaching hours per group"""
  hours: Float!

  """Modified teaching hours per group if different from standard"""
  hoursAdjusted: Float

  """Actual teaching hours used, defaulting to standard if no adjustment"""
  hoursEffective: Int

  """Unique course identifier"""
  id: Int!

  """Full course name"""
  name: String!

  """Abbreviated course name"""
  nameShort: String
  nomImport: String

  """An object relationship"""
  parent: Course

  """Reference to previous year's version of this course"""
  parentId: Int

  """An array relationship"""
  priorities(
    """distinct select on columns"""
    distinctOn: [PrioritySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PriorityOrderBy!]

    """filter the rows returned"""
    where: PriorityBoolExp
  ): [Priority!]!

  """An aggregate relationship"""
  prioritiesAggregate(
    """distinct select on columns"""
    distinctOn: [PrioritySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PriorityOrderBy!]

    """filter the rows returned"""
    where: PriorityBoolExp
  ): PriorityAggregate!

  """
  Priority duration in years (3=default, 1=none, 0=permanent, NULL=disabled)
  """
  priorityRule: Int

  """An object relationship"""
  program: Program!

  """Program offering this course"""
  programId: Int!

  """An array relationship"""
  requests(
    """distinct select on columns"""
    distinctOn: [RequestSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RequestOrderBy!]

    """filter the rows returned"""
    where: RequestBoolExp
  ): [Request!]!

  """An aggregate relationship"""
  requestsAggregate(
    """distinct select on columns"""
    distinctOn: [RequestSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RequestOrderBy!]

    """filter the rows returned"""
    where: RequestBoolExp
  ): RequestAggregate!

  """Academic semester (1-6)"""
  semester: Int!

  """
  Calculates total effective teaching hours for a course by multiplying hours_effective by groups_effective
  """
  totalHoursEffective: Float

  """An object relationship"""
  track: Track

  """Optional track specialization for this course"""
  trackId: Int

  """Course delivery type affecting workload calculation"""
  type: String!

  """An object relationship"""
  typeByType: CourseType!

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz!

  """Controls course visibility in the user interface and queries"""
  visible: Boolean!

  """Academic year when the course is offered"""
  year: Int!

  """An object relationship"""
  yearByYear: Year!
}

"""
aggregated selection of "course"
"""
type CourseAggregate {
  aggregate: CourseAggregateFields
  nodes: [Course!]!
}

input CourseAggregateBoolExp {
  bool_and: courseAggregateBoolExpBool_and
  bool_or: courseAggregateBoolExpBool_or
  count: courseAggregateBoolExpCount
}

"""
aggregate fields of "course"
"""
type CourseAggregateFields {
  avg: CourseAvgFields
  count(columns: [CourseSelectColumn!], distinct: Boolean): Int!
  max: CourseMaxFields
  min: CourseMinFields
  stddev: CourseStddevFields
  stddevPop: CourseStddevPopFields
  stddevSamp: CourseStddevSampFields
  sum: CourseSumFields
  varPop: CourseVarPopFields
  varSamp: CourseVarSampFields
  variance: CourseVarianceFields
}

"""
order by aggregate values of table "course"
"""
input CourseAggregateOrderBy {
  avg: CourseAvgOrderBy
  count: OrderBy
  max: CourseMaxOrderBy
  min: CourseMinOrderBy
  stddev: CourseStddevOrderBy
  stddevPop: CourseStddevPopOrderBy
  stddevSamp: CourseStddevSampOrderBy
  sum: CourseSumOrderBy
  varPop: CourseVarPopOrderBy
  varSamp: CourseVarSampOrderBy
  variance: CourseVarianceOrderBy
}

"""
input type for inserting array relation for remote table "course"
"""
input CourseArrRelInsertInput {
  data: [CourseInsertInput!]!

  """upsert condition"""
  onConflict: CourseOnConflict
}

"""aggregate avg on columns"""
type CourseAvgFields {
  """Computed study year (1-3) based on semester"""
  cycleYear: Float

  """Standard number of student groups"""
  groups: Float

  """Modified number of groups if different from standard"""
  groupsAdjusted: Float

  """Actual number of groups used, defaulting to standard if no adjustment"""
  groupsEffective: Float

  """Standard teaching hours per group"""
  hours: Float

  """Modified teaching hours per group if different from standard"""
  hoursAdjusted: Float

  """Actual teaching hours used, defaulting to standard if no adjustment"""
  hoursEffective: Float

  """Unique course identifier"""
  id: Float

  """Reference to previous year's version of this course"""
  parentId: Float

  """
  Priority duration in years (3=default, 1=none, 0=permanent, NULL=disabled)
  """
  priorityRule: Float

  """Program offering this course"""
  programId: Float

  """Academic semester (1-6)"""
  semester: Float

  """
  Calculates total effective teaching hours for a course by multiplying hours_effective by groups_effective
  """
  totalHoursEffective: Float

  """Optional track specialization for this course"""
  trackId: Float

  """Academic year when the course is offered"""
  year: Float
}

"""
order by avg() on columns of table "course"
"""
input CourseAvgOrderBy {
  """Computed study year (1-3) based on semester"""
  cycleYear: OrderBy

  """Standard number of student groups"""
  groups: OrderBy

  """Modified number of groups if different from standard"""
  groupsAdjusted: OrderBy

  """Actual number of groups used, defaulting to standard if no adjustment"""
  groupsEffective: OrderBy

  """Standard teaching hours per group"""
  hours: OrderBy

  """Modified teaching hours per group if different from standard"""
  hoursAdjusted: OrderBy

  """Actual teaching hours used, defaulting to standard if no adjustment"""
  hoursEffective: OrderBy

  """Unique course identifier"""
  id: OrderBy

  """Reference to previous year's version of this course"""
  parentId: OrderBy

  """
  Priority duration in years (3=default, 1=none, 0=permanent, NULL=disabled)
  """
  priorityRule: OrderBy

  """Program offering this course"""
  programId: OrderBy

  """Academic semester (1-6)"""
  semester: OrderBy

  """Optional track specialization for this course"""
  trackId: OrderBy

  """Academic year when the course is offered"""
  year: OrderBy
}

"""
Boolean expression to filter rows from the table "course". All fields are combined with a logical 'AND'.
"""
input CourseBoolExp {
  _and: [CourseBoolExp!]
  _not: CourseBoolExp
  _or: [CourseBoolExp!]
  children: CourseBoolExp
  childrenAggregate: CourseAggregateBoolExp
  coordinations: CoordinationBoolExp
  coordinationsAggregate: CoordinationAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  cycleYear: IntComparisonExp
  description: StringComparisonExp
  ensIdImport: StringComparisonExp
  formationIdImport: StringComparisonExp
  groups: IntComparisonExp
  groupsAdjusted: IntComparisonExp
  groupsEffective: IntComparisonExp
  hours: FloatComparisonExp
  hoursAdjusted: FloatComparisonExp
  hoursEffective: IntComparisonExp
  id: IntComparisonExp
  name: StringComparisonExp
  nameShort: StringComparisonExp
  nomImport: StringComparisonExp
  parent: CourseBoolExp
  parentId: IntComparisonExp
  priorities: PriorityBoolExp
  prioritiesAggregate: PriorityAggregateBoolExp
  priorityRule: IntComparisonExp
  program: ProgramBoolExp
  programId: IntComparisonExp
  requests: RequestBoolExp
  requestsAggregate: RequestAggregateBoolExp
  semester: IntComparisonExp
  totalHoursEffective: FloatComparisonExp
  track: TrackBoolExp
  trackId: IntComparisonExp
  type: StringComparisonExp
  typeByType: CourseTypeBoolExp
  updatedAt: TimestamptzComparisonExp
  visible: BooleanComparisonExp
  year: IntComparisonExp
  yearByYear: YearBoolExp
}

"""
unique or primary key constraints on table "course"
"""
enum CourseConstraint {
  """
  unique or primary key constraint on columns "ens_id_import"
  """
  course_ens_id_import_key

  """
  unique or primary key constraint on columns "id"
  """
  course_pkey

  """
  unique or primary key constraint on columns "track_id", "semester", "type", "program_id", "name", "year"
  """
  course_year_program_id_track_id_name_semester_type_key
}

"""
input type for incrementing numeric columns in table "course"
"""
input CourseIncInput {
  """Standard number of student groups"""
  groups: Int

  """Modified number of groups if different from standard"""
  groupsAdjusted: Int

  """Standard teaching hours per group"""
  hours: Float

  """Modified teaching hours per group if different from standard"""
  hoursAdjusted: Float

  """Unique course identifier"""
  id: Int

  """Reference to previous year's version of this course"""
  parentId: Int

  """
  Priority duration in years (3=default, 1=none, 0=permanent, NULL=disabled)
  """
  priorityRule: Int

  """Program offering this course"""
  programId: Int

  """Academic semester (1-6)"""
  semester: Int

  """Optional track specialization for this course"""
  trackId: Int

  """Academic year when the course is offered"""
  year: Int
}

"""
input type for inserting data into table "course"
"""
input CourseInsertInput {
  children: CourseArrRelInsertInput
  coordinations: CoordinationArrRelInsertInput

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Detailed course description and objectives"""
  description: String
  ensIdImport: String
  formationIdImport: String

  """Standard number of student groups"""
  groups: Int

  """Modified number of groups if different from standard"""
  groupsAdjusted: Int

  """Standard teaching hours per group"""
  hours: Float

  """Modified teaching hours per group if different from standard"""
  hoursAdjusted: Float

  """Unique course identifier"""
  id: Int

  """Full course name"""
  name: String

  """Abbreviated course name"""
  nameShort: String
  nomImport: String
  parent: CourseObjRelInsertInput

  """Reference to previous year's version of this course"""
  parentId: Int
  priorities: PriorityArrRelInsertInput

  """
  Priority duration in years (3=default, 1=none, 0=permanent, NULL=disabled)
  """
  priorityRule: Int
  program: ProgramObjRelInsertInput

  """Program offering this course"""
  programId: Int
  requests: RequestArrRelInsertInput

  """Academic semester (1-6)"""
  semester: Int
  track: TrackObjRelInsertInput

  """Optional track specialization for this course"""
  trackId: Int

  """Course delivery type affecting workload calculation"""
  type: String
  typeByType: CourseTypeObjRelInsertInput

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Controls course visibility in the user interface and queries"""
  visible: Boolean

  """Academic year when the course is offered"""
  year: Int
  yearByYear: YearObjRelInsertInput
}

"""aggregate max on columns"""
type CourseMaxFields {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Computed study year (1-3) based on semester"""
  cycleYear: Int

  """Detailed course description and objectives"""
  description: String
  ensIdImport: String
  formationIdImport: String

  """Standard number of student groups"""
  groups: Int

  """Modified number of groups if different from standard"""
  groupsAdjusted: Int

  """Actual number of groups used, defaulting to standard if no adjustment"""
  groupsEffective: Int

  """Standard teaching hours per group"""
  hours: Float

  """Modified teaching hours per group if different from standard"""
  hoursAdjusted: Float

  """Actual teaching hours used, defaulting to standard if no adjustment"""
  hoursEffective: Int

  """Unique course identifier"""
  id: Int

  """Full course name"""
  name: String

  """Abbreviated course name"""
  nameShort: String
  nomImport: String

  """Reference to previous year's version of this course"""
  parentId: Int

  """
  Priority duration in years (3=default, 1=none, 0=permanent, NULL=disabled)
  """
  priorityRule: Int

  """Program offering this course"""
  programId: Int

  """Academic semester (1-6)"""
  semester: Int

  """
  Calculates total effective teaching hours for a course by multiplying hours_effective by groups_effective
  """
  totalHoursEffective: Float

  """Optional track specialization for this course"""
  trackId: Int

  """Course delivery type affecting workload calculation"""
  type: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Academic year when the course is offered"""
  year: Int
}

"""
order by max() on columns of table "course"
"""
input CourseMaxOrderBy {
  """Timestamp when the record was created"""
  createdAt: OrderBy

  """Computed study year (1-3) based on semester"""
  cycleYear: OrderBy

  """Detailed course description and objectives"""
  description: OrderBy
  ensIdImport: OrderBy
  formationIdImport: OrderBy

  """Standard number of student groups"""
  groups: OrderBy

  """Modified number of groups if different from standard"""
  groupsAdjusted: OrderBy

  """Actual number of groups used, defaulting to standard if no adjustment"""
  groupsEffective: OrderBy

  """Standard teaching hours per group"""
  hours: OrderBy

  """Modified teaching hours per group if different from standard"""
  hoursAdjusted: OrderBy

  """Actual teaching hours used, defaulting to standard if no adjustment"""
  hoursEffective: OrderBy

  """Unique course identifier"""
  id: OrderBy

  """Full course name"""
  name: OrderBy

  """Abbreviated course name"""
  nameShort: OrderBy
  nomImport: OrderBy

  """Reference to previous year's version of this course"""
  parentId: OrderBy

  """
  Priority duration in years (3=default, 1=none, 0=permanent, NULL=disabled)
  """
  priorityRule: OrderBy

  """Program offering this course"""
  programId: OrderBy

  """Academic semester (1-6)"""
  semester: OrderBy

  """Optional track specialization for this course"""
  trackId: OrderBy

  """Course delivery type affecting workload calculation"""
  type: OrderBy

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: OrderBy

  """Academic year when the course is offered"""
  year: OrderBy
}

"""aggregate min on columns"""
type CourseMinFields {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Computed study year (1-3) based on semester"""
  cycleYear: Int

  """Detailed course description and objectives"""
  description: String
  ensIdImport: String
  formationIdImport: String

  """Standard number of student groups"""
  groups: Int

  """Modified number of groups if different from standard"""
  groupsAdjusted: Int

  """Actual number of groups used, defaulting to standard if no adjustment"""
  groupsEffective: Int

  """Standard teaching hours per group"""
  hours: Float

  """Modified teaching hours per group if different from standard"""
  hoursAdjusted: Float

  """Actual teaching hours used, defaulting to standard if no adjustment"""
  hoursEffective: Int

  """Unique course identifier"""
  id: Int

  """Full course name"""
  name: String

  """Abbreviated course name"""
  nameShort: String
  nomImport: String

  """Reference to previous year's version of this course"""
  parentId: Int

  """
  Priority duration in years (3=default, 1=none, 0=permanent, NULL=disabled)
  """
  priorityRule: Int

  """Program offering this course"""
  programId: Int

  """Academic semester (1-6)"""
  semester: Int

  """
  Calculates total effective teaching hours for a course by multiplying hours_effective by groups_effective
  """
  totalHoursEffective: Float

  """Optional track specialization for this course"""
  trackId: Int

  """Course delivery type affecting workload calculation"""
  type: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Academic year when the course is offered"""
  year: Int
}

"""
order by min() on columns of table "course"
"""
input CourseMinOrderBy {
  """Timestamp when the record was created"""
  createdAt: OrderBy

  """Computed study year (1-3) based on semester"""
  cycleYear: OrderBy

  """Detailed course description and objectives"""
  description: OrderBy
  ensIdImport: OrderBy
  formationIdImport: OrderBy

  """Standard number of student groups"""
  groups: OrderBy

  """Modified number of groups if different from standard"""
  groupsAdjusted: OrderBy

  """Actual number of groups used, defaulting to standard if no adjustment"""
  groupsEffective: OrderBy

  """Standard teaching hours per group"""
  hours: OrderBy

  """Modified teaching hours per group if different from standard"""
  hoursAdjusted: OrderBy

  """Actual teaching hours used, defaulting to standard if no adjustment"""
  hoursEffective: OrderBy

  """Unique course identifier"""
  id: OrderBy

  """Full course name"""
  name: OrderBy

  """Abbreviated course name"""
  nameShort: OrderBy
  nomImport: OrderBy

  """Reference to previous year's version of this course"""
  parentId: OrderBy

  """
  Priority duration in years (3=default, 1=none, 0=permanent, NULL=disabled)
  """
  priorityRule: OrderBy

  """Program offering this course"""
  programId: OrderBy

  """Academic semester (1-6)"""
  semester: OrderBy

  """Optional track specialization for this course"""
  trackId: OrderBy

  """Course delivery type affecting workload calculation"""
  type: OrderBy

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: OrderBy

  """Academic year when the course is offered"""
  year: OrderBy
}

"""
response of any mutation on the table "course"
"""
type CourseMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Course!]!
}

"""
input type for inserting object relation for remote table "course"
"""
input CourseObjRelInsertInput {
  data: CourseInsertInput!

  """upsert condition"""
  onConflict: CourseOnConflict
}

"""
on_conflict condition type for table "course"
"""
input CourseOnConflict {
  constraint: CourseConstraint!
  updateColumns: [CourseUpdateColumn!]! = []
  where: CourseBoolExp
}

"""Ordering options when selecting data from "course"."""
input CourseOrderBy {
  childrenAggregate: CourseAggregateOrderBy
  coordinationsAggregate: CoordinationAggregateOrderBy
  createdAt: OrderBy
  cycleYear: OrderBy
  description: OrderBy
  ensIdImport: OrderBy
  formationIdImport: OrderBy
  groups: OrderBy
  groupsAdjusted: OrderBy
  groupsEffective: OrderBy
  hours: OrderBy
  hoursAdjusted: OrderBy
  hoursEffective: OrderBy
  id: OrderBy
  name: OrderBy
  nameShort: OrderBy
  nomImport: OrderBy
  parent: CourseOrderBy
  parentId: OrderBy
  prioritiesAggregate: PriorityAggregateOrderBy
  priorityRule: OrderBy
  program: ProgramOrderBy
  programId: OrderBy
  requestsAggregate: RequestAggregateOrderBy
  semester: OrderBy
  totalHoursEffective: OrderBy
  track: TrackOrderBy
  trackId: OrderBy
  type: OrderBy
  typeByType: CourseTypeOrderBy
  updatedAt: OrderBy
  visible: OrderBy
  year: OrderBy
  yearByYear: YearOrderBy
}

"""primary key columns input for table: course"""
input CoursePkColumnsInput {
  """Unique course identifier"""
  id: Int!
}

"""
select columns of table "course"
"""
enum CourseSelectColumn {
  """column name"""
  createdAt

  """column name"""
  cycleYear

  """column name"""
  description

  """column name"""
  ensIdImport

  """column name"""
  formationIdImport

  """column name"""
  groups

  """column name"""
  groupsAdjusted

  """column name"""
  groupsEffective

  """column name"""
  hours

  """column name"""
  hoursAdjusted

  """column name"""
  hoursEffective

  """column name"""
  id

  """column name"""
  name

  """column name"""
  nameShort

  """column name"""
  nomImport

  """column name"""
  parentId

  """column name"""
  priorityRule

  """column name"""
  programId

  """column name"""
  semester

  """column name"""
  trackId

  """column name"""
  type

  """column name"""
  updatedAt

  """column name"""
  visible

  """column name"""
  year
}

"""
select "courseAggregateBoolExpBool_andArgumentsColumns" columns of table "course"
"""
enum CourseSelectColumnCourseAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  visible
}

"""
select "courseAggregateBoolExpBool_orArgumentsColumns" columns of table "course"
"""
enum CourseSelectColumnCourseAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  visible
}

"""
input type for updating data in table "course"
"""
input CourseSetInput {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Detailed course description and objectives"""
  description: String
  ensIdImport: String
  formationIdImport: String

  """Standard number of student groups"""
  groups: Int

  """Modified number of groups if different from standard"""
  groupsAdjusted: Int

  """Standard teaching hours per group"""
  hours: Float

  """Modified teaching hours per group if different from standard"""
  hoursAdjusted: Float

  """Unique course identifier"""
  id: Int

  """Full course name"""
  name: String

  """Abbreviated course name"""
  nameShort: String
  nomImport: String

  """Reference to previous year's version of this course"""
  parentId: Int

  """
  Priority duration in years (3=default, 1=none, 0=permanent, NULL=disabled)
  """
  priorityRule: Int

  """Program offering this course"""
  programId: Int

  """Academic semester (1-6)"""
  semester: Int

  """Optional track specialization for this course"""
  trackId: Int

  """Course delivery type affecting workload calculation"""
  type: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Controls course visibility in the user interface and queries"""
  visible: Boolean

  """Academic year when the course is offered"""
  year: Int
}

"""aggregate stddev on columns"""
type CourseStddevFields {
  """Computed study year (1-3) based on semester"""
  cycleYear: Float

  """Standard number of student groups"""
  groups: Float

  """Modified number of groups if different from standard"""
  groupsAdjusted: Float

  """Actual number of groups used, defaulting to standard if no adjustment"""
  groupsEffective: Float

  """Standard teaching hours per group"""
  hours: Float

  """Modified teaching hours per group if different from standard"""
  hoursAdjusted: Float

  """Actual teaching hours used, defaulting to standard if no adjustment"""
  hoursEffective: Float

  """Unique course identifier"""
  id: Float

  """Reference to previous year's version of this course"""
  parentId: Float

  """
  Priority duration in years (3=default, 1=none, 0=permanent, NULL=disabled)
  """
  priorityRule: Float

  """Program offering this course"""
  programId: Float

  """Academic semester (1-6)"""
  semester: Float

  """
  Calculates total effective teaching hours for a course by multiplying hours_effective by groups_effective
  """
  totalHoursEffective: Float

  """Optional track specialization for this course"""
  trackId: Float

  """Academic year when the course is offered"""
  year: Float
}

"""
order by stddev() on columns of table "course"
"""
input CourseStddevOrderBy {
  """Computed study year (1-3) based on semester"""
  cycleYear: OrderBy

  """Standard number of student groups"""
  groups: OrderBy

  """Modified number of groups if different from standard"""
  groupsAdjusted: OrderBy

  """Actual number of groups used, defaulting to standard if no adjustment"""
  groupsEffective: OrderBy

  """Standard teaching hours per group"""
  hours: OrderBy

  """Modified teaching hours per group if different from standard"""
  hoursAdjusted: OrderBy

  """Actual teaching hours used, defaulting to standard if no adjustment"""
  hoursEffective: OrderBy

  """Unique course identifier"""
  id: OrderBy

  """Reference to previous year's version of this course"""
  parentId: OrderBy

  """
  Priority duration in years (3=default, 1=none, 0=permanent, NULL=disabled)
  """
  priorityRule: OrderBy

  """Program offering this course"""
  programId: OrderBy

  """Academic semester (1-6)"""
  semester: OrderBy

  """Optional track specialization for this course"""
  trackId: OrderBy

  """Academic year when the course is offered"""
  year: OrderBy
}

"""aggregate stddevPop on columns"""
type CourseStddevPopFields {
  """Computed study year (1-3) based on semester"""
  cycleYear: Float

  """Standard number of student groups"""
  groups: Float

  """Modified number of groups if different from standard"""
  groupsAdjusted: Float

  """Actual number of groups used, defaulting to standard if no adjustment"""
  groupsEffective: Float

  """Standard teaching hours per group"""
  hours: Float

  """Modified teaching hours per group if different from standard"""
  hoursAdjusted: Float

  """Actual teaching hours used, defaulting to standard if no adjustment"""
  hoursEffective: Float

  """Unique course identifier"""
  id: Float

  """Reference to previous year's version of this course"""
  parentId: Float

  """
  Priority duration in years (3=default, 1=none, 0=permanent, NULL=disabled)
  """
  priorityRule: Float

  """Program offering this course"""
  programId: Float

  """Academic semester (1-6)"""
  semester: Float

  """
  Calculates total effective teaching hours for a course by multiplying hours_effective by groups_effective
  """
  totalHoursEffective: Float

  """Optional track specialization for this course"""
  trackId: Float

  """Academic year when the course is offered"""
  year: Float
}

"""
order by stddevPop() on columns of table "course"
"""
input CourseStddevPopOrderBy {
  """Computed study year (1-3) based on semester"""
  cycleYear: OrderBy

  """Standard number of student groups"""
  groups: OrderBy

  """Modified number of groups if different from standard"""
  groupsAdjusted: OrderBy

  """Actual number of groups used, defaulting to standard if no adjustment"""
  groupsEffective: OrderBy

  """Standard teaching hours per group"""
  hours: OrderBy

  """Modified teaching hours per group if different from standard"""
  hoursAdjusted: OrderBy

  """Actual teaching hours used, defaulting to standard if no adjustment"""
  hoursEffective: OrderBy

  """Unique course identifier"""
  id: OrderBy

  """Reference to previous year's version of this course"""
  parentId: OrderBy

  """
  Priority duration in years (3=default, 1=none, 0=permanent, NULL=disabled)
  """
  priorityRule: OrderBy

  """Program offering this course"""
  programId: OrderBy

  """Academic semester (1-6)"""
  semester: OrderBy

  """Optional track specialization for this course"""
  trackId: OrderBy

  """Academic year when the course is offered"""
  year: OrderBy
}

"""aggregate stddevSamp on columns"""
type CourseStddevSampFields {
  """Computed study year (1-3) based on semester"""
  cycleYear: Float

  """Standard number of student groups"""
  groups: Float

  """Modified number of groups if different from standard"""
  groupsAdjusted: Float

  """Actual number of groups used, defaulting to standard if no adjustment"""
  groupsEffective: Float

  """Standard teaching hours per group"""
  hours: Float

  """Modified teaching hours per group if different from standard"""
  hoursAdjusted: Float

  """Actual teaching hours used, defaulting to standard if no adjustment"""
  hoursEffective: Float

  """Unique course identifier"""
  id: Float

  """Reference to previous year's version of this course"""
  parentId: Float

  """
  Priority duration in years (3=default, 1=none, 0=permanent, NULL=disabled)
  """
  priorityRule: Float

  """Program offering this course"""
  programId: Float

  """Academic semester (1-6)"""
  semester: Float

  """
  Calculates total effective teaching hours for a course by multiplying hours_effective by groups_effective
  """
  totalHoursEffective: Float

  """Optional track specialization for this course"""
  trackId: Float

  """Academic year when the course is offered"""
  year: Float
}

"""
order by stddevSamp() on columns of table "course"
"""
input CourseStddevSampOrderBy {
  """Computed study year (1-3) based on semester"""
  cycleYear: OrderBy

  """Standard number of student groups"""
  groups: OrderBy

  """Modified number of groups if different from standard"""
  groupsAdjusted: OrderBy

  """Actual number of groups used, defaulting to standard if no adjustment"""
  groupsEffective: OrderBy

  """Standard teaching hours per group"""
  hours: OrderBy

  """Modified teaching hours per group if different from standard"""
  hoursAdjusted: OrderBy

  """Actual teaching hours used, defaulting to standard if no adjustment"""
  hoursEffective: OrderBy

  """Unique course identifier"""
  id: OrderBy

  """Reference to previous year's version of this course"""
  parentId: OrderBy

  """
  Priority duration in years (3=default, 1=none, 0=permanent, NULL=disabled)
  """
  priorityRule: OrderBy

  """Program offering this course"""
  programId: OrderBy

  """Academic semester (1-6)"""
  semester: OrderBy

  """Optional track specialization for this course"""
  trackId: OrderBy

  """Academic year when the course is offered"""
  year: OrderBy
}

"""
Streaming cursor of the table "course"
"""
input CourseStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: CourseStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input CourseStreamCursorValueInput {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Computed study year (1-3) based on semester"""
  cycleYear: Int

  """Detailed course description and objectives"""
  description: String
  ensIdImport: String
  formationIdImport: String

  """Standard number of student groups"""
  groups: Int

  """Modified number of groups if different from standard"""
  groupsAdjusted: Int

  """Actual number of groups used, defaulting to standard if no adjustment"""
  groupsEffective: Int

  """Standard teaching hours per group"""
  hours: Float

  """Modified teaching hours per group if different from standard"""
  hoursAdjusted: Float

  """Actual teaching hours used, defaulting to standard if no adjustment"""
  hoursEffective: Int

  """Unique course identifier"""
  id: Int

  """Full course name"""
  name: String

  """Abbreviated course name"""
  nameShort: String
  nomImport: String

  """Reference to previous year's version of this course"""
  parentId: Int

  """
  Priority duration in years (3=default, 1=none, 0=permanent, NULL=disabled)
  """
  priorityRule: Int

  """Program offering this course"""
  programId: Int

  """Academic semester (1-6)"""
  semester: Int

  """Optional track specialization for this course"""
  trackId: Int

  """Course delivery type affecting workload calculation"""
  type: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Controls course visibility in the user interface and queries"""
  visible: Boolean

  """Academic year when the course is offered"""
  year: Int
}

"""aggregate sum on columns"""
type CourseSumFields {
  """Computed study year (1-3) based on semester"""
  cycleYear: Int

  """Standard number of student groups"""
  groups: Int

  """Modified number of groups if different from standard"""
  groupsAdjusted: Int

  """Actual number of groups used, defaulting to standard if no adjustment"""
  groupsEffective: Int

  """Standard teaching hours per group"""
  hours: Float

  """Modified teaching hours per group if different from standard"""
  hoursAdjusted: Float

  """Actual teaching hours used, defaulting to standard if no adjustment"""
  hoursEffective: Int

  """Unique course identifier"""
  id: Int

  """Reference to previous year's version of this course"""
  parentId: Int

  """
  Priority duration in years (3=default, 1=none, 0=permanent, NULL=disabled)
  """
  priorityRule: Int

  """Program offering this course"""
  programId: Int

  """Academic semester (1-6)"""
  semester: Int

  """
  Calculates total effective teaching hours for a course by multiplying hours_effective by groups_effective
  """
  totalHoursEffective: Float

  """Optional track specialization for this course"""
  trackId: Int

  """Academic year when the course is offered"""
  year: Int
}

"""
order by sum() on columns of table "course"
"""
input CourseSumOrderBy {
  """Computed study year (1-3) based on semester"""
  cycleYear: OrderBy

  """Standard number of student groups"""
  groups: OrderBy

  """Modified number of groups if different from standard"""
  groupsAdjusted: OrderBy

  """Actual number of groups used, defaulting to standard if no adjustment"""
  groupsEffective: OrderBy

  """Standard teaching hours per group"""
  hours: OrderBy

  """Modified teaching hours per group if different from standard"""
  hoursAdjusted: OrderBy

  """Actual teaching hours used, defaulting to standard if no adjustment"""
  hoursEffective: OrderBy

  """Unique course identifier"""
  id: OrderBy

  """Reference to previous year's version of this course"""
  parentId: OrderBy

  """
  Priority duration in years (3=default, 1=none, 0=permanent, NULL=disabled)
  """
  priorityRule: OrderBy

  """Program offering this course"""
  programId: OrderBy

  """Academic semester (1-6)"""
  semester: OrderBy

  """Optional track specialization for this course"""
  trackId: OrderBy

  """Academic year when the course is offered"""
  year: OrderBy
}

"""Types of course delivery with associated workload coefficients"""
type CourseType {
  """Workload multiplier for service hour calculations"""
  coefficient: Float!

  """An array relationship"""
  courses(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): [Course!]!

  """An aggregate relationship"""
  coursesAggregate(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): CourseAggregate!

  """Timestamp when the record was created"""
  createdAt: timestamptz!

  """Detailed description of the course type and its characteristics"""
  description: String

  """Human-readable type name for display"""
  label: String!

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz!

  """Course type identifier (e.g., lecture, tutorial)"""
  value: String!
}

"""
aggregated selection of "course_type"
"""
type CourseTypeAggregate {
  aggregate: CourseTypeAggregateFields
  nodes: [CourseType!]!
}

"""
aggregate fields of "course_type"
"""
type CourseTypeAggregateFields {
  avg: CourseTypeAvgFields
  count(columns: [CourseTypeSelectColumn!], distinct: Boolean): Int!
  max: CourseTypeMaxFields
  min: CourseTypeMinFields
  stddev: CourseTypeStddevFields
  stddevPop: CourseTypeStddevPopFields
  stddevSamp: CourseTypeStddevSampFields
  sum: CourseTypeSumFields
  varPop: CourseTypeVarPopFields
  varSamp: CourseTypeVarSampFields
  variance: CourseTypeVarianceFields
}

"""aggregate avg on columns"""
type CourseTypeAvgFields {
  """Workload multiplier for service hour calculations"""
  coefficient: Float
}

"""
Boolean expression to filter rows from the table "course_type". All fields are combined with a logical 'AND'.
"""
input CourseTypeBoolExp {
  _and: [CourseTypeBoolExp!]
  _not: CourseTypeBoolExp
  _or: [CourseTypeBoolExp!]
  coefficient: FloatComparisonExp
  courses: CourseBoolExp
  coursesAggregate: CourseAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  label: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "course_type"
"""
enum CourseTypeConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  course_type_pkey
}

"""
input type for incrementing numeric columns in table "course_type"
"""
input CourseTypeIncInput {
  """Workload multiplier for service hour calculations"""
  coefficient: Float
}

"""
input type for inserting data into table "course_type"
"""
input CourseTypeInsertInput {
  """Workload multiplier for service hour calculations"""
  coefficient: Float
  courses: CourseArrRelInsertInput

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Detailed description of the course type and its characteristics"""
  description: String

  """Human-readable type name for display"""
  label: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Course type identifier (e.g., lecture, tutorial)"""
  value: String
}

"""aggregate max on columns"""
type CourseTypeMaxFields {
  """Workload multiplier for service hour calculations"""
  coefficient: Float

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Detailed description of the course type and its characteristics"""
  description: String

  """Human-readable type name for display"""
  label: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Course type identifier (e.g., lecture, tutorial)"""
  value: String
}

"""aggregate min on columns"""
type CourseTypeMinFields {
  """Workload multiplier for service hour calculations"""
  coefficient: Float

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Detailed description of the course type and its characteristics"""
  description: String

  """Human-readable type name for display"""
  label: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Course type identifier (e.g., lecture, tutorial)"""
  value: String
}

"""
response of any mutation on the table "course_type"
"""
type CourseTypeMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [CourseType!]!
}

"""
input type for inserting object relation for remote table "course_type"
"""
input CourseTypeObjRelInsertInput {
  data: CourseTypeInsertInput!

  """upsert condition"""
  onConflict: CourseTypeOnConflict
}

"""
on_conflict condition type for table "course_type"
"""
input CourseTypeOnConflict {
  constraint: CourseTypeConstraint!
  updateColumns: [CourseTypeUpdateColumn!]! = []
  where: CourseTypeBoolExp
}

"""Ordering options when selecting data from "course_type"."""
input CourseTypeOrderBy {
  coefficient: OrderBy
  coursesAggregate: CourseAggregateOrderBy
  createdAt: OrderBy
  description: OrderBy
  label: OrderBy
  updatedAt: OrderBy
  value: OrderBy
}

"""primary key columns input for table: course_type"""
input CourseTypePkColumnsInput {
  """Course type identifier (e.g., lecture, tutorial)"""
  value: String!
}

"""
select columns of table "course_type"
"""
enum CourseTypeSelectColumn {
  """column name"""
  coefficient

  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  label

  """column name"""
  updatedAt

  """column name"""
  value
}

"""
input type for updating data in table "course_type"
"""
input CourseTypeSetInput {
  """Workload multiplier for service hour calculations"""
  coefficient: Float

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Detailed description of the course type and its characteristics"""
  description: String

  """Human-readable type name for display"""
  label: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Course type identifier (e.g., lecture, tutorial)"""
  value: String
}

"""aggregate stddev on columns"""
type CourseTypeStddevFields {
  """Workload multiplier for service hour calculations"""
  coefficient: Float
}

"""aggregate stddevPop on columns"""
type CourseTypeStddevPopFields {
  """Workload multiplier for service hour calculations"""
  coefficient: Float
}

"""aggregate stddevSamp on columns"""
type CourseTypeStddevSampFields {
  """Workload multiplier for service hour calculations"""
  coefficient: Float
}

"""
Streaming cursor of the table "course_type"
"""
input CourseTypeStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: CourseTypeStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input CourseTypeStreamCursorValueInput {
  """Workload multiplier for service hour calculations"""
  coefficient: Float

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Detailed description of the course type and its characteristics"""
  description: String

  """Human-readable type name for display"""
  label: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Course type identifier (e.g., lecture, tutorial)"""
  value: String
}

"""aggregate sum on columns"""
type CourseTypeSumFields {
  """Workload multiplier for service hour calculations"""
  coefficient: Float
}

"""
update columns of table "course_type"
"""
enum CourseTypeUpdateColumn {
  """column name"""
  coefficient

  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  label

  """column name"""
  updatedAt

  """column name"""
  value
}

input CourseTypeUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: CourseTypeIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: CourseTypeSetInput

  """filter the rows which have to be updated"""
  where: CourseTypeBoolExp!
}

"""aggregate varPop on columns"""
type CourseTypeVarPopFields {
  """Workload multiplier for service hour calculations"""
  coefficient: Float
}

"""aggregate varSamp on columns"""
type CourseTypeVarSampFields {
  """Workload multiplier for service hour calculations"""
  coefficient: Float
}

"""aggregate variance on columns"""
type CourseTypeVarianceFields {
  """Workload multiplier for service hour calculations"""
  coefficient: Float
}

"""
update columns of table "course"
"""
enum CourseUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  ensIdImport

  """column name"""
  formationIdImport

  """column name"""
  groups

  """column name"""
  groupsAdjusted

  """column name"""
  hours

  """column name"""
  hoursAdjusted

  """column name"""
  id

  """column name"""
  name

  """column name"""
  nameShort

  """column name"""
  nomImport

  """column name"""
  parentId

  """column name"""
  priorityRule

  """column name"""
  programId

  """column name"""
  semester

  """column name"""
  trackId

  """column name"""
  type

  """column name"""
  updatedAt

  """column name"""
  visible

  """column name"""
  year
}

input CourseUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: CourseIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: CourseSetInput

  """filter the rows which have to be updated"""
  where: CourseBoolExp!
}

"""aggregate varPop on columns"""
type CourseVarPopFields {
  """Computed study year (1-3) based on semester"""
  cycleYear: Float

  """Standard number of student groups"""
  groups: Float

  """Modified number of groups if different from standard"""
  groupsAdjusted: Float

  """Actual number of groups used, defaulting to standard if no adjustment"""
  groupsEffective: Float

  """Standard teaching hours per group"""
  hours: Float

  """Modified teaching hours per group if different from standard"""
  hoursAdjusted: Float

  """Actual teaching hours used, defaulting to standard if no adjustment"""
  hoursEffective: Float

  """Unique course identifier"""
  id: Float

  """Reference to previous year's version of this course"""
  parentId: Float

  """
  Priority duration in years (3=default, 1=none, 0=permanent, NULL=disabled)
  """
  priorityRule: Float

  """Program offering this course"""
  programId: Float

  """Academic semester (1-6)"""
  semester: Float

  """
  Calculates total effective teaching hours for a course by multiplying hours_effective by groups_effective
  """
  totalHoursEffective: Float

  """Optional track specialization for this course"""
  trackId: Float

  """Academic year when the course is offered"""
  year: Float
}

"""
order by varPop() on columns of table "course"
"""
input CourseVarPopOrderBy {
  """Computed study year (1-3) based on semester"""
  cycleYear: OrderBy

  """Standard number of student groups"""
  groups: OrderBy

  """Modified number of groups if different from standard"""
  groupsAdjusted: OrderBy

  """Actual number of groups used, defaulting to standard if no adjustment"""
  groupsEffective: OrderBy

  """Standard teaching hours per group"""
  hours: OrderBy

  """Modified teaching hours per group if different from standard"""
  hoursAdjusted: OrderBy

  """Actual teaching hours used, defaulting to standard if no adjustment"""
  hoursEffective: OrderBy

  """Unique course identifier"""
  id: OrderBy

  """Reference to previous year's version of this course"""
  parentId: OrderBy

  """
  Priority duration in years (3=default, 1=none, 0=permanent, NULL=disabled)
  """
  priorityRule: OrderBy

  """Program offering this course"""
  programId: OrderBy

  """Academic semester (1-6)"""
  semester: OrderBy

  """Optional track specialization for this course"""
  trackId: OrderBy

  """Academic year when the course is offered"""
  year: OrderBy
}

"""aggregate varSamp on columns"""
type CourseVarSampFields {
  """Computed study year (1-3) based on semester"""
  cycleYear: Float

  """Standard number of student groups"""
  groups: Float

  """Modified number of groups if different from standard"""
  groupsAdjusted: Float

  """Actual number of groups used, defaulting to standard if no adjustment"""
  groupsEffective: Float

  """Standard teaching hours per group"""
  hours: Float

  """Modified teaching hours per group if different from standard"""
  hoursAdjusted: Float

  """Actual teaching hours used, defaulting to standard if no adjustment"""
  hoursEffective: Float

  """Unique course identifier"""
  id: Float

  """Reference to previous year's version of this course"""
  parentId: Float

  """
  Priority duration in years (3=default, 1=none, 0=permanent, NULL=disabled)
  """
  priorityRule: Float

  """Program offering this course"""
  programId: Float

  """Academic semester (1-6)"""
  semester: Float

  """
  Calculates total effective teaching hours for a course by multiplying hours_effective by groups_effective
  """
  totalHoursEffective: Float

  """Optional track specialization for this course"""
  trackId: Float

  """Academic year when the course is offered"""
  year: Float
}

"""
order by varSamp() on columns of table "course"
"""
input CourseVarSampOrderBy {
  """Computed study year (1-3) based on semester"""
  cycleYear: OrderBy

  """Standard number of student groups"""
  groups: OrderBy

  """Modified number of groups if different from standard"""
  groupsAdjusted: OrderBy

  """Actual number of groups used, defaulting to standard if no adjustment"""
  groupsEffective: OrderBy

  """Standard teaching hours per group"""
  hours: OrderBy

  """Modified teaching hours per group if different from standard"""
  hoursAdjusted: OrderBy

  """Actual teaching hours used, defaulting to standard if no adjustment"""
  hoursEffective: OrderBy

  """Unique course identifier"""
  id: OrderBy

  """Reference to previous year's version of this course"""
  parentId: OrderBy

  """
  Priority duration in years (3=default, 1=none, 0=permanent, NULL=disabled)
  """
  priorityRule: OrderBy

  """Program offering this course"""
  programId: OrderBy

  """Academic semester (1-6)"""
  semester: OrderBy

  """Optional track specialization for this course"""
  trackId: OrderBy

  """Academic year when the course is offered"""
  year: OrderBy
}

"""aggregate variance on columns"""
type CourseVarianceFields {
  """Computed study year (1-3) based on semester"""
  cycleYear: Float

  """Standard number of student groups"""
  groups: Float

  """Modified number of groups if different from standard"""
  groupsAdjusted: Float

  """Actual number of groups used, defaulting to standard if no adjustment"""
  groupsEffective: Float

  """Standard teaching hours per group"""
  hours: Float

  """Modified teaching hours per group if different from standard"""
  hoursAdjusted: Float

  """Actual teaching hours used, defaulting to standard if no adjustment"""
  hoursEffective: Float

  """Unique course identifier"""
  id: Float

  """Reference to previous year's version of this course"""
  parentId: Float

  """
  Priority duration in years (3=default, 1=none, 0=permanent, NULL=disabled)
  """
  priorityRule: Float

  """Program offering this course"""
  programId: Float

  """Academic semester (1-6)"""
  semester: Float

  """
  Calculates total effective teaching hours for a course by multiplying hours_effective by groups_effective
  """
  totalHoursEffective: Float

  """Optional track specialization for this course"""
  trackId: Float

  """Academic year when the course is offered"""
  year: Float
}

"""
order by variance() on columns of table "course"
"""
input CourseVarianceOrderBy {
  """Computed study year (1-3) based on semester"""
  cycleYear: OrderBy

  """Standard number of student groups"""
  groups: OrderBy

  """Modified number of groups if different from standard"""
  groupsAdjusted: OrderBy

  """Actual number of groups used, defaulting to standard if no adjustment"""
  groupsEffective: OrderBy

  """Standard teaching hours per group"""
  hours: OrderBy

  """Modified teaching hours per group if different from standard"""
  hoursAdjusted: OrderBy

  """Actual teaching hours used, defaulting to standard if no adjustment"""
  hoursEffective: OrderBy

  """Unique course identifier"""
  id: OrderBy

  """Reference to previous year's version of this course"""
  parentId: OrderBy

  """
  Priority duration in years (3=default, 1=none, 0=permanent, NULL=disabled)
  """
  priorityRule: OrderBy

  """Program offering this course"""
  programId: OrderBy

  """Academic semester (1-6)"""
  semester: OrderBy

  """Optional track specialization for this course"""
  trackId: OrderBy

  """Academic year when the course is offered"""
  year: OrderBy
}

"""ordering argument of a cursor"""
enum CursorOrdering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""Academic degrees offered by the institution"""
type Degree {
  """Timestamp when the record was created"""
  createdAt: timestamptz!

  """Unique degree identifier"""
  id: Int!

  """Full degree name, unique (e.g., Bachelor of Science)"""
  name: String!

  """Abbreviated degree name (e.g., BSc)"""
  nameShort: String

  """An array relationship"""
  programs(
    """distinct select on columns"""
    distinctOn: [ProgramSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProgramOrderBy!]

    """filter the rows returned"""
    where: ProgramBoolExp
  ): [Program!]!

  """An aggregate relationship"""
  programsAggregate(
    """distinct select on columns"""
    distinctOn: [ProgramSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProgramOrderBy!]

    """filter the rows returned"""
    where: ProgramBoolExp
  ): ProgramAggregate!

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz!

  """Controls degree visibility in the user interface and queries"""
  visible: Boolean!
}

"""
aggregated selection of "degree"
"""
type DegreeAggregate {
  aggregate: DegreeAggregateFields
  nodes: [Degree!]!
}

"""
aggregate fields of "degree"
"""
type DegreeAggregateFields {
  avg: DegreeAvgFields
  count(columns: [DegreeSelectColumn!], distinct: Boolean): Int!
  max: DegreeMaxFields
  min: DegreeMinFields
  stddev: DegreeStddevFields
  stddevPop: DegreeStddevPopFields
  stddevSamp: DegreeStddevSampFields
  sum: DegreeSumFields
  varPop: DegreeVarPopFields
  varSamp: DegreeVarSampFields
  variance: DegreeVarianceFields
}

"""aggregate avg on columns"""
type DegreeAvgFields {
  """Unique degree identifier"""
  id: Float
}

"""
Boolean expression to filter rows from the table "degree". All fields are combined with a logical 'AND'.
"""
input DegreeBoolExp {
  _and: [DegreeBoolExp!]
  _not: DegreeBoolExp
  _or: [DegreeBoolExp!]
  createdAt: TimestamptzComparisonExp
  id: IntComparisonExp
  name: StringComparisonExp
  nameShort: StringComparisonExp
  programs: ProgramBoolExp
  programsAggregate: ProgramAggregateBoolExp
  updatedAt: TimestamptzComparisonExp
  visible: BooleanComparisonExp
}

"""
unique or primary key constraints on table "degree"
"""
enum DegreeConstraint {
  """
  unique or primary key constraint on columns "name"
  """
  degree_name_key

  """
  unique or primary key constraint on columns "id"
  """
  degree_pkey
}

"""
input type for incrementing numeric columns in table "degree"
"""
input DegreeIncInput {
  """Unique degree identifier"""
  id: Int
}

"""
input type for inserting data into table "degree"
"""
input DegreeInsertInput {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Unique degree identifier"""
  id: Int

  """Full degree name, unique (e.g., Bachelor of Science)"""
  name: String

  """Abbreviated degree name (e.g., BSc)"""
  nameShort: String
  programs: ProgramArrRelInsertInput

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Controls degree visibility in the user interface and queries"""
  visible: Boolean
}

"""aggregate max on columns"""
type DegreeMaxFields {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Unique degree identifier"""
  id: Int

  """Full degree name, unique (e.g., Bachelor of Science)"""
  name: String

  """Abbreviated degree name (e.g., BSc)"""
  nameShort: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type DegreeMinFields {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Unique degree identifier"""
  id: Int

  """Full degree name, unique (e.g., Bachelor of Science)"""
  name: String

  """Abbreviated degree name (e.g., BSc)"""
  nameShort: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""
response of any mutation on the table "degree"
"""
type DegreeMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Degree!]!
}

"""
input type for inserting object relation for remote table "degree"
"""
input DegreeObjRelInsertInput {
  data: DegreeInsertInput!

  """upsert condition"""
  onConflict: DegreeOnConflict
}

"""
on_conflict condition type for table "degree"
"""
input DegreeOnConflict {
  constraint: DegreeConstraint!
  updateColumns: [DegreeUpdateColumn!]! = []
  where: DegreeBoolExp
}

"""Ordering options when selecting data from "degree"."""
input DegreeOrderBy {
  createdAt: OrderBy
  id: OrderBy
  name: OrderBy
  nameShort: OrderBy
  programsAggregate: ProgramAggregateOrderBy
  updatedAt: OrderBy
  visible: OrderBy
}

"""primary key columns input for table: degree"""
input DegreePkColumnsInput {
  """Unique degree identifier"""
  id: Int!
}

"""
select columns of table "degree"
"""
enum DegreeSelectColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  name

  """column name"""
  nameShort

  """column name"""
  updatedAt

  """column name"""
  visible
}

"""
input type for updating data in table "degree"
"""
input DegreeSetInput {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Unique degree identifier"""
  id: Int

  """Full degree name, unique (e.g., Bachelor of Science)"""
  name: String

  """Abbreviated degree name (e.g., BSc)"""
  nameShort: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Controls degree visibility in the user interface and queries"""
  visible: Boolean
}

"""aggregate stddev on columns"""
type DegreeStddevFields {
  """Unique degree identifier"""
  id: Float
}

"""aggregate stddevPop on columns"""
type DegreeStddevPopFields {
  """Unique degree identifier"""
  id: Float
}

"""aggregate stddevSamp on columns"""
type DegreeStddevSampFields {
  """Unique degree identifier"""
  id: Float
}

"""
Streaming cursor of the table "degree"
"""
input DegreeStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: DegreeStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input DegreeStreamCursorValueInput {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Unique degree identifier"""
  id: Int

  """Full degree name, unique (e.g., Bachelor of Science)"""
  name: String

  """Abbreviated degree name (e.g., BSc)"""
  nameShort: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Controls degree visibility in the user interface and queries"""
  visible: Boolean
}

"""aggregate sum on columns"""
type DegreeSumFields {
  """Unique degree identifier"""
  id: Int
}

"""
update columns of table "degree"
"""
enum DegreeUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  name

  """column name"""
  nameShort

  """column name"""
  updatedAt

  """column name"""
  visible
}

input DegreeUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: DegreeIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: DegreeSetInput

  """filter the rows which have to be updated"""
  where: DegreeBoolExp!
}

"""aggregate varPop on columns"""
type DegreeVarPopFields {
  """Unique degree identifier"""
  id: Float
}

"""aggregate varSamp on columns"""
type DegreeVarSampFields {
  """Unique degree identifier"""
  id: Float
}

"""aggregate variance on columns"""
type DegreeVarianceFields {
  """Unique degree identifier"""
  id: Float
}

"""
Boolean expression to compare columns of type "Float". All fields are combined with logical 'AND'.
"""
input FloatComparisonExp {
  _eq: Float
  _gt: Float
  _gte: Float
  _in: [Float!]
  _isNull: Boolean
  _lt: Float
  _lte: Float
  _neq: Float
  _nin: [Float!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input IntComparisonExp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _isNull: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""column ordering options"""
enum OrderBy {
  """in ascending order, nulls last"""
  ASC

  """in ascending order, nulls first"""
  ASC_NULLS_FIRST

  """in ascending order, nulls last"""
  ASC_NULLS_LAST

  """in descending order, nulls first"""
  DESC

  """in descending order, nulls first"""
  DESC_NULLS_FIRST

  """in descending order, nulls last"""
  DESC_NULLS_LAST
}

"""System phases controlling the course assignment workflow"""
type Phase {
  """Timestamp when the record was created"""
  createdAt: timestamptz!

  """
  Current phase flag (TRUE or NULL). Constrained to have at most one current phase
  """
  current: Boolean

  """Summary of activities and permissions during this phase"""
  description: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz!

  """Phase identifier"""
  value: String!
}

"""
aggregated selection of "phase"
"""
type PhaseAggregate {
  aggregate: PhaseAggregateFields
  nodes: [Phase!]!
}

"""
aggregate fields of "phase"
"""
type PhaseAggregateFields {
  count(columns: [PhaseSelectColumn!], distinct: Boolean): Int!
  max: PhaseMaxFields
  min: PhaseMinFields
}

"""
Boolean expression to filter rows from the table "phase". All fields are combined with a logical 'AND'.
"""
input PhaseBoolExp {
  _and: [PhaseBoolExp!]
  _not: PhaseBoolExp
  _or: [PhaseBoolExp!]
  createdAt: TimestamptzComparisonExp
  current: BooleanComparisonExp
  description: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "phase"
"""
enum PhaseConstraint {
  """
  unique or primary key constraint on columns "current"
  """
  phase_current_key

  """
  unique or primary key constraint on columns "value"
  """
  phase_pkey
}

"""
input type for inserting data into table "phase"
"""
input PhaseInsertInput {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """
  Current phase flag (TRUE or NULL). Constrained to have at most one current phase
  """
  current: Boolean

  """Summary of activities and permissions during this phase"""
  description: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Phase identifier"""
  value: String
}

"""aggregate max on columns"""
type PhaseMaxFields {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Summary of activities and permissions during this phase"""
  description: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Phase identifier"""
  value: String
}

"""aggregate min on columns"""
type PhaseMinFields {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Summary of activities and permissions during this phase"""
  description: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Phase identifier"""
  value: String
}

"""
response of any mutation on the table "phase"
"""
type PhaseMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Phase!]!
}

"""
on_conflict condition type for table "phase"
"""
input PhaseOnConflict {
  constraint: PhaseConstraint!
  updateColumns: [PhaseUpdateColumn!]! = []
  where: PhaseBoolExp
}

"""Ordering options when selecting data from "phase"."""
input PhaseOrderBy {
  createdAt: OrderBy
  current: OrderBy
  description: OrderBy
  updatedAt: OrderBy
  value: OrderBy
}

"""primary key columns input for table: phase"""
input PhasePkColumnsInput {
  """Phase identifier"""
  value: String!
}

"""
select columns of table "phase"
"""
enum PhaseSelectColumn {
  """column name"""
  createdAt

  """column name"""
  current

  """column name"""
  description

  """column name"""
  updatedAt

  """column name"""
  value
}

"""
input type for updating data in table "phase"
"""
input PhaseSetInput {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """
  Current phase flag (TRUE or NULL). Constrained to have at most one current phase
  """
  current: Boolean

  """Summary of activities and permissions during this phase"""
  description: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Phase identifier"""
  value: String
}

"""
Streaming cursor of the table "phase"
"""
input PhaseStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PhaseStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PhaseStreamCursorValueInput {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """
  Current phase flag (TRUE or NULL). Constrained to have at most one current phase
  """
  current: Boolean

  """Summary of activities and permissions during this phase"""
  description: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Phase identifier"""
  value: String
}

"""
update columns of table "phase"
"""
enum PhaseUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  current

  """column name"""
  description

  """column name"""
  updatedAt

  """column name"""
  value
}

input PhaseUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: PhaseSetInput

  """filter the rows which have to be updated"""
  where: PhaseBoolExp!
}

"""Teaching positions with associated service hour requirements"""
type Position {
  """
  Default annual teaching hours required for this position, can be overridden per teacher
  """
  baseServiceHours: Float

  """Timestamp when the record was created"""
  createdAt: timestamptz!

  """Optional description of the position"""
  description: String

  """Human-readable position name for display purposes"""
  label: String!

  """An array relationship"""
  teachers(
    """distinct select on columns"""
    distinctOn: [TeacherSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TeacherOrderBy!]

    """filter the rows returned"""
    where: TeacherBoolExp
  ): [Teacher!]!

  """An aggregate relationship"""
  teachersAggregate(
    """distinct select on columns"""
    distinctOn: [TeacherSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TeacherOrderBy!]

    """filter the rows returned"""
    where: TeacherBoolExp
  ): TeacherAggregate!

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz!

  """Position identifier (e.g., professor, lecturer)"""
  value: String!
}

"""
aggregated selection of "position"
"""
type PositionAggregate {
  aggregate: PositionAggregateFields
  nodes: [Position!]!
}

"""
aggregate fields of "position"
"""
type PositionAggregateFields {
  avg: PositionAvgFields
  count(columns: [PositionSelectColumn!], distinct: Boolean): Int!
  max: PositionMaxFields
  min: PositionMinFields
  stddev: PositionStddevFields
  stddevPop: PositionStddevPopFields
  stddevSamp: PositionStddevSampFields
  sum: PositionSumFields
  varPop: PositionVarPopFields
  varSamp: PositionVarSampFields
  variance: PositionVarianceFields
}

"""aggregate avg on columns"""
type PositionAvgFields {
  """
  Default annual teaching hours required for this position, can be overridden per teacher
  """
  baseServiceHours: Float
}

"""
Boolean expression to filter rows from the table "position". All fields are combined with a logical 'AND'.
"""
input PositionBoolExp {
  _and: [PositionBoolExp!]
  _not: PositionBoolExp
  _or: [PositionBoolExp!]
  baseServiceHours: FloatComparisonExp
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  label: StringComparisonExp
  teachers: TeacherBoolExp
  teachersAggregate: TeacherAggregateBoolExp
  updatedAt: TimestamptzComparisonExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "position"
"""
enum PositionConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  position_pkey
}

"""
input type for incrementing numeric columns in table "position"
"""
input PositionIncInput {
  """
  Default annual teaching hours required for this position, can be overridden per teacher
  """
  baseServiceHours: Float
}

"""
input type for inserting data into table "position"
"""
input PositionInsertInput {
  """
  Default annual teaching hours required for this position, can be overridden per teacher
  """
  baseServiceHours: Float

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Optional description of the position"""
  description: String

  """Human-readable position name for display purposes"""
  label: String
  teachers: TeacherArrRelInsertInput

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Position identifier (e.g., professor, lecturer)"""
  value: String
}

"""aggregate max on columns"""
type PositionMaxFields {
  """
  Default annual teaching hours required for this position, can be overridden per teacher
  """
  baseServiceHours: Float

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Optional description of the position"""
  description: String

  """Human-readable position name for display purposes"""
  label: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Position identifier (e.g., professor, lecturer)"""
  value: String
}

"""aggregate min on columns"""
type PositionMinFields {
  """
  Default annual teaching hours required for this position, can be overridden per teacher
  """
  baseServiceHours: Float

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Optional description of the position"""
  description: String

  """Human-readable position name for display purposes"""
  label: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Position identifier (e.g., professor, lecturer)"""
  value: String
}

"""
response of any mutation on the table "position"
"""
type PositionMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Position!]!
}

"""
input type for inserting object relation for remote table "position"
"""
input PositionObjRelInsertInput {
  data: PositionInsertInput!

  """upsert condition"""
  onConflict: PositionOnConflict
}

"""
on_conflict condition type for table "position"
"""
input PositionOnConflict {
  constraint: PositionConstraint!
  updateColumns: [PositionUpdateColumn!]! = []
  where: PositionBoolExp
}

"""Ordering options when selecting data from "position"."""
input PositionOrderBy {
  baseServiceHours: OrderBy
  createdAt: OrderBy
  description: OrderBy
  label: OrderBy
  teachersAggregate: TeacherAggregateOrderBy
  updatedAt: OrderBy
  value: OrderBy
}

"""primary key columns input for table: position"""
input PositionPkColumnsInput {
  """Position identifier (e.g., professor, lecturer)"""
  value: String!
}

"""
select columns of table "position"
"""
enum PositionSelectColumn {
  """column name"""
  baseServiceHours

  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  label

  """column name"""
  updatedAt

  """column name"""
  value
}

"""
input type for updating data in table "position"
"""
input PositionSetInput {
  """
  Default annual teaching hours required for this position, can be overridden per teacher
  """
  baseServiceHours: Float

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Optional description of the position"""
  description: String

  """Human-readable position name for display purposes"""
  label: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Position identifier (e.g., professor, lecturer)"""
  value: String
}

"""aggregate stddev on columns"""
type PositionStddevFields {
  """
  Default annual teaching hours required for this position, can be overridden per teacher
  """
  baseServiceHours: Float
}

"""aggregate stddevPop on columns"""
type PositionStddevPopFields {
  """
  Default annual teaching hours required for this position, can be overridden per teacher
  """
  baseServiceHours: Float
}

"""aggregate stddevSamp on columns"""
type PositionStddevSampFields {
  """
  Default annual teaching hours required for this position, can be overridden per teacher
  """
  baseServiceHours: Float
}

"""
Streaming cursor of the table "position"
"""
input PositionStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PositionStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PositionStreamCursorValueInput {
  """
  Default annual teaching hours required for this position, can be overridden per teacher
  """
  baseServiceHours: Float

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Optional description of the position"""
  description: String

  """Human-readable position name for display purposes"""
  label: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Position identifier (e.g., professor, lecturer)"""
  value: String
}

"""aggregate sum on columns"""
type PositionSumFields {
  """
  Default annual teaching hours required for this position, can be overridden per teacher
  """
  baseServiceHours: Float
}

"""
update columns of table "position"
"""
enum PositionUpdateColumn {
  """column name"""
  baseServiceHours

  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  label

  """column name"""
  updatedAt

  """column name"""
  value
}

input PositionUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: PositionIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: PositionSetInput

  """filter the rows which have to be updated"""
  where: PositionBoolExp!
}

"""aggregate varPop on columns"""
type PositionVarPopFields {
  """
  Default annual teaching hours required for this position, can be overridden per teacher
  """
  baseServiceHours: Float
}

"""aggregate varSamp on columns"""
type PositionVarSampFields {
  """
  Default annual teaching hours required for this position, can be overridden per teacher
  """
  baseServiceHours: Float
}

"""aggregate variance on columns"""
type PositionVarianceFields {
  """
  Default annual teaching hours required for this position, can be overridden per teacher
  """
  baseServiceHours: Float
}

"""Teacher course assignment history and priority status"""
type Priority {
  """An object relationship"""
  course: Course!

  """Course for which priority is tracked"""
  courseId: Int!

  """Timestamp when the record was created"""
  createdAt: timestamptz!

  """Unique priority record identifier"""
  id: Int!

  """Current priority status based on seniority and course rules"""
  isPriority: Boolean

  """Consecutive years teaching this course before current year"""
  seniority: Int

  """An object relationship"""
  service: Service!

  """Associated teacher service record"""
  serviceId: Int!

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz!
}

"""
aggregated selection of "priority"
"""
type PriorityAggregate {
  aggregate: PriorityAggregateFields
  nodes: [Priority!]!
}

input PriorityAggregateBoolExp {
  bool_and: priorityAggregateBoolExpBool_and
  bool_or: priorityAggregateBoolExpBool_or
  count: priorityAggregateBoolExpCount
}

"""
aggregate fields of "priority"
"""
type PriorityAggregateFields {
  avg: PriorityAvgFields
  count(columns: [PrioritySelectColumn!], distinct: Boolean): Int!
  max: PriorityMaxFields
  min: PriorityMinFields
  stddev: PriorityStddevFields
  stddevPop: PriorityStddevPopFields
  stddevSamp: PriorityStddevSampFields
  sum: PrioritySumFields
  varPop: PriorityVarPopFields
  varSamp: PriorityVarSampFields
  variance: PriorityVarianceFields
}

"""
order by aggregate values of table "priority"
"""
input PriorityAggregateOrderBy {
  avg: PriorityAvgOrderBy
  count: OrderBy
  max: PriorityMaxOrderBy
  min: PriorityMinOrderBy
  stddev: PriorityStddevOrderBy
  stddevPop: PriorityStddevPopOrderBy
  stddevSamp: PriorityStddevSampOrderBy
  sum: PrioritySumOrderBy
  varPop: PriorityVarPopOrderBy
  varSamp: PriorityVarSampOrderBy
  variance: PriorityVarianceOrderBy
}

"""
input type for inserting array relation for remote table "priority"
"""
input PriorityArrRelInsertInput {
  data: [PriorityInsertInput!]!

  """upsert condition"""
  onConflict: PriorityOnConflict
}

"""aggregate avg on columns"""
type PriorityAvgFields {
  """Course for which priority is tracked"""
  courseId: Float

  """Unique priority record identifier"""
  id: Float

  """Consecutive years teaching this course before current year"""
  seniority: Float

  """Associated teacher service record"""
  serviceId: Float
}

"""
order by avg() on columns of table "priority"
"""
input PriorityAvgOrderBy {
  """Course for which priority is tracked"""
  courseId: OrderBy

  """Unique priority record identifier"""
  id: OrderBy

  """Consecutive years teaching this course before current year"""
  seniority: OrderBy

  """Associated teacher service record"""
  serviceId: OrderBy
}

"""
Boolean expression to filter rows from the table "priority". All fields are combined with a logical 'AND'.
"""
input PriorityBoolExp {
  _and: [PriorityBoolExp!]
  _not: PriorityBoolExp
  _or: [PriorityBoolExp!]
  course: CourseBoolExp
  courseId: IntComparisonExp
  createdAt: TimestamptzComparisonExp
  id: IntComparisonExp
  isPriority: BooleanComparisonExp
  seniority: IntComparisonExp
  service: ServiceBoolExp
  serviceId: IntComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "priority"
"""
enum PriorityConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  priority_pkey

  """
  unique or primary key constraint on columns "course_id", "service_id"
  """
  priority_service_id_course_id_key
}

"""
input type for incrementing numeric columns in table "priority"
"""
input PriorityIncInput {
  """Course for which priority is tracked"""
  courseId: Int

  """Unique priority record identifier"""
  id: Int

  """Consecutive years teaching this course before current year"""
  seniority: Int

  """Associated teacher service record"""
  serviceId: Int
}

"""
input type for inserting data into table "priority"
"""
input PriorityInsertInput {
  course: CourseObjRelInsertInput

  """Course for which priority is tracked"""
  courseId: Int

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Unique priority record identifier"""
  id: Int

  """Current priority status based on seniority and course rules"""
  isPriority: Boolean

  """Consecutive years teaching this course before current year"""
  seniority: Int
  service: ServiceObjRelInsertInput

  """Associated teacher service record"""
  serviceId: Int

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type PriorityMaxFields {
  """Course for which priority is tracked"""
  courseId: Int

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Unique priority record identifier"""
  id: Int

  """Consecutive years teaching this course before current year"""
  seniority: Int

  """Associated teacher service record"""
  serviceId: Int

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""
order by max() on columns of table "priority"
"""
input PriorityMaxOrderBy {
  """Course for which priority is tracked"""
  courseId: OrderBy

  """Timestamp when the record was created"""
  createdAt: OrderBy

  """Unique priority record identifier"""
  id: OrderBy

  """Consecutive years teaching this course before current year"""
  seniority: OrderBy

  """Associated teacher service record"""
  serviceId: OrderBy

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type PriorityMinFields {
  """Course for which priority is tracked"""
  courseId: Int

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Unique priority record identifier"""
  id: Int

  """Consecutive years teaching this course before current year"""
  seniority: Int

  """Associated teacher service record"""
  serviceId: Int

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""
order by min() on columns of table "priority"
"""
input PriorityMinOrderBy {
  """Course for which priority is tracked"""
  courseId: OrderBy

  """Timestamp when the record was created"""
  createdAt: OrderBy

  """Unique priority record identifier"""
  id: OrderBy

  """Consecutive years teaching this course before current year"""
  seniority: OrderBy

  """Associated teacher service record"""
  serviceId: OrderBy

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: OrderBy
}

"""
response of any mutation on the table "priority"
"""
type PriorityMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Priority!]!
}

"""
on_conflict condition type for table "priority"
"""
input PriorityOnConflict {
  constraint: PriorityConstraint!
  updateColumns: [PriorityUpdateColumn!]! = []
  where: PriorityBoolExp
}

"""Ordering options when selecting data from "priority"."""
input PriorityOrderBy {
  course: CourseOrderBy
  courseId: OrderBy
  createdAt: OrderBy
  id: OrderBy
  isPriority: OrderBy
  seniority: OrderBy
  service: ServiceOrderBy
  serviceId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: priority"""
input PriorityPkColumnsInput {
  """Unique priority record identifier"""
  id: Int!
}

"""
select columns of table "priority"
"""
enum PrioritySelectColumn {
  """column name"""
  courseId

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  isPriority

  """column name"""
  seniority

  """column name"""
  serviceId

  """column name"""
  updatedAt
}

"""
select "priorityAggregateBoolExpBool_andArgumentsColumns" columns of table "priority"
"""
enum PrioritySelectColumnPriorityAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  isPriority
}

"""
select "priorityAggregateBoolExpBool_orArgumentsColumns" columns of table "priority"
"""
enum PrioritySelectColumnPriorityAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  isPriority
}

"""
input type for updating data in table "priority"
"""
input PrioritySetInput {
  """Course for which priority is tracked"""
  courseId: Int

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Unique priority record identifier"""
  id: Int

  """Current priority status based on seniority and course rules"""
  isPriority: Boolean

  """Consecutive years teaching this course before current year"""
  seniority: Int

  """Associated teacher service record"""
  serviceId: Int

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type PriorityStddevFields {
  """Course for which priority is tracked"""
  courseId: Float

  """Unique priority record identifier"""
  id: Float

  """Consecutive years teaching this course before current year"""
  seniority: Float

  """Associated teacher service record"""
  serviceId: Float
}

"""
order by stddev() on columns of table "priority"
"""
input PriorityStddevOrderBy {
  """Course for which priority is tracked"""
  courseId: OrderBy

  """Unique priority record identifier"""
  id: OrderBy

  """Consecutive years teaching this course before current year"""
  seniority: OrderBy

  """Associated teacher service record"""
  serviceId: OrderBy
}

"""aggregate stddevPop on columns"""
type PriorityStddevPopFields {
  """Course for which priority is tracked"""
  courseId: Float

  """Unique priority record identifier"""
  id: Float

  """Consecutive years teaching this course before current year"""
  seniority: Float

  """Associated teacher service record"""
  serviceId: Float
}

"""
order by stddevPop() on columns of table "priority"
"""
input PriorityStddevPopOrderBy {
  """Course for which priority is tracked"""
  courseId: OrderBy

  """Unique priority record identifier"""
  id: OrderBy

  """Consecutive years teaching this course before current year"""
  seniority: OrderBy

  """Associated teacher service record"""
  serviceId: OrderBy
}

"""aggregate stddevSamp on columns"""
type PriorityStddevSampFields {
  """Course for which priority is tracked"""
  courseId: Float

  """Unique priority record identifier"""
  id: Float

  """Consecutive years teaching this course before current year"""
  seniority: Float

  """Associated teacher service record"""
  serviceId: Float
}

"""
order by stddevSamp() on columns of table "priority"
"""
input PriorityStddevSampOrderBy {
  """Course for which priority is tracked"""
  courseId: OrderBy

  """Unique priority record identifier"""
  id: OrderBy

  """Consecutive years teaching this course before current year"""
  seniority: OrderBy

  """Associated teacher service record"""
  serviceId: OrderBy
}

"""
Streaming cursor of the table "priority"
"""
input PriorityStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PriorityStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PriorityStreamCursorValueInput {
  """Course for which priority is tracked"""
  courseId: Int

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Unique priority record identifier"""
  id: Int

  """Current priority status based on seniority and course rules"""
  isPriority: Boolean

  """Consecutive years teaching this course before current year"""
  seniority: Int

  """Associated teacher service record"""
  serviceId: Int

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type PrioritySumFields {
  """Course for which priority is tracked"""
  courseId: Int

  """Unique priority record identifier"""
  id: Int

  """Consecutive years teaching this course before current year"""
  seniority: Int

  """Associated teacher service record"""
  serviceId: Int
}

"""
order by sum() on columns of table "priority"
"""
input PrioritySumOrderBy {
  """Course for which priority is tracked"""
  courseId: OrderBy

  """Unique priority record identifier"""
  id: OrderBy

  """Consecutive years teaching this course before current year"""
  seniority: OrderBy

  """Associated teacher service record"""
  serviceId: OrderBy
}

"""
update columns of table "priority"
"""
enum PriorityUpdateColumn {
  """column name"""
  courseId

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  isPriority

  """column name"""
  seniority

  """column name"""
  serviceId

  """column name"""
  updatedAt
}

input PriorityUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: PriorityIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: PrioritySetInput

  """filter the rows which have to be updated"""
  where: PriorityBoolExp!
}

"""aggregate varPop on columns"""
type PriorityVarPopFields {
  """Course for which priority is tracked"""
  courseId: Float

  """Unique priority record identifier"""
  id: Float

  """Consecutive years teaching this course before current year"""
  seniority: Float

  """Associated teacher service record"""
  serviceId: Float
}

"""
order by varPop() on columns of table "priority"
"""
input PriorityVarPopOrderBy {
  """Course for which priority is tracked"""
  courseId: OrderBy

  """Unique priority record identifier"""
  id: OrderBy

  """Consecutive years teaching this course before current year"""
  seniority: OrderBy

  """Associated teacher service record"""
  serviceId: OrderBy
}

"""aggregate varSamp on columns"""
type PriorityVarSampFields {
  """Course for which priority is tracked"""
  courseId: Float

  """Unique priority record identifier"""
  id: Float

  """Consecutive years teaching this course before current year"""
  seniority: Float

  """Associated teacher service record"""
  serviceId: Float
}

"""
order by varSamp() on columns of table "priority"
"""
input PriorityVarSampOrderBy {
  """Course for which priority is tracked"""
  courseId: OrderBy

  """Unique priority record identifier"""
  id: OrderBy

  """Consecutive years teaching this course before current year"""
  seniority: OrderBy

  """Associated teacher service record"""
  serviceId: OrderBy
}

"""aggregate variance on columns"""
type PriorityVarianceFields {
  """Course for which priority is tracked"""
  courseId: Float

  """Unique priority record identifier"""
  id: Float

  """Consecutive years teaching this course before current year"""
  seniority: Float

  """Associated teacher service record"""
  serviceId: Float
}

"""
order by variance() on columns of table "priority"
"""
input PriorityVarianceOrderBy {
  """Course for which priority is tracked"""
  courseId: OrderBy

  """Unique priority record identifier"""
  id: OrderBy

  """Consecutive years teaching this course before current year"""
  seniority: OrderBy

  """Associated teacher service record"""
  serviceId: OrderBy
}

"""Academic programs within each degree"""
type Program {
  """An array relationship"""
  coordinations(
    """distinct select on columns"""
    distinctOn: [CoordinationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CoordinationOrderBy!]

    """filter the rows returned"""
    where: CoordinationBoolExp
  ): [Coordination!]!

  """An aggregate relationship"""
  coordinationsAggregate(
    """distinct select on columns"""
    distinctOn: [CoordinationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CoordinationOrderBy!]

    """filter the rows returned"""
    where: CoordinationBoolExp
  ): CoordinationAggregate!

  """An array relationship"""
  courses(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): [Course!]!

  """An aggregate relationship"""
  coursesAggregate(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): CourseAggregate!

  """Timestamp when the record was created"""
  createdAt: timestamptz!

  """An object relationship"""
  degree: Degree!

  """Parent degree for this program"""
  degreeId: Int!

  """Unique program identifier"""
  id: Int!

  """Full program name, unique within its degree (e.g., Mathematics)"""
  name: String!

  """Abbreviated program name"""
  nameShort: String
  nomImport: String

  """An array relationship"""
  tracks(
    """distinct select on columns"""
    distinctOn: [TrackSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TrackOrderBy!]

    """filter the rows returned"""
    where: TrackBoolExp
  ): [Track!]!

  """An aggregate relationship"""
  tracksAggregate(
    """distinct select on columns"""
    distinctOn: [TrackSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TrackOrderBy!]

    """filter the rows returned"""
    where: TrackBoolExp
  ): TrackAggregate!

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz!

  """Controls program visibility in the user interface and queries"""
  visible: Boolean!
}

"""
aggregated selection of "program"
"""
type ProgramAggregate {
  aggregate: ProgramAggregateFields
  nodes: [Program!]!
}

input ProgramAggregateBoolExp {
  bool_and: programAggregateBoolExpBool_and
  bool_or: programAggregateBoolExpBool_or
  count: programAggregateBoolExpCount
}

"""
aggregate fields of "program"
"""
type ProgramAggregateFields {
  avg: ProgramAvgFields
  count(columns: [ProgramSelectColumn!], distinct: Boolean): Int!
  max: ProgramMaxFields
  min: ProgramMinFields
  stddev: ProgramStddevFields
  stddevPop: ProgramStddevPopFields
  stddevSamp: ProgramStddevSampFields
  sum: ProgramSumFields
  varPop: ProgramVarPopFields
  varSamp: ProgramVarSampFields
  variance: ProgramVarianceFields
}

"""
order by aggregate values of table "program"
"""
input ProgramAggregateOrderBy {
  avg: ProgramAvgOrderBy
  count: OrderBy
  max: ProgramMaxOrderBy
  min: ProgramMinOrderBy
  stddev: ProgramStddevOrderBy
  stddevPop: ProgramStddevPopOrderBy
  stddevSamp: ProgramStddevSampOrderBy
  sum: ProgramSumOrderBy
  varPop: ProgramVarPopOrderBy
  varSamp: ProgramVarSampOrderBy
  variance: ProgramVarianceOrderBy
}

"""
input type for inserting array relation for remote table "program"
"""
input ProgramArrRelInsertInput {
  data: [ProgramInsertInput!]!

  """upsert condition"""
  onConflict: ProgramOnConflict
}

"""aggregate avg on columns"""
type ProgramAvgFields {
  """Parent degree for this program"""
  degreeId: Float

  """Unique program identifier"""
  id: Float
}

"""
order by avg() on columns of table "program"
"""
input ProgramAvgOrderBy {
  """Parent degree for this program"""
  degreeId: OrderBy

  """Unique program identifier"""
  id: OrderBy
}

"""
Boolean expression to filter rows from the table "program". All fields are combined with a logical 'AND'.
"""
input ProgramBoolExp {
  _and: [ProgramBoolExp!]
  _not: ProgramBoolExp
  _or: [ProgramBoolExp!]
  coordinations: CoordinationBoolExp
  coordinationsAggregate: CoordinationAggregateBoolExp
  courses: CourseBoolExp
  coursesAggregate: CourseAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  degree: DegreeBoolExp
  degreeId: IntComparisonExp
  id: IntComparisonExp
  name: StringComparisonExp
  nameShort: StringComparisonExp
  nomImport: StringComparisonExp
  tracks: TrackBoolExp
  tracksAggregate: TrackAggregateBoolExp
  updatedAt: TimestamptzComparisonExp
  visible: BooleanComparisonExp
}

"""
unique or primary key constraints on table "program"
"""
enum ProgramConstraint {
  """
  unique or primary key constraint on columns "degree_id", "name"
  """
  program_degree_id_name_key

  """
  unique or primary key constraint on columns "id"
  """
  program_pkey
}

"""
input type for incrementing numeric columns in table "program"
"""
input ProgramIncInput {
  """Parent degree for this program"""
  degreeId: Int

  """Unique program identifier"""
  id: Int
}

"""
input type for inserting data into table "program"
"""
input ProgramInsertInput {
  coordinations: CoordinationArrRelInsertInput
  courses: CourseArrRelInsertInput

  """Timestamp when the record was created"""
  createdAt: timestamptz
  degree: DegreeObjRelInsertInput

  """Parent degree for this program"""
  degreeId: Int

  """Unique program identifier"""
  id: Int

  """Full program name, unique within its degree (e.g., Mathematics)"""
  name: String

  """Abbreviated program name"""
  nameShort: String
  nomImport: String
  tracks: TrackArrRelInsertInput

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Controls program visibility in the user interface and queries"""
  visible: Boolean
}

"""aggregate max on columns"""
type ProgramMaxFields {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Parent degree for this program"""
  degreeId: Int

  """Unique program identifier"""
  id: Int

  """Full program name, unique within its degree (e.g., Mathematics)"""
  name: String

  """Abbreviated program name"""
  nameShort: String
  nomImport: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""
order by max() on columns of table "program"
"""
input ProgramMaxOrderBy {
  """Timestamp when the record was created"""
  createdAt: OrderBy

  """Parent degree for this program"""
  degreeId: OrderBy

  """Unique program identifier"""
  id: OrderBy

  """Full program name, unique within its degree (e.g., Mathematics)"""
  name: OrderBy

  """Abbreviated program name"""
  nameShort: OrderBy
  nomImport: OrderBy

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type ProgramMinFields {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Parent degree for this program"""
  degreeId: Int

  """Unique program identifier"""
  id: Int

  """Full program name, unique within its degree (e.g., Mathematics)"""
  name: String

  """Abbreviated program name"""
  nameShort: String
  nomImport: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""
order by min() on columns of table "program"
"""
input ProgramMinOrderBy {
  """Timestamp when the record was created"""
  createdAt: OrderBy

  """Parent degree for this program"""
  degreeId: OrderBy

  """Unique program identifier"""
  id: OrderBy

  """Full program name, unique within its degree (e.g., Mathematics)"""
  name: OrderBy

  """Abbreviated program name"""
  nameShort: OrderBy
  nomImport: OrderBy

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: OrderBy
}

"""
response of any mutation on the table "program"
"""
type ProgramMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Program!]!
}

"""
input type for inserting object relation for remote table "program"
"""
input ProgramObjRelInsertInput {
  data: ProgramInsertInput!

  """upsert condition"""
  onConflict: ProgramOnConflict
}

"""
on_conflict condition type for table "program"
"""
input ProgramOnConflict {
  constraint: ProgramConstraint!
  updateColumns: [ProgramUpdateColumn!]! = []
  where: ProgramBoolExp
}

"""Ordering options when selecting data from "program"."""
input ProgramOrderBy {
  coordinationsAggregate: CoordinationAggregateOrderBy
  coursesAggregate: CourseAggregateOrderBy
  createdAt: OrderBy
  degree: DegreeOrderBy
  degreeId: OrderBy
  id: OrderBy
  name: OrderBy
  nameShort: OrderBy
  nomImport: OrderBy
  tracksAggregate: TrackAggregateOrderBy
  updatedAt: OrderBy
  visible: OrderBy
}

"""primary key columns input for table: program"""
input ProgramPkColumnsInput {
  """Unique program identifier"""
  id: Int!
}

"""
select columns of table "program"
"""
enum ProgramSelectColumn {
  """column name"""
  createdAt

  """column name"""
  degreeId

  """column name"""
  id

  """column name"""
  name

  """column name"""
  nameShort

  """column name"""
  nomImport

  """column name"""
  updatedAt

  """column name"""
  visible
}

"""
select "programAggregateBoolExpBool_andArgumentsColumns" columns of table "program"
"""
enum ProgramSelectColumnProgramAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  visible
}

"""
select "programAggregateBoolExpBool_orArgumentsColumns" columns of table "program"
"""
enum ProgramSelectColumnProgramAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  visible
}

"""
input type for updating data in table "program"
"""
input ProgramSetInput {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Parent degree for this program"""
  degreeId: Int

  """Unique program identifier"""
  id: Int

  """Full program name, unique within its degree (e.g., Mathematics)"""
  name: String

  """Abbreviated program name"""
  nameShort: String
  nomImport: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Controls program visibility in the user interface and queries"""
  visible: Boolean
}

"""aggregate stddev on columns"""
type ProgramStddevFields {
  """Parent degree for this program"""
  degreeId: Float

  """Unique program identifier"""
  id: Float
}

"""
order by stddev() on columns of table "program"
"""
input ProgramStddevOrderBy {
  """Parent degree for this program"""
  degreeId: OrderBy

  """Unique program identifier"""
  id: OrderBy
}

"""aggregate stddevPop on columns"""
type ProgramStddevPopFields {
  """Parent degree for this program"""
  degreeId: Float

  """Unique program identifier"""
  id: Float
}

"""
order by stddevPop() on columns of table "program"
"""
input ProgramStddevPopOrderBy {
  """Parent degree for this program"""
  degreeId: OrderBy

  """Unique program identifier"""
  id: OrderBy
}

"""aggregate stddevSamp on columns"""
type ProgramStddevSampFields {
  """Parent degree for this program"""
  degreeId: Float

  """Unique program identifier"""
  id: Float
}

"""
order by stddevSamp() on columns of table "program"
"""
input ProgramStddevSampOrderBy {
  """Parent degree for this program"""
  degreeId: OrderBy

  """Unique program identifier"""
  id: OrderBy
}

"""
Streaming cursor of the table "program"
"""
input ProgramStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ProgramStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ProgramStreamCursorValueInput {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Parent degree for this program"""
  degreeId: Int

  """Unique program identifier"""
  id: Int

  """Full program name, unique within its degree (e.g., Mathematics)"""
  name: String

  """Abbreviated program name"""
  nameShort: String
  nomImport: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Controls program visibility in the user interface and queries"""
  visible: Boolean
}

"""aggregate sum on columns"""
type ProgramSumFields {
  """Parent degree for this program"""
  degreeId: Int

  """Unique program identifier"""
  id: Int
}

"""
order by sum() on columns of table "program"
"""
input ProgramSumOrderBy {
  """Parent degree for this program"""
  degreeId: OrderBy

  """Unique program identifier"""
  id: OrderBy
}

"""
update columns of table "program"
"""
enum ProgramUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  degreeId

  """column name"""
  id

  """column name"""
  name

  """column name"""
  nameShort

  """column name"""
  nomImport

  """column name"""
  updatedAt

  """column name"""
  visible
}

input ProgramUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: ProgramIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: ProgramSetInput

  """filter the rows which have to be updated"""
  where: ProgramBoolExp!
}

"""aggregate varPop on columns"""
type ProgramVarPopFields {
  """Parent degree for this program"""
  degreeId: Float

  """Unique program identifier"""
  id: Float
}

"""
order by varPop() on columns of table "program"
"""
input ProgramVarPopOrderBy {
  """Parent degree for this program"""
  degreeId: OrderBy

  """Unique program identifier"""
  id: OrderBy
}

"""aggregate varSamp on columns"""
type ProgramVarSampFields {
  """Parent degree for this program"""
  degreeId: Float

  """Unique program identifier"""
  id: Float
}

"""
order by varSamp() on columns of table "program"
"""
input ProgramVarSampOrderBy {
  """Parent degree for this program"""
  degreeId: OrderBy

  """Unique program identifier"""
  id: OrderBy
}

"""aggregate variance on columns"""
type ProgramVarianceFields {
  """Parent degree for this program"""
  degreeId: Float

  """Unique program identifier"""
  id: Float
}

"""
order by variance() on columns of table "program"
"""
input ProgramVarianceOrderBy {
  """Parent degree for this program"""
  degreeId: OrderBy

  """Unique program identifier"""
  id: OrderBy
}

"""Teacher requests and assignments for courses"""
type Request {
  """An object relationship"""
  course: Course!

  """Requested or assigned course"""
  courseId: Int!

  """Timestamp when the record was created"""
  createdAt: timestamptz!

  """Requested or assigned teaching hours"""
  hours: Float!

  """
  Calculates weighted hours for a request by multiplying the requested hours by the course type coefficient
  """
  hoursWeighted: Float

  """Unique request identifier"""
  id: Int!

  """
  Determines if a request is prioritized based on teaching history and course priority rules
  """
  isPriority: Boolean

  """An object relationship"""
  service: Service!

  """Associated teacher service record"""
  serviceId: Int!

  """Type of request (primary choice, backup, or final assignment)"""
  type: String!

  """An object relationship"""
  typeByType: RequestType!

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz!
}

"""
aggregated selection of "request"
"""
type RequestAggregate {
  aggregate: RequestAggregateFields
  nodes: [Request!]!
}

input RequestAggregateBoolExp {
  count: requestAggregateBoolExpCount
}

"""
aggregate fields of "request"
"""
type RequestAggregateFields {
  avg: RequestAvgFields
  count(columns: [RequestSelectColumn!], distinct: Boolean): Int!
  max: RequestMaxFields
  min: RequestMinFields
  stddev: RequestStddevFields
  stddevPop: RequestStddevPopFields
  stddevSamp: RequestStddevSampFields
  sum: RequestSumFields
  varPop: RequestVarPopFields
  varSamp: RequestVarSampFields
  variance: RequestVarianceFields
}

"""
order by aggregate values of table "request"
"""
input RequestAggregateOrderBy {
  avg: RequestAvgOrderBy
  count: OrderBy
  max: RequestMaxOrderBy
  min: RequestMinOrderBy
  stddev: RequestStddevOrderBy
  stddevPop: RequestStddevPopOrderBy
  stddevSamp: RequestStddevSampOrderBy
  sum: RequestSumOrderBy
  varPop: RequestVarPopOrderBy
  varSamp: RequestVarSampOrderBy
  variance: RequestVarianceOrderBy
}

"""
input type for inserting array relation for remote table "request"
"""
input RequestArrRelInsertInput {
  data: [RequestInsertInput!]!

  """upsert condition"""
  onConflict: RequestOnConflict
}

"""aggregate avg on columns"""
type RequestAvgFields {
  """Requested or assigned course"""
  courseId: Float

  """Requested or assigned teaching hours"""
  hours: Float

  """
  Calculates weighted hours for a request by multiplying the requested hours by the course type coefficient
  """
  hoursWeighted: Float

  """Unique request identifier"""
  id: Float

  """Associated teacher service record"""
  serviceId: Float
}

"""
order by avg() on columns of table "request"
"""
input RequestAvgOrderBy {
  """Requested or assigned course"""
  courseId: OrderBy

  """Requested or assigned teaching hours"""
  hours: OrderBy

  """Unique request identifier"""
  id: OrderBy

  """Associated teacher service record"""
  serviceId: OrderBy
}

"""
Boolean expression to filter rows from the table "request". All fields are combined with a logical 'AND'.
"""
input RequestBoolExp {
  _and: [RequestBoolExp!]
  _not: RequestBoolExp
  _or: [RequestBoolExp!]
  course: CourseBoolExp
  courseId: IntComparisonExp
  createdAt: TimestamptzComparisonExp
  hours: FloatComparisonExp
  hoursWeighted: FloatComparisonExp
  id: IntComparisonExp
  isPriority: BooleanComparisonExp
  service: ServiceBoolExp
  serviceId: IntComparisonExp
  type: StringComparisonExp
  typeByType: RequestTypeBoolExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "request"
"""
enum RequestConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  request_pkey

  """
  unique or primary key constraint on columns "type", "course_id", "service_id"
  """
  request_service_id_course_id_type_key
}

"""
input type for incrementing numeric columns in table "request"
"""
input RequestIncInput {
  """Requested or assigned course"""
  courseId: Int

  """Requested or assigned teaching hours"""
  hours: Float

  """Unique request identifier"""
  id: Int

  """Associated teacher service record"""
  serviceId: Int
}

"""
input type for inserting data into table "request"
"""
input RequestInsertInput {
  course: CourseObjRelInsertInput

  """Requested or assigned course"""
  courseId: Int

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Requested or assigned teaching hours"""
  hours: Float

  """Unique request identifier"""
  id: Int
  service: ServiceObjRelInsertInput

  """Associated teacher service record"""
  serviceId: Int

  """Type of request (primary choice, backup, or final assignment)"""
  type: String
  typeByType: RequestTypeObjRelInsertInput

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type RequestMaxFields {
  """Requested or assigned course"""
  courseId: Int

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Requested or assigned teaching hours"""
  hours: Float

  """
  Calculates weighted hours for a request by multiplying the requested hours by the course type coefficient
  """
  hoursWeighted: Float

  """Unique request identifier"""
  id: Int

  """Associated teacher service record"""
  serviceId: Int

  """Type of request (primary choice, backup, or final assignment)"""
  type: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""
order by max() on columns of table "request"
"""
input RequestMaxOrderBy {
  """Requested or assigned course"""
  courseId: OrderBy

  """Timestamp when the record was created"""
  createdAt: OrderBy

  """Requested or assigned teaching hours"""
  hours: OrderBy

  """Unique request identifier"""
  id: OrderBy

  """Associated teacher service record"""
  serviceId: OrderBy

  """Type of request (primary choice, backup, or final assignment)"""
  type: OrderBy

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type RequestMinFields {
  """Requested or assigned course"""
  courseId: Int

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Requested or assigned teaching hours"""
  hours: Float

  """
  Calculates weighted hours for a request by multiplying the requested hours by the course type coefficient
  """
  hoursWeighted: Float

  """Unique request identifier"""
  id: Int

  """Associated teacher service record"""
  serviceId: Int

  """Type of request (primary choice, backup, or final assignment)"""
  type: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""
order by min() on columns of table "request"
"""
input RequestMinOrderBy {
  """Requested or assigned course"""
  courseId: OrderBy

  """Timestamp when the record was created"""
  createdAt: OrderBy

  """Requested or assigned teaching hours"""
  hours: OrderBy

  """Unique request identifier"""
  id: OrderBy

  """Associated teacher service record"""
  serviceId: OrderBy

  """Type of request (primary choice, backup, or final assignment)"""
  type: OrderBy

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: OrderBy
}

"""
response of any mutation on the table "request"
"""
type RequestMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Request!]!
}

"""
on_conflict condition type for table "request"
"""
input RequestOnConflict {
  constraint: RequestConstraint!
  updateColumns: [RequestUpdateColumn!]! = []
  where: RequestBoolExp
}

"""Ordering options when selecting data from "request"."""
input RequestOrderBy {
  course: CourseOrderBy
  courseId: OrderBy
  createdAt: OrderBy
  hours: OrderBy
  hoursWeighted: OrderBy
  id: OrderBy
  isPriority: OrderBy
  service: ServiceOrderBy
  serviceId: OrderBy
  type: OrderBy
  typeByType: RequestTypeOrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: request"""
input RequestPkColumnsInput {
  """Unique request identifier"""
  id: Int!
}

"""
select columns of table "request"
"""
enum RequestSelectColumn {
  """column name"""
  courseId

  """column name"""
  createdAt

  """column name"""
  hours

  """column name"""
  id

  """column name"""
  serviceId

  """column name"""
  type

  """column name"""
  updatedAt
}

"""
input type for updating data in table "request"
"""
input RequestSetInput {
  """Requested or assigned course"""
  courseId: Int

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Requested or assigned teaching hours"""
  hours: Float

  """Unique request identifier"""
  id: Int

  """Associated teacher service record"""
  serviceId: Int

  """Type of request (primary choice, backup, or final assignment)"""
  type: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type RequestStddevFields {
  """Requested or assigned course"""
  courseId: Float

  """Requested or assigned teaching hours"""
  hours: Float

  """
  Calculates weighted hours for a request by multiplying the requested hours by the course type coefficient
  """
  hoursWeighted: Float

  """Unique request identifier"""
  id: Float

  """Associated teacher service record"""
  serviceId: Float
}

"""
order by stddev() on columns of table "request"
"""
input RequestStddevOrderBy {
  """Requested or assigned course"""
  courseId: OrderBy

  """Requested or assigned teaching hours"""
  hours: OrderBy

  """Unique request identifier"""
  id: OrderBy

  """Associated teacher service record"""
  serviceId: OrderBy
}

"""aggregate stddevPop on columns"""
type RequestStddevPopFields {
  """Requested or assigned course"""
  courseId: Float

  """Requested or assigned teaching hours"""
  hours: Float

  """
  Calculates weighted hours for a request by multiplying the requested hours by the course type coefficient
  """
  hoursWeighted: Float

  """Unique request identifier"""
  id: Float

  """Associated teacher service record"""
  serviceId: Float
}

"""
order by stddevPop() on columns of table "request"
"""
input RequestStddevPopOrderBy {
  """Requested or assigned course"""
  courseId: OrderBy

  """Requested or assigned teaching hours"""
  hours: OrderBy

  """Unique request identifier"""
  id: OrderBy

  """Associated teacher service record"""
  serviceId: OrderBy
}

"""aggregate stddevSamp on columns"""
type RequestStddevSampFields {
  """Requested or assigned course"""
  courseId: Float

  """Requested or assigned teaching hours"""
  hours: Float

  """
  Calculates weighted hours for a request by multiplying the requested hours by the course type coefficient
  """
  hoursWeighted: Float

  """Unique request identifier"""
  id: Float

  """Associated teacher service record"""
  serviceId: Float
}

"""
order by stddevSamp() on columns of table "request"
"""
input RequestStddevSampOrderBy {
  """Requested or assigned course"""
  courseId: OrderBy

  """Requested or assigned teaching hours"""
  hours: OrderBy

  """Unique request identifier"""
  id: OrderBy

  """Associated teacher service record"""
  serviceId: OrderBy
}

"""
Streaming cursor of the table "request"
"""
input RequestStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: RequestStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input RequestStreamCursorValueInput {
  """Requested or assigned course"""
  courseId: Int

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Requested or assigned teaching hours"""
  hours: Float

  """Unique request identifier"""
  id: Int

  """Associated teacher service record"""
  serviceId: Int

  """Type of request (primary choice, backup, or final assignment)"""
  type: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type RequestSumFields {
  """Requested or assigned course"""
  courseId: Int

  """Requested or assigned teaching hours"""
  hours: Float

  """
  Calculates weighted hours for a request by multiplying the requested hours by the course type coefficient
  """
  hoursWeighted: Float

  """Unique request identifier"""
  id: Int

  """Associated teacher service record"""
  serviceId: Int
}

"""
order by sum() on columns of table "request"
"""
input RequestSumOrderBy {
  """Requested or assigned course"""
  courseId: OrderBy

  """Requested or assigned teaching hours"""
  hours: OrderBy

  """Unique request identifier"""
  id: OrderBy

  """Associated teacher service record"""
  serviceId: OrderBy
}

"""Types of teaching assignment requests in workflow"""
type RequestType {
  """Timestamp when the record was created"""
  createdAt: timestamptz!

  """Detailed description of the request type and its purpose"""
  description: String

  """An array relationship"""
  requests(
    """distinct select on columns"""
    distinctOn: [RequestSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RequestOrderBy!]

    """filter the rows returned"""
    where: RequestBoolExp
  ): [Request!]!

  """An aggregate relationship"""
  requestsAggregate(
    """distinct select on columns"""
    distinctOn: [RequestSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RequestOrderBy!]

    """filter the rows returned"""
    where: RequestBoolExp
  ): RequestAggregate!

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz!

  """Request type identifier"""
  value: String!
}

"""
aggregated selection of "request_type"
"""
type RequestTypeAggregate {
  aggregate: RequestTypeAggregateFields
  nodes: [RequestType!]!
}

"""
aggregate fields of "request_type"
"""
type RequestTypeAggregateFields {
  count(columns: [RequestTypeSelectColumn!], distinct: Boolean): Int!
  max: RequestTypeMaxFields
  min: RequestTypeMinFields
}

"""
Boolean expression to filter rows from the table "request_type". All fields are combined with a logical 'AND'.
"""
input RequestTypeBoolExp {
  _and: [RequestTypeBoolExp!]
  _not: RequestTypeBoolExp
  _or: [RequestTypeBoolExp!]
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  requests: RequestBoolExp
  requestsAggregate: RequestAggregateBoolExp
  updatedAt: TimestamptzComparisonExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "request_type"
"""
enum RequestTypeConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  request_type_pkey
}

"""
input type for inserting data into table "request_type"
"""
input RequestTypeInsertInput {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Detailed description of the request type and its purpose"""
  description: String
  requests: RequestArrRelInsertInput

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Request type identifier"""
  value: String
}

"""aggregate max on columns"""
type RequestTypeMaxFields {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Detailed description of the request type and its purpose"""
  description: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Request type identifier"""
  value: String
}

"""aggregate min on columns"""
type RequestTypeMinFields {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Detailed description of the request type and its purpose"""
  description: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Request type identifier"""
  value: String
}

"""
response of any mutation on the table "request_type"
"""
type RequestTypeMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [RequestType!]!
}

"""
input type for inserting object relation for remote table "request_type"
"""
input RequestTypeObjRelInsertInput {
  data: RequestTypeInsertInput!

  """upsert condition"""
  onConflict: RequestTypeOnConflict
}

"""
on_conflict condition type for table "request_type"
"""
input RequestTypeOnConflict {
  constraint: RequestTypeConstraint!
  updateColumns: [RequestTypeUpdateColumn!]! = []
  where: RequestTypeBoolExp
}

"""Ordering options when selecting data from "request_type"."""
input RequestTypeOrderBy {
  createdAt: OrderBy
  description: OrderBy
  requestsAggregate: RequestAggregateOrderBy
  updatedAt: OrderBy
  value: OrderBy
}

"""primary key columns input for table: request_type"""
input RequestTypePkColumnsInput {
  """Request type identifier"""
  value: String!
}

"""
select columns of table "request_type"
"""
enum RequestTypeSelectColumn {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  updatedAt

  """column name"""
  value
}

"""
input type for updating data in table "request_type"
"""
input RequestTypeSetInput {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Detailed description of the request type and its purpose"""
  description: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Request type identifier"""
  value: String
}

"""
Streaming cursor of the table "request_type"
"""
input RequestTypeStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: RequestTypeStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input RequestTypeStreamCursorValueInput {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Detailed description of the request type and its purpose"""
  description: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Request type identifier"""
  value: String
}

"""
update columns of table "request_type"
"""
enum RequestTypeUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  updatedAt

  """column name"""
  value
}

input RequestTypeUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: RequestTypeSetInput

  """filter the rows which have to be updated"""
  where: RequestTypeBoolExp!
}

"""
update columns of table "request"
"""
enum RequestUpdateColumn {
  """column name"""
  courseId

  """column name"""
  createdAt

  """column name"""
  hours

  """column name"""
  id

  """column name"""
  serviceId

  """column name"""
  type

  """column name"""
  updatedAt
}

input RequestUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: RequestIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: RequestSetInput

  """filter the rows which have to be updated"""
  where: RequestBoolExp!
}

"""aggregate varPop on columns"""
type RequestVarPopFields {
  """Requested or assigned course"""
  courseId: Float

  """Requested or assigned teaching hours"""
  hours: Float

  """
  Calculates weighted hours for a request by multiplying the requested hours by the course type coefficient
  """
  hoursWeighted: Float

  """Unique request identifier"""
  id: Float

  """Associated teacher service record"""
  serviceId: Float
}

"""
order by varPop() on columns of table "request"
"""
input RequestVarPopOrderBy {
  """Requested or assigned course"""
  courseId: OrderBy

  """Requested or assigned teaching hours"""
  hours: OrderBy

  """Unique request identifier"""
  id: OrderBy

  """Associated teacher service record"""
  serviceId: OrderBy
}

"""aggregate varSamp on columns"""
type RequestVarSampFields {
  """Requested or assigned course"""
  courseId: Float

  """Requested or assigned teaching hours"""
  hours: Float

  """
  Calculates weighted hours for a request by multiplying the requested hours by the course type coefficient
  """
  hoursWeighted: Float

  """Unique request identifier"""
  id: Float

  """Associated teacher service record"""
  serviceId: Float
}

"""
order by varSamp() on columns of table "request"
"""
input RequestVarSampOrderBy {
  """Requested or assigned course"""
  courseId: OrderBy

  """Requested or assigned teaching hours"""
  hours: OrderBy

  """Unique request identifier"""
  id: OrderBy

  """Associated teacher service record"""
  serviceId: OrderBy
}

"""aggregate variance on columns"""
type RequestVarianceFields {
  """Requested or assigned course"""
  courseId: Float

  """Requested or assigned teaching hours"""
  hours: Float

  """
  Calculates weighted hours for a request by multiplying the requested hours by the course type coefficient
  """
  hoursWeighted: Float

  """Unique request identifier"""
  id: Float

  """Associated teacher service record"""
  serviceId: Float
}

"""
order by variance() on columns of table "request"
"""
input RequestVarianceOrderBy {
  """Requested or assigned course"""
  courseId: OrderBy

  """Requested or assigned teaching hours"""
  hours: OrderBy

  """Unique request identifier"""
  id: OrderBy

  """Associated teacher service record"""
  serviceId: OrderBy
}

"""Teacher role assignments for system privileges"""
type Role {
  """Additional information about this privilege assignment"""
  comment: String

  """Timestamp when the record was created"""
  createdAt: timestamptz!

  """Unique role assignment identifier"""
  id: Int!

  """An object relationship"""
  roleType: RoleType!

  """An object relationship"""
  teacher: Teacher!

  """Type of privileged role"""
  type: String!

  """Teacher identifier with role access"""
  uid: String!

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz!
}

"""
aggregated selection of "role"
"""
type RoleAggregate {
  aggregate: RoleAggregateFields
  nodes: [Role!]!
}

input RoleAggregateBoolExp {
  count: roleAggregateBoolExpCount
}

"""
aggregate fields of "role"
"""
type RoleAggregateFields {
  avg: RoleAvgFields
  count(columns: [RoleSelectColumn!], distinct: Boolean): Int!
  max: RoleMaxFields
  min: RoleMinFields
  stddev: RoleStddevFields
  stddevPop: RoleStddevPopFields
  stddevSamp: RoleStddevSampFields
  sum: RoleSumFields
  varPop: RoleVarPopFields
  varSamp: RoleVarSampFields
  variance: RoleVarianceFields
}

"""
order by aggregate values of table "role"
"""
input RoleAggregateOrderBy {
  avg: RoleAvgOrderBy
  count: OrderBy
  max: RoleMaxOrderBy
  min: RoleMinOrderBy
  stddev: RoleStddevOrderBy
  stddevPop: RoleStddevPopOrderBy
  stddevSamp: RoleStddevSampOrderBy
  sum: RoleSumOrderBy
  varPop: RoleVarPopOrderBy
  varSamp: RoleVarSampOrderBy
  variance: RoleVarianceOrderBy
}

"""
input type for inserting array relation for remote table "role"
"""
input RoleArrRelInsertInput {
  data: [RoleInsertInput!]!

  """upsert condition"""
  onConflict: RoleOnConflict
}

"""aggregate avg on columns"""
type RoleAvgFields {
  """Unique role assignment identifier"""
  id: Float
}

"""
order by avg() on columns of table "role"
"""
input RoleAvgOrderBy {
  """Unique role assignment identifier"""
  id: OrderBy
}

"""
Boolean expression to filter rows from the table "role". All fields are combined with a logical 'AND'.
"""
input RoleBoolExp {
  _and: [RoleBoolExp!]
  _not: RoleBoolExp
  _or: [RoleBoolExp!]
  comment: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  id: IntComparisonExp
  roleType: RoleTypeBoolExp
  teacher: TeacherBoolExp
  type: StringComparisonExp
  uid: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "role"
"""
enum RoleConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  role_pkey

  """
  unique or primary key constraint on columns "uid", "type"
  """
  role_uid_type_key
}

"""
input type for incrementing numeric columns in table "role"
"""
input RoleIncInput {
  """Unique role assignment identifier"""
  id: Int
}

"""
input type for inserting data into table "role"
"""
input RoleInsertInput {
  """Additional information about this privilege assignment"""
  comment: String

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Unique role assignment identifier"""
  id: Int
  roleType: RoleTypeObjRelInsertInput
  teacher: TeacherObjRelInsertInput

  """Type of privileged role"""
  type: String

  """Teacher identifier with role access"""
  uid: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type RoleMaxFields {
  """Additional information about this privilege assignment"""
  comment: String

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Unique role assignment identifier"""
  id: Int

  """Type of privileged role"""
  type: String

  """Teacher identifier with role access"""
  uid: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""
order by max() on columns of table "role"
"""
input RoleMaxOrderBy {
  """Additional information about this privilege assignment"""
  comment: OrderBy

  """Timestamp when the record was created"""
  createdAt: OrderBy

  """Unique role assignment identifier"""
  id: OrderBy

  """Type of privileged role"""
  type: OrderBy

  """Teacher identifier with role access"""
  uid: OrderBy

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type RoleMinFields {
  """Additional information about this privilege assignment"""
  comment: String

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Unique role assignment identifier"""
  id: Int

  """Type of privileged role"""
  type: String

  """Teacher identifier with role access"""
  uid: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""
order by min() on columns of table "role"
"""
input RoleMinOrderBy {
  """Additional information about this privilege assignment"""
  comment: OrderBy

  """Timestamp when the record was created"""
  createdAt: OrderBy

  """Unique role assignment identifier"""
  id: OrderBy

  """Type of privileged role"""
  type: OrderBy

  """Teacher identifier with role access"""
  uid: OrderBy

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: OrderBy
}

"""
response of any mutation on the table "role"
"""
type RoleMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Role!]!
}

"""
on_conflict condition type for table "role"
"""
input RoleOnConflict {
  constraint: RoleConstraint!
  updateColumns: [RoleUpdateColumn!]! = []
  where: RoleBoolExp
}

"""Ordering options when selecting data from "role"."""
input RoleOrderBy {
  comment: OrderBy
  createdAt: OrderBy
  id: OrderBy
  roleType: RoleTypeOrderBy
  teacher: TeacherOrderBy
  type: OrderBy
  uid: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: role"""
input RolePkColumnsInput {
  """Unique role assignment identifier"""
  id: Int!
}

"""
select columns of table "role"
"""
enum RoleSelectColumn {
  """column name"""
  comment

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  type

  """column name"""
  uid

  """column name"""
  updatedAt
}

"""
input type for updating data in table "role"
"""
input RoleSetInput {
  """Additional information about this privilege assignment"""
  comment: String

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Unique role assignment identifier"""
  id: Int

  """Type of privileged role"""
  type: String

  """Teacher identifier with role access"""
  uid: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type RoleStddevFields {
  """Unique role assignment identifier"""
  id: Float
}

"""
order by stddev() on columns of table "role"
"""
input RoleStddevOrderBy {
  """Unique role assignment identifier"""
  id: OrderBy
}

"""aggregate stddevPop on columns"""
type RoleStddevPopFields {
  """Unique role assignment identifier"""
  id: Float
}

"""
order by stddevPop() on columns of table "role"
"""
input RoleStddevPopOrderBy {
  """Unique role assignment identifier"""
  id: OrderBy
}

"""aggregate stddevSamp on columns"""
type RoleStddevSampFields {
  """Unique role assignment identifier"""
  id: Float
}

"""
order by stddevSamp() on columns of table "role"
"""
input RoleStddevSampOrderBy {
  """Unique role assignment identifier"""
  id: OrderBy
}

"""
Streaming cursor of the table "role"
"""
input RoleStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: RoleStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input RoleStreamCursorValueInput {
  """Additional information about this privilege assignment"""
  comment: String

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Unique role assignment identifier"""
  id: Int

  """Type of privileged role"""
  type: String

  """Teacher identifier with role access"""
  uid: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type RoleSumFields {
  """Unique role assignment identifier"""
  id: Int
}

"""
order by sum() on columns of table "role"
"""
input RoleSumOrderBy {
  """Unique role assignment identifier"""
  id: OrderBy
}

"""System roles for privileged access"""
type RoleType {
  """Timestamp when the record was created"""
  createdAt: timestamptz!

  """Description of role privileges and responsibilities"""
  description: String

  """An array relationship"""
  roles(
    """distinct select on columns"""
    distinctOn: [RoleSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RoleOrderBy!]

    """filter the rows returned"""
    where: RoleBoolExp
  ): [Role!]!

  """An aggregate relationship"""
  rolesAggregate(
    """distinct select on columns"""
    distinctOn: [RoleSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RoleOrderBy!]

    """filter the rows returned"""
    where: RoleBoolExp
  ): RoleAggregate!

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz!

  """Role identifier"""
  value: String!
}

"""
aggregated selection of "role_type"
"""
type RoleTypeAggregate {
  aggregate: RoleTypeAggregateFields
  nodes: [RoleType!]!
}

"""
aggregate fields of "role_type"
"""
type RoleTypeAggregateFields {
  count(columns: [RoleTypeSelectColumn!], distinct: Boolean): Int!
  max: RoleTypeMaxFields
  min: RoleTypeMinFields
}

"""
Boolean expression to filter rows from the table "role_type". All fields are combined with a logical 'AND'.
"""
input RoleTypeBoolExp {
  _and: [RoleTypeBoolExp!]
  _not: RoleTypeBoolExp
  _or: [RoleTypeBoolExp!]
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  roles: RoleBoolExp
  rolesAggregate: RoleAggregateBoolExp
  updatedAt: TimestamptzComparisonExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "role_type"
"""
enum RoleTypeConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  role_type_pkey
}

"""
input type for inserting data into table "role_type"
"""
input RoleTypeInsertInput {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Description of role privileges and responsibilities"""
  description: String
  roles: RoleArrRelInsertInput

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Role identifier"""
  value: String
}

"""aggregate max on columns"""
type RoleTypeMaxFields {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Description of role privileges and responsibilities"""
  description: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Role identifier"""
  value: String
}

"""aggregate min on columns"""
type RoleTypeMinFields {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Description of role privileges and responsibilities"""
  description: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Role identifier"""
  value: String
}

"""
response of any mutation on the table "role_type"
"""
type RoleTypeMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [RoleType!]!
}

"""
input type for inserting object relation for remote table "role_type"
"""
input RoleTypeObjRelInsertInput {
  data: RoleTypeInsertInput!

  """upsert condition"""
  onConflict: RoleTypeOnConflict
}

"""
on_conflict condition type for table "role_type"
"""
input RoleTypeOnConflict {
  constraint: RoleTypeConstraint!
  updateColumns: [RoleTypeUpdateColumn!]! = []
  where: RoleTypeBoolExp
}

"""Ordering options when selecting data from "role_type"."""
input RoleTypeOrderBy {
  createdAt: OrderBy
  description: OrderBy
  rolesAggregate: RoleAggregateOrderBy
  updatedAt: OrderBy
  value: OrderBy
}

"""primary key columns input for table: role_type"""
input RoleTypePkColumnsInput {
  """Role identifier"""
  value: String!
}

"""
select columns of table "role_type"
"""
enum RoleTypeSelectColumn {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  updatedAt

  """column name"""
  value
}

"""
input type for updating data in table "role_type"
"""
input RoleTypeSetInput {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Description of role privileges and responsibilities"""
  description: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Role identifier"""
  value: String
}

"""
Streaming cursor of the table "role_type"
"""
input RoleTypeStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: RoleTypeStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input RoleTypeStreamCursorValueInput {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Description of role privileges and responsibilities"""
  description: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Role identifier"""
  value: String
}

"""
update columns of table "role_type"
"""
enum RoleTypeUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  updatedAt

  """column name"""
  value
}

input RoleTypeUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: RoleTypeSetInput

  """filter the rows which have to be updated"""
  where: RoleTypeBoolExp!
}

"""
update columns of table "role"
"""
enum RoleUpdateColumn {
  """column name"""
  comment

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  type

  """column name"""
  uid

  """column name"""
  updatedAt
}

input RoleUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: RoleIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: RoleSetInput

  """filter the rows which have to be updated"""
  where: RoleBoolExp!
}

"""aggregate varPop on columns"""
type RoleVarPopFields {
  """Unique role assignment identifier"""
  id: Float
}

"""
order by varPop() on columns of table "role"
"""
input RoleVarPopOrderBy {
  """Unique role assignment identifier"""
  id: OrderBy
}

"""aggregate varSamp on columns"""
type RoleVarSampFields {
  """Unique role assignment identifier"""
  id: Float
}

"""
order by varSamp() on columns of table "role"
"""
input RoleVarSampOrderBy {
  """Unique role assignment identifier"""
  id: OrderBy
}

"""aggregate variance on columns"""
type RoleVarianceFields {
  """Unique role assignment identifier"""
  id: Float
}

"""
order by variance() on columns of table "role"
"""
input RoleVarianceOrderBy {
  """Unique role assignment identifier"""
  id: OrderBy
}

"""
Annual teaching service records tracking required hours and modifications
"""
type Service {
  """Timestamp when the record was created"""
  createdAt: timestamptz!

  """Required teaching hours for the year before modifications"""
  hours: Float!

  """Unique service identifier"""
  id: Int!

  """Optional message from teacher to course assignment committee"""
  message: String

  """An array relationship"""
  modifications(
    """distinct select on columns"""
    distinctOn: [ServiceModificationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceModificationOrderBy!]

    """filter the rows returned"""
    where: ServiceModificationBoolExp
  ): [ServiceModification!]!

  """An aggregate relationship"""
  modificationsAggregate(
    """distinct select on columns"""
    distinctOn: [ServiceModificationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceModificationOrderBy!]

    """filter the rows returned"""
    where: ServiceModificationBoolExp
  ): ServiceModificationAggregate!

  """An array relationship"""
  priorities(
    """distinct select on columns"""
    distinctOn: [PrioritySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PriorityOrderBy!]

    """filter the rows returned"""
    where: PriorityBoolExp
  ): [Priority!]!

  """An aggregate relationship"""
  prioritiesAggregate(
    """distinct select on columns"""
    distinctOn: [PrioritySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PriorityOrderBy!]

    """filter the rows returned"""
    where: PriorityBoolExp
  ): PriorityAggregate!

  """An array relationship"""
  requests(
    """distinct select on columns"""
    distinctOn: [RequestSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RequestOrderBy!]

    """filter the rows returned"""
    where: RequestBoolExp
  ): [Request!]!

  """An aggregate relationship"""
  requestsAggregate(
    """distinct select on columns"""
    distinctOn: [RequestSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RequestOrderBy!]

    """filter the rows returned"""
    where: RequestBoolExp
  ): RequestAggregate!

  """An object relationship"""
  teacher: Teacher!

  """Teacher identifier linking to teacher table"""
  uid: String!

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz!

  """Academic year for this service record"""
  year: Int!

  """An object relationship"""
  yearByYear: Year!
}

"""
aggregated selection of "service"
"""
type ServiceAggregate {
  aggregate: ServiceAggregateFields
  nodes: [Service!]!
}

input ServiceAggregateBoolExp {
  count: serviceAggregateBoolExpCount
}

"""
aggregate fields of "service"
"""
type ServiceAggregateFields {
  avg: ServiceAvgFields
  count(columns: [ServiceSelectColumn!], distinct: Boolean): Int!
  max: ServiceMaxFields
  min: ServiceMinFields
  stddev: ServiceStddevFields
  stddevPop: ServiceStddevPopFields
  stddevSamp: ServiceStddevSampFields
  sum: ServiceSumFields
  varPop: ServiceVarPopFields
  varSamp: ServiceVarSampFields
  variance: ServiceVarianceFields
}

"""
order by aggregate values of table "service"
"""
input ServiceAggregateOrderBy {
  avg: ServiceAvgOrderBy
  count: OrderBy
  max: ServiceMaxOrderBy
  min: ServiceMinOrderBy
  stddev: ServiceStddevOrderBy
  stddevPop: ServiceStddevPopOrderBy
  stddevSamp: ServiceStddevSampOrderBy
  sum: ServiceSumOrderBy
  varPop: ServiceVarPopOrderBy
  varSamp: ServiceVarSampOrderBy
  variance: ServiceVarianceOrderBy
}

"""
input type for inserting array relation for remote table "service"
"""
input ServiceArrRelInsertInput {
  data: [ServiceInsertInput!]!

  """upsert condition"""
  onConflict: ServiceOnConflict
}

"""aggregate avg on columns"""
type ServiceAvgFields {
  """Required teaching hours for the year before modifications"""
  hours: Float

  """Unique service identifier"""
  id: Float

  """Academic year for this service record"""
  year: Float
}

"""
order by avg() on columns of table "service"
"""
input ServiceAvgOrderBy {
  """Required teaching hours for the year before modifications"""
  hours: OrderBy

  """Unique service identifier"""
  id: OrderBy

  """Academic year for this service record"""
  year: OrderBy
}

"""
Boolean expression to filter rows from the table "service". All fields are combined with a logical 'AND'.
"""
input ServiceBoolExp {
  _and: [ServiceBoolExp!]
  _not: ServiceBoolExp
  _or: [ServiceBoolExp!]
  createdAt: TimestamptzComparisonExp
  hours: FloatComparisonExp
  id: IntComparisonExp
  message: StringComparisonExp
  modifications: ServiceModificationBoolExp
  modificationsAggregate: ServiceModificationAggregateBoolExp
  priorities: PriorityBoolExp
  prioritiesAggregate: PriorityAggregateBoolExp
  requests: RequestBoolExp
  requestsAggregate: RequestAggregateBoolExp
  teacher: TeacherBoolExp
  uid: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  year: IntComparisonExp
  yearByYear: YearBoolExp
}

"""
unique or primary key constraints on table "service"
"""
enum ServiceConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  service_pkey

  """
  unique or primary key constraint on columns "uid", "year"
  """
  service_year_uid_key
}

"""
input type for incrementing numeric columns in table "service"
"""
input ServiceIncInput {
  """Required teaching hours for the year before modifications"""
  hours: Float

  """Unique service identifier"""
  id: Int

  """Academic year for this service record"""
  year: Int
}

"""
input type for inserting data into table "service"
"""
input ServiceInsertInput {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Required teaching hours for the year before modifications"""
  hours: Float

  """Unique service identifier"""
  id: Int

  """Optional message from teacher to course assignment committee"""
  message: String
  modifications: ServiceModificationArrRelInsertInput
  priorities: PriorityArrRelInsertInput
  requests: RequestArrRelInsertInput
  teacher: TeacherObjRelInsertInput

  """Teacher identifier linking to teacher table"""
  uid: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Academic year for this service record"""
  year: Int
  yearByYear: YearObjRelInsertInput
}

"""aggregate max on columns"""
type ServiceMaxFields {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Required teaching hours for the year before modifications"""
  hours: Float

  """Unique service identifier"""
  id: Int

  """Optional message from teacher to course assignment committee"""
  message: String

  """Teacher identifier linking to teacher table"""
  uid: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Academic year for this service record"""
  year: Int
}

"""
order by max() on columns of table "service"
"""
input ServiceMaxOrderBy {
  """Timestamp when the record was created"""
  createdAt: OrderBy

  """Required teaching hours for the year before modifications"""
  hours: OrderBy

  """Unique service identifier"""
  id: OrderBy

  """Optional message from teacher to course assignment committee"""
  message: OrderBy

  """Teacher identifier linking to teacher table"""
  uid: OrderBy

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: OrderBy

  """Academic year for this service record"""
  year: OrderBy
}

"""aggregate min on columns"""
type ServiceMinFields {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Required teaching hours for the year before modifications"""
  hours: Float

  """Unique service identifier"""
  id: Int

  """Optional message from teacher to course assignment committee"""
  message: String

  """Teacher identifier linking to teacher table"""
  uid: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Academic year for this service record"""
  year: Int
}

"""
order by min() on columns of table "service"
"""
input ServiceMinOrderBy {
  """Timestamp when the record was created"""
  createdAt: OrderBy

  """Required teaching hours for the year before modifications"""
  hours: OrderBy

  """Unique service identifier"""
  id: OrderBy

  """Optional message from teacher to course assignment committee"""
  message: OrderBy

  """Teacher identifier linking to teacher table"""
  uid: OrderBy

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: OrderBy

  """Academic year for this service record"""
  year: OrderBy
}

"""Individual modifications to base teaching service hours"""
type ServiceModification {
  """Timestamp when the record was created"""
  createdAt: timestamptz!

  """Hour adjustment amount (negative values increase required hours)"""
  hours: Float!

  """Unique modification identifier"""
  id: Int!

  """An object relationship"""
  service: Service!

  """Reference to affected service record"""
  serviceId: Int!

  """Type of service modification being applied"""
  type: String!

  """An object relationship"""
  typeByType: ServiceModificationType!

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz!
}

"""
aggregated selection of "service_modification"
"""
type ServiceModificationAggregate {
  aggregate: ServiceModificationAggregateFields
  nodes: [ServiceModification!]!
}

input ServiceModificationAggregateBoolExp {
  count: serviceModificationAggregateBoolExpCount
}

"""
aggregate fields of "service_modification"
"""
type ServiceModificationAggregateFields {
  avg: ServiceModificationAvgFields
  count(columns: [ServiceModificationSelectColumn!], distinct: Boolean): Int!
  max: ServiceModificationMaxFields
  min: ServiceModificationMinFields
  stddev: ServiceModificationStddevFields
  stddevPop: ServiceModificationStddevPopFields
  stddevSamp: ServiceModificationStddevSampFields
  sum: ServiceModificationSumFields
  varPop: ServiceModificationVarPopFields
  varSamp: ServiceModificationVarSampFields
  variance: ServiceModificationVarianceFields
}

"""
order by aggregate values of table "service_modification"
"""
input ServiceModificationAggregateOrderBy {
  avg: ServiceModificationAvgOrderBy
  count: OrderBy
  max: ServiceModificationMaxOrderBy
  min: ServiceModificationMinOrderBy
  stddev: ServiceModificationStddevOrderBy
  stddevPop: ServiceModificationStddevPopOrderBy
  stddevSamp: ServiceModificationStddevSampOrderBy
  sum: ServiceModificationSumOrderBy
  varPop: ServiceModificationVarPopOrderBy
  varSamp: ServiceModificationVarSampOrderBy
  variance: ServiceModificationVarianceOrderBy
}

"""
input type for inserting array relation for remote table "service_modification"
"""
input ServiceModificationArrRelInsertInput {
  data: [ServiceModificationInsertInput!]!

  """upsert condition"""
  onConflict: ServiceModificationOnConflict
}

"""aggregate avg on columns"""
type ServiceModificationAvgFields {
  """Hour adjustment amount (negative values increase required hours)"""
  hours: Float

  """Unique modification identifier"""
  id: Float

  """Reference to affected service record"""
  serviceId: Float
}

"""
order by avg() on columns of table "service_modification"
"""
input ServiceModificationAvgOrderBy {
  """Hour adjustment amount (negative values increase required hours)"""
  hours: OrderBy

  """Unique modification identifier"""
  id: OrderBy

  """Reference to affected service record"""
  serviceId: OrderBy
}

"""
Boolean expression to filter rows from the table "service_modification". All fields are combined with a logical 'AND'.
"""
input ServiceModificationBoolExp {
  _and: [ServiceModificationBoolExp!]
  _not: ServiceModificationBoolExp
  _or: [ServiceModificationBoolExp!]
  createdAt: TimestamptzComparisonExp
  hours: FloatComparisonExp
  id: IntComparisonExp
  service: ServiceBoolExp
  serviceId: IntComparisonExp
  type: StringComparisonExp
  typeByType: ServiceModificationTypeBoolExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "service_modification"
"""
enum ServiceModificationConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  service_modification_pkey
}

"""
input type for incrementing numeric columns in table "service_modification"
"""
input ServiceModificationIncInput {
  """Hour adjustment amount (negative values increase required hours)"""
  hours: Float

  """Unique modification identifier"""
  id: Int

  """Reference to affected service record"""
  serviceId: Int
}

"""
input type for inserting data into table "service_modification"
"""
input ServiceModificationInsertInput {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Hour adjustment amount (negative values increase required hours)"""
  hours: Float

  """Unique modification identifier"""
  id: Int
  service: ServiceObjRelInsertInput

  """Reference to affected service record"""
  serviceId: Int

  """Type of service modification being applied"""
  type: String
  typeByType: ServiceModificationTypeObjRelInsertInput

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type ServiceModificationMaxFields {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Hour adjustment amount (negative values increase required hours)"""
  hours: Float

  """Unique modification identifier"""
  id: Int

  """Reference to affected service record"""
  serviceId: Int

  """Type of service modification being applied"""
  type: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""
order by max() on columns of table "service_modification"
"""
input ServiceModificationMaxOrderBy {
  """Timestamp when the record was created"""
  createdAt: OrderBy

  """Hour adjustment amount (negative values increase required hours)"""
  hours: OrderBy

  """Unique modification identifier"""
  id: OrderBy

  """Reference to affected service record"""
  serviceId: OrderBy

  """Type of service modification being applied"""
  type: OrderBy

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type ServiceModificationMinFields {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Hour adjustment amount (negative values increase required hours)"""
  hours: Float

  """Unique modification identifier"""
  id: Int

  """Reference to affected service record"""
  serviceId: Int

  """Type of service modification being applied"""
  type: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""
order by min() on columns of table "service_modification"
"""
input ServiceModificationMinOrderBy {
  """Timestamp when the record was created"""
  createdAt: OrderBy

  """Hour adjustment amount (negative values increase required hours)"""
  hours: OrderBy

  """Unique modification identifier"""
  id: OrderBy

  """Reference to affected service record"""
  serviceId: OrderBy

  """Type of service modification being applied"""
  type: OrderBy

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: OrderBy
}

"""
response of any mutation on the table "service_modification"
"""
type ServiceModificationMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ServiceModification!]!
}

"""
on_conflict condition type for table "service_modification"
"""
input ServiceModificationOnConflict {
  constraint: ServiceModificationConstraint!
  updateColumns: [ServiceModificationUpdateColumn!]! = []
  where: ServiceModificationBoolExp
}

"""Ordering options when selecting data from "service_modification"."""
input ServiceModificationOrderBy {
  createdAt: OrderBy
  hours: OrderBy
  id: OrderBy
  service: ServiceOrderBy
  serviceId: OrderBy
  type: OrderBy
  typeByType: ServiceModificationTypeOrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: service_modification"""
input ServiceModificationPkColumnsInput {
  """Unique modification identifier"""
  id: Int!
}

"""
select columns of table "service_modification"
"""
enum ServiceModificationSelectColumn {
  """column name"""
  createdAt

  """column name"""
  hours

  """column name"""
  id

  """column name"""
  serviceId

  """column name"""
  type

  """column name"""
  updatedAt
}

"""
input type for updating data in table "service_modification"
"""
input ServiceModificationSetInput {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Hour adjustment amount (negative values increase required hours)"""
  hours: Float

  """Unique modification identifier"""
  id: Int

  """Reference to affected service record"""
  serviceId: Int

  """Type of service modification being applied"""
  type: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type ServiceModificationStddevFields {
  """Hour adjustment amount (negative values increase required hours)"""
  hours: Float

  """Unique modification identifier"""
  id: Float

  """Reference to affected service record"""
  serviceId: Float
}

"""
order by stddev() on columns of table "service_modification"
"""
input ServiceModificationStddevOrderBy {
  """Hour adjustment amount (negative values increase required hours)"""
  hours: OrderBy

  """Unique modification identifier"""
  id: OrderBy

  """Reference to affected service record"""
  serviceId: OrderBy
}

"""aggregate stddevPop on columns"""
type ServiceModificationStddevPopFields {
  """Hour adjustment amount (negative values increase required hours)"""
  hours: Float

  """Unique modification identifier"""
  id: Float

  """Reference to affected service record"""
  serviceId: Float
}

"""
order by stddevPop() on columns of table "service_modification"
"""
input ServiceModificationStddevPopOrderBy {
  """Hour adjustment amount (negative values increase required hours)"""
  hours: OrderBy

  """Unique modification identifier"""
  id: OrderBy

  """Reference to affected service record"""
  serviceId: OrderBy
}

"""aggregate stddevSamp on columns"""
type ServiceModificationStddevSampFields {
  """Hour adjustment amount (negative values increase required hours)"""
  hours: Float

  """Unique modification identifier"""
  id: Float

  """Reference to affected service record"""
  serviceId: Float
}

"""
order by stddevSamp() on columns of table "service_modification"
"""
input ServiceModificationStddevSampOrderBy {
  """Hour adjustment amount (negative values increase required hours)"""
  hours: OrderBy

  """Unique modification identifier"""
  id: OrderBy

  """Reference to affected service record"""
  serviceId: OrderBy
}

"""
Streaming cursor of the table "service_modification"
"""
input ServiceModificationStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ServiceModificationStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ServiceModificationStreamCursorValueInput {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Hour adjustment amount (negative values increase required hours)"""
  hours: Float

  """Unique modification identifier"""
  id: Int

  """Reference to affected service record"""
  serviceId: Int

  """Type of service modification being applied"""
  type: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type ServiceModificationSumFields {
  """Hour adjustment amount (negative values increase required hours)"""
  hours: Float

  """Unique modification identifier"""
  id: Int

  """Reference to affected service record"""
  serviceId: Int
}

"""
order by sum() on columns of table "service_modification"
"""
input ServiceModificationSumOrderBy {
  """Hour adjustment amount (negative values increase required hours)"""
  hours: OrderBy

  """Unique modification identifier"""
  id: OrderBy

  """Reference to affected service record"""
  serviceId: OrderBy
}

"""Categories of service hour modifications"""
type ServiceModificationType {
  """Timestamp when the record was created"""
  createdAt: timestamptz!

  """Detailed explanation of the modification type and its application"""
  description: String

  """Human-readable name for the modification type"""
  label: String!

  """An aggregate relationship"""
  modificationsServiceAggregate(
    """distinct select on columns"""
    distinctOn: [ServiceModificationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceModificationOrderBy!]

    """filter the rows returned"""
    where: ServiceModificationBoolExp
  ): ServiceModificationAggregate!

  """An array relationship"""
  modifications_service(
    """distinct select on columns"""
    distinctOn: [ServiceModificationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceModificationOrderBy!]

    """filter the rows returned"""
    where: ServiceModificationBoolExp
  ): [ServiceModification!]!

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz!

  """Modification type identifier"""
  value: String!
}

"""
aggregated selection of "service_modification_type"
"""
type ServiceModificationTypeAggregate {
  aggregate: ServiceModificationTypeAggregateFields
  nodes: [ServiceModificationType!]!
}

"""
aggregate fields of "service_modification_type"
"""
type ServiceModificationTypeAggregateFields {
  count(columns: [ServiceModificationTypeSelectColumn!], distinct: Boolean): Int!
  max: ServiceModificationTypeMaxFields
  min: ServiceModificationTypeMinFields
}

"""
Boolean expression to filter rows from the table "service_modification_type". All fields are combined with a logical 'AND'.
"""
input ServiceModificationTypeBoolExp {
  _and: [ServiceModificationTypeBoolExp!]
  _not: ServiceModificationTypeBoolExp
  _or: [ServiceModificationTypeBoolExp!]
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  label: StringComparisonExp
  modifications_service: ServiceModificationBoolExp
  modifications_serviceAggregate: ServiceModificationAggregateBoolExp
  updatedAt: TimestamptzComparisonExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "service_modification_type"
"""
enum ServiceModificationTypeConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  service_modification_type_pkey
}

"""
input type for inserting data into table "service_modification_type"
"""
input ServiceModificationTypeInsertInput {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Detailed explanation of the modification type and its application"""
  description: String

  """Human-readable name for the modification type"""
  label: String
  modifications_service: ServiceModificationArrRelInsertInput

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Modification type identifier"""
  value: String
}

"""aggregate max on columns"""
type ServiceModificationTypeMaxFields {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Detailed explanation of the modification type and its application"""
  description: String

  """Human-readable name for the modification type"""
  label: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Modification type identifier"""
  value: String
}

"""aggregate min on columns"""
type ServiceModificationTypeMinFields {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Detailed explanation of the modification type and its application"""
  description: String

  """Human-readable name for the modification type"""
  label: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Modification type identifier"""
  value: String
}

"""
response of any mutation on the table "service_modification_type"
"""
type ServiceModificationTypeMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ServiceModificationType!]!
}

"""
input type for inserting object relation for remote table "service_modification_type"
"""
input ServiceModificationTypeObjRelInsertInput {
  data: ServiceModificationTypeInsertInput!

  """upsert condition"""
  onConflict: ServiceModificationTypeOnConflict
}

"""
on_conflict condition type for table "service_modification_type"
"""
input ServiceModificationTypeOnConflict {
  constraint: ServiceModificationTypeConstraint!
  updateColumns: [ServiceModificationTypeUpdateColumn!]! = []
  where: ServiceModificationTypeBoolExp
}

"""Ordering options when selecting data from "service_modification_type"."""
input ServiceModificationTypeOrderBy {
  createdAt: OrderBy
  description: OrderBy
  label: OrderBy
  modifications_serviceAggregate: ServiceModificationAggregateOrderBy
  updatedAt: OrderBy
  value: OrderBy
}

"""primary key columns input for table: service_modification_type"""
input ServiceModificationTypePkColumnsInput {
  """Modification type identifier"""
  value: String!
}

"""
select columns of table "service_modification_type"
"""
enum ServiceModificationTypeSelectColumn {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  label

  """column name"""
  updatedAt

  """column name"""
  value
}

"""
input type for updating data in table "service_modification_type"
"""
input ServiceModificationTypeSetInput {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Detailed explanation of the modification type and its application"""
  description: String

  """Human-readable name for the modification type"""
  label: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Modification type identifier"""
  value: String
}

"""
Streaming cursor of the table "service_modification_type"
"""
input ServiceModificationTypeStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ServiceModificationTypeStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ServiceModificationTypeStreamCursorValueInput {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Detailed explanation of the modification type and its application"""
  description: String

  """Human-readable name for the modification type"""
  label: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Modification type identifier"""
  value: String
}

"""
update columns of table "service_modification_type"
"""
enum ServiceModificationTypeUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  label

  """column name"""
  updatedAt

  """column name"""
  value
}

input ServiceModificationTypeUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: ServiceModificationTypeSetInput

  """filter the rows which have to be updated"""
  where: ServiceModificationTypeBoolExp!
}

"""
update columns of table "service_modification"
"""
enum ServiceModificationUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  hours

  """column name"""
  id

  """column name"""
  serviceId

  """column name"""
  type

  """column name"""
  updatedAt
}

input ServiceModificationUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: ServiceModificationIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: ServiceModificationSetInput

  """filter the rows which have to be updated"""
  where: ServiceModificationBoolExp!
}

"""aggregate varPop on columns"""
type ServiceModificationVarPopFields {
  """Hour adjustment amount (negative values increase required hours)"""
  hours: Float

  """Unique modification identifier"""
  id: Float

  """Reference to affected service record"""
  serviceId: Float
}

"""
order by varPop() on columns of table "service_modification"
"""
input ServiceModificationVarPopOrderBy {
  """Hour adjustment amount (negative values increase required hours)"""
  hours: OrderBy

  """Unique modification identifier"""
  id: OrderBy

  """Reference to affected service record"""
  serviceId: OrderBy
}

"""aggregate varSamp on columns"""
type ServiceModificationVarSampFields {
  """Hour adjustment amount (negative values increase required hours)"""
  hours: Float

  """Unique modification identifier"""
  id: Float

  """Reference to affected service record"""
  serviceId: Float
}

"""
order by varSamp() on columns of table "service_modification"
"""
input ServiceModificationVarSampOrderBy {
  """Hour adjustment amount (negative values increase required hours)"""
  hours: OrderBy

  """Unique modification identifier"""
  id: OrderBy

  """Reference to affected service record"""
  serviceId: OrderBy
}

"""aggregate variance on columns"""
type ServiceModificationVarianceFields {
  """Hour adjustment amount (negative values increase required hours)"""
  hours: Float

  """Unique modification identifier"""
  id: Float

  """Reference to affected service record"""
  serviceId: Float
}

"""
order by variance() on columns of table "service_modification"
"""
input ServiceModificationVarianceOrderBy {
  """Hour adjustment amount (negative values increase required hours)"""
  hours: OrderBy

  """Unique modification identifier"""
  id: OrderBy

  """Reference to affected service record"""
  serviceId: OrderBy
}

"""
response of any mutation on the table "service"
"""
type ServiceMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Service!]!
}

"""
input type for inserting object relation for remote table "service"
"""
input ServiceObjRelInsertInput {
  data: ServiceInsertInput!

  """upsert condition"""
  onConflict: ServiceOnConflict
}

"""
on_conflict condition type for table "service"
"""
input ServiceOnConflict {
  constraint: ServiceConstraint!
  updateColumns: [ServiceUpdateColumn!]! = []
  where: ServiceBoolExp
}

"""Ordering options when selecting data from "service"."""
input ServiceOrderBy {
  createdAt: OrderBy
  hours: OrderBy
  id: OrderBy
  message: OrderBy
  modificationsAggregate: ServiceModificationAggregateOrderBy
  prioritiesAggregate: PriorityAggregateOrderBy
  requestsAggregate: RequestAggregateOrderBy
  teacher: TeacherOrderBy
  uid: OrderBy
  updatedAt: OrderBy
  year: OrderBy
  yearByYear: YearOrderBy
}

"""primary key columns input for table: service"""
input ServicePkColumnsInput {
  """Unique service identifier"""
  id: Int!
}

"""
select columns of table "service"
"""
enum ServiceSelectColumn {
  """column name"""
  createdAt

  """column name"""
  hours

  """column name"""
  id

  """column name"""
  message

  """column name"""
  uid

  """column name"""
  updatedAt

  """column name"""
  year
}

"""
input type for updating data in table "service"
"""
input ServiceSetInput {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Required teaching hours for the year before modifications"""
  hours: Float

  """Unique service identifier"""
  id: Int

  """Optional message from teacher to course assignment committee"""
  message: String

  """Teacher identifier linking to teacher table"""
  uid: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Academic year for this service record"""
  year: Int
}

"""aggregate stddev on columns"""
type ServiceStddevFields {
  """Required teaching hours for the year before modifications"""
  hours: Float

  """Unique service identifier"""
  id: Float

  """Academic year for this service record"""
  year: Float
}

"""
order by stddev() on columns of table "service"
"""
input ServiceStddevOrderBy {
  """Required teaching hours for the year before modifications"""
  hours: OrderBy

  """Unique service identifier"""
  id: OrderBy

  """Academic year for this service record"""
  year: OrderBy
}

"""aggregate stddevPop on columns"""
type ServiceStddevPopFields {
  """Required teaching hours for the year before modifications"""
  hours: Float

  """Unique service identifier"""
  id: Float

  """Academic year for this service record"""
  year: Float
}

"""
order by stddevPop() on columns of table "service"
"""
input ServiceStddevPopOrderBy {
  """Required teaching hours for the year before modifications"""
  hours: OrderBy

  """Unique service identifier"""
  id: OrderBy

  """Academic year for this service record"""
  year: OrderBy
}

"""aggregate stddevSamp on columns"""
type ServiceStddevSampFields {
  """Required teaching hours for the year before modifications"""
  hours: Float

  """Unique service identifier"""
  id: Float

  """Academic year for this service record"""
  year: Float
}

"""
order by stddevSamp() on columns of table "service"
"""
input ServiceStddevSampOrderBy {
  """Required teaching hours for the year before modifications"""
  hours: OrderBy

  """Unique service identifier"""
  id: OrderBy

  """Academic year for this service record"""
  year: OrderBy
}

"""
Streaming cursor of the table "service"
"""
input ServiceStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ServiceStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ServiceStreamCursorValueInput {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Required teaching hours for the year before modifications"""
  hours: Float

  """Unique service identifier"""
  id: Int

  """Optional message from teacher to course assignment committee"""
  message: String

  """Teacher identifier linking to teacher table"""
  uid: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Academic year for this service record"""
  year: Int
}

"""aggregate sum on columns"""
type ServiceSumFields {
  """Required teaching hours for the year before modifications"""
  hours: Float

  """Unique service identifier"""
  id: Int

  """Academic year for this service record"""
  year: Int
}

"""
order by sum() on columns of table "service"
"""
input ServiceSumOrderBy {
  """Required teaching hours for the year before modifications"""
  hours: OrderBy

  """Unique service identifier"""
  id: OrderBy

  """Academic year for this service record"""
  year: OrderBy
}

"""
update columns of table "service"
"""
enum ServiceUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  hours

  """column name"""
  id

  """column name"""
  message

  """column name"""
  uid

  """column name"""
  updatedAt

  """column name"""
  year
}

input ServiceUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: ServiceIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: ServiceSetInput

  """filter the rows which have to be updated"""
  where: ServiceBoolExp!
}

"""aggregate varPop on columns"""
type ServiceVarPopFields {
  """Required teaching hours for the year before modifications"""
  hours: Float

  """Unique service identifier"""
  id: Float

  """Academic year for this service record"""
  year: Float
}

"""
order by varPop() on columns of table "service"
"""
input ServiceVarPopOrderBy {
  """Required teaching hours for the year before modifications"""
  hours: OrderBy

  """Unique service identifier"""
  id: OrderBy

  """Academic year for this service record"""
  year: OrderBy
}

"""aggregate varSamp on columns"""
type ServiceVarSampFields {
  """Required teaching hours for the year before modifications"""
  hours: Float

  """Unique service identifier"""
  id: Float

  """Academic year for this service record"""
  year: Float
}

"""
order by varSamp() on columns of table "service"
"""
input ServiceVarSampOrderBy {
  """Required teaching hours for the year before modifications"""
  hours: OrderBy

  """Unique service identifier"""
  id: OrderBy

  """Academic year for this service record"""
  year: OrderBy
}

"""aggregate variance on columns"""
type ServiceVarianceFields {
  """Required teaching hours for the year before modifications"""
  hours: Float

  """Unique service identifier"""
  id: Float

  """Academic year for this service record"""
  year: Float
}

"""
order by variance() on columns of table "service"
"""
input ServiceVarianceOrderBy {
  """Required teaching hours for the year before modifications"""
  hours: OrderBy

  """Unique service identifier"""
  id: OrderBy

  """Academic year for this service record"""
  year: OrderBy
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input StringComparisonExp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _isNull: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""Core teacher information and status"""
type Teacher {
  """
  Controls system access and automatic service creation for upcoming years
  """
  active: Boolean!

  """Optional display name, used instead of first/last name when set"""
  alias: String

  """
  Individual override for annual teaching hours, takes precedence over position's base hours
  """
  baseServiceHours: Float

  """An array relationship"""
  coordinations(
    """distinct select on columns"""
    distinctOn: [CoordinationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CoordinationOrderBy!]

    """filter the rows returned"""
    where: CoordinationBoolExp
  ): [Coordination!]!

  """An aggregate relationship"""
  coordinationsAggregate(
    """distinct select on columns"""
    distinctOn: [CoordinationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CoordinationOrderBy!]

    """filter the rows returned"""
    where: CoordinationBoolExp
  ): CoordinationAggregate!

  """Timestamp when the record was created"""
  createdAt: timestamptz!

  """Teacher's first name"""
  firstname: String!

  """Teacher's last name"""
  lastname: String!

  """Reference to teacher's position, determines default service hours"""
  position: String

  """An object relationship"""
  positionByPosition: Position

  """An array relationship"""
  roles(
    """distinct select on columns"""
    distinctOn: [RoleSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RoleOrderBy!]

    """filter the rows returned"""
    where: RoleBoolExp
  ): [Role!]!

  """An aggregate relationship"""
  rolesAggregate(
    """distinct select on columns"""
    distinctOn: [RoleSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RoleOrderBy!]

    """filter the rows returned"""
    where: RoleBoolExp
  ): RoleAggregate!

  """An array relationship"""
  services(
    """distinct select on columns"""
    distinctOn: [ServiceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceOrderBy!]

    """filter the rows returned"""
    where: ServiceBoolExp
  ): [Service!]!

  """An aggregate relationship"""
  servicesAggregate(
    """distinct select on columns"""
    distinctOn: [ServiceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceOrderBy!]

    """filter the rows returned"""
    where: ServiceBoolExp
  ): ServiceAggregate!

  """Teacher's email address (primary key)."""
  uid: String!

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz!

  """Controls teacher visibility in the user interface and queries"""
  visible: Boolean!
}

"""
aggregated selection of "teacher"
"""
type TeacherAggregate {
  aggregate: TeacherAggregateFields
  nodes: [Teacher!]!
}

input TeacherAggregateBoolExp {
  bool_and: teacherAggregateBoolExpBool_and
  bool_or: teacherAggregateBoolExpBool_or
  count: teacherAggregateBoolExpCount
}

"""
aggregate fields of "teacher"
"""
type TeacherAggregateFields {
  avg: TeacherAvgFields
  count(columns: [TeacherSelectColumn!], distinct: Boolean): Int!
  max: TeacherMaxFields
  min: TeacherMinFields
  stddev: TeacherStddevFields
  stddevPop: TeacherStddevPopFields
  stddevSamp: TeacherStddevSampFields
  sum: TeacherSumFields
  varPop: TeacherVarPopFields
  varSamp: TeacherVarSampFields
  variance: TeacherVarianceFields
}

"""
order by aggregate values of table "teacher"
"""
input TeacherAggregateOrderBy {
  avg: TeacherAvgOrderBy
  count: OrderBy
  max: TeacherMaxOrderBy
  min: TeacherMinOrderBy
  stddev: TeacherStddevOrderBy
  stddevPop: TeacherStddevPopOrderBy
  stddevSamp: TeacherStddevSampOrderBy
  sum: TeacherSumOrderBy
  varPop: TeacherVarPopOrderBy
  varSamp: TeacherVarSampOrderBy
  variance: TeacherVarianceOrderBy
}

"""
input type for inserting array relation for remote table "teacher"
"""
input TeacherArrRelInsertInput {
  data: [TeacherInsertInput!]!

  """upsert condition"""
  onConflict: TeacherOnConflict
}

"""aggregate avg on columns"""
type TeacherAvgFields {
  """
  Individual override for annual teaching hours, takes precedence over position's base hours
  """
  baseServiceHours: Float
}

"""
order by avg() on columns of table "teacher"
"""
input TeacherAvgOrderBy {
  """
  Individual override for annual teaching hours, takes precedence over position's base hours
  """
  baseServiceHours: OrderBy
}

"""
Boolean expression to filter rows from the table "teacher". All fields are combined with a logical 'AND'.
"""
input TeacherBoolExp {
  _and: [TeacherBoolExp!]
  _not: TeacherBoolExp
  _or: [TeacherBoolExp!]
  active: BooleanComparisonExp
  alias: StringComparisonExp
  baseServiceHours: FloatComparisonExp
  coordinations: CoordinationBoolExp
  coordinationsAggregate: CoordinationAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  firstname: StringComparisonExp
  lastname: StringComparisonExp
  position: StringComparisonExp
  positionByPosition: PositionBoolExp
  roles: RoleBoolExp
  rolesAggregate: RoleAggregateBoolExp
  services: ServiceBoolExp
  servicesAggregate: ServiceAggregateBoolExp
  uid: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  visible: BooleanComparisonExp
}

"""
unique or primary key constraints on table "teacher"
"""
enum TeacherConstraint {
  """
  unique or primary key constraint on columns "uid"
  """
  teacher_pkey
}

"""
input type for incrementing numeric columns in table "teacher"
"""
input TeacherIncInput {
  """
  Individual override for annual teaching hours, takes precedence over position's base hours
  """
  baseServiceHours: Float
}

"""
input type for inserting data into table "teacher"
"""
input TeacherInsertInput {
  """
  Controls system access and automatic service creation for upcoming years
  """
  active: Boolean

  """Optional display name, used instead of first/last name when set"""
  alias: String

  """
  Individual override for annual teaching hours, takes precedence over position's base hours
  """
  baseServiceHours: Float
  coordinations: CoordinationArrRelInsertInput

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Teacher's first name"""
  firstname: String

  """Teacher's last name"""
  lastname: String

  """Reference to teacher's position, determines default service hours"""
  position: String
  positionByPosition: PositionObjRelInsertInput
  roles: RoleArrRelInsertInput
  services: ServiceArrRelInsertInput

  """Teacher's email address (primary key)."""
  uid: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Controls teacher visibility in the user interface and queries"""
  visible: Boolean
}

"""aggregate max on columns"""
type TeacherMaxFields {
  """Optional display name, used instead of first/last name when set"""
  alias: String

  """
  Individual override for annual teaching hours, takes precedence over position's base hours
  """
  baseServiceHours: Float

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Teacher's first name"""
  firstname: String

  """Teacher's last name"""
  lastname: String

  """Reference to teacher's position, determines default service hours"""
  position: String

  """Teacher's email address (primary key)."""
  uid: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""
order by max() on columns of table "teacher"
"""
input TeacherMaxOrderBy {
  """Optional display name, used instead of first/last name when set"""
  alias: OrderBy

  """
  Individual override for annual teaching hours, takes precedence over position's base hours
  """
  baseServiceHours: OrderBy

  """Timestamp when the record was created"""
  createdAt: OrderBy

  """Teacher's first name"""
  firstname: OrderBy

  """Teacher's last name"""
  lastname: OrderBy

  """Reference to teacher's position, determines default service hours"""
  position: OrderBy

  """Teacher's email address (primary key)."""
  uid: OrderBy

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type TeacherMinFields {
  """Optional display name, used instead of first/last name when set"""
  alias: String

  """
  Individual override for annual teaching hours, takes precedence over position's base hours
  """
  baseServiceHours: Float

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Teacher's first name"""
  firstname: String

  """Teacher's last name"""
  lastname: String

  """Reference to teacher's position, determines default service hours"""
  position: String

  """Teacher's email address (primary key)."""
  uid: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""
order by min() on columns of table "teacher"
"""
input TeacherMinOrderBy {
  """Optional display name, used instead of first/last name when set"""
  alias: OrderBy

  """
  Individual override for annual teaching hours, takes precedence over position's base hours
  """
  baseServiceHours: OrderBy

  """Timestamp when the record was created"""
  createdAt: OrderBy

  """Teacher's first name"""
  firstname: OrderBy

  """Teacher's last name"""
  lastname: OrderBy

  """Reference to teacher's position, determines default service hours"""
  position: OrderBy

  """Teacher's email address (primary key)."""
  uid: OrderBy

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: OrderBy
}

"""
response of any mutation on the table "teacher"
"""
type TeacherMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Teacher!]!
}

"""
input type for inserting object relation for remote table "teacher"
"""
input TeacherObjRelInsertInput {
  data: TeacherInsertInput!

  """upsert condition"""
  onConflict: TeacherOnConflict
}

"""
on_conflict condition type for table "teacher"
"""
input TeacherOnConflict {
  constraint: TeacherConstraint!
  updateColumns: [TeacherUpdateColumn!]! = []
  where: TeacherBoolExp
}

"""Ordering options when selecting data from "teacher"."""
input TeacherOrderBy {
  active: OrderBy
  alias: OrderBy
  baseServiceHours: OrderBy
  coordinationsAggregate: CoordinationAggregateOrderBy
  createdAt: OrderBy
  firstname: OrderBy
  lastname: OrderBy
  position: OrderBy
  positionByPosition: PositionOrderBy
  rolesAggregate: RoleAggregateOrderBy
  servicesAggregate: ServiceAggregateOrderBy
  uid: OrderBy
  updatedAt: OrderBy
  visible: OrderBy
}

"""primary key columns input for table: teacher"""
input TeacherPkColumnsInput {
  """Teacher's email address (primary key)."""
  uid: String!
}

"""
select columns of table "teacher"
"""
enum TeacherSelectColumn {
  """column name"""
  active

  """column name"""
  alias

  """column name"""
  baseServiceHours

  """column name"""
  createdAt

  """column name"""
  firstname

  """column name"""
  lastname

  """column name"""
  position

  """column name"""
  uid

  """column name"""
  updatedAt

  """column name"""
  visible
}

"""
select "teacherAggregateBoolExpBool_andArgumentsColumns" columns of table "teacher"
"""
enum TeacherSelectColumnTeacherAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  active

  """column name"""
  visible
}

"""
select "teacherAggregateBoolExpBool_orArgumentsColumns" columns of table "teacher"
"""
enum TeacherSelectColumnTeacherAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  active

  """column name"""
  visible
}

"""
input type for updating data in table "teacher"
"""
input TeacherSetInput {
  """
  Controls system access and automatic service creation for upcoming years
  """
  active: Boolean

  """Optional display name, used instead of first/last name when set"""
  alias: String

  """
  Individual override for annual teaching hours, takes precedence over position's base hours
  """
  baseServiceHours: Float

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Teacher's first name"""
  firstname: String

  """Teacher's last name"""
  lastname: String

  """Reference to teacher's position, determines default service hours"""
  position: String

  """Teacher's email address (primary key)."""
  uid: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Controls teacher visibility in the user interface and queries"""
  visible: Boolean
}

"""aggregate stddev on columns"""
type TeacherStddevFields {
  """
  Individual override for annual teaching hours, takes precedence over position's base hours
  """
  baseServiceHours: Float
}

"""
order by stddev() on columns of table "teacher"
"""
input TeacherStddevOrderBy {
  """
  Individual override for annual teaching hours, takes precedence over position's base hours
  """
  baseServiceHours: OrderBy
}

"""aggregate stddevPop on columns"""
type TeacherStddevPopFields {
  """
  Individual override for annual teaching hours, takes precedence over position's base hours
  """
  baseServiceHours: Float
}

"""
order by stddevPop() on columns of table "teacher"
"""
input TeacherStddevPopOrderBy {
  """
  Individual override for annual teaching hours, takes precedence over position's base hours
  """
  baseServiceHours: OrderBy
}

"""aggregate stddevSamp on columns"""
type TeacherStddevSampFields {
  """
  Individual override for annual teaching hours, takes precedence over position's base hours
  """
  baseServiceHours: Float
}

"""
order by stddevSamp() on columns of table "teacher"
"""
input TeacherStddevSampOrderBy {
  """
  Individual override for annual teaching hours, takes precedence over position's base hours
  """
  baseServiceHours: OrderBy
}

"""
Streaming cursor of the table "teacher"
"""
input TeacherStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: TeacherStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input TeacherStreamCursorValueInput {
  """
  Controls system access and automatic service creation for upcoming years
  """
  active: Boolean

  """Optional display name, used instead of first/last name when set"""
  alias: String

  """
  Individual override for annual teaching hours, takes precedence over position's base hours
  """
  baseServiceHours: Float

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Teacher's first name"""
  firstname: String

  """Teacher's last name"""
  lastname: String

  """Reference to teacher's position, determines default service hours"""
  position: String

  """Teacher's email address (primary key)."""
  uid: String

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Controls teacher visibility in the user interface and queries"""
  visible: Boolean
}

"""aggregate sum on columns"""
type TeacherSumFields {
  """
  Individual override for annual teaching hours, takes precedence over position's base hours
  """
  baseServiceHours: Float
}

"""
order by sum() on columns of table "teacher"
"""
input TeacherSumOrderBy {
  """
  Individual override for annual teaching hours, takes precedence over position's base hours
  """
  baseServiceHours: OrderBy
}

"""
update columns of table "teacher"
"""
enum TeacherUpdateColumn {
  """column name"""
  active

  """column name"""
  alias

  """column name"""
  baseServiceHours

  """column name"""
  createdAt

  """column name"""
  firstname

  """column name"""
  lastname

  """column name"""
  position

  """column name"""
  uid

  """column name"""
  updatedAt

  """column name"""
  visible
}

input TeacherUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: TeacherIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: TeacherSetInput

  """filter the rows which have to be updated"""
  where: TeacherBoolExp!
}

"""aggregate varPop on columns"""
type TeacherVarPopFields {
  """
  Individual override for annual teaching hours, takes precedence over position's base hours
  """
  baseServiceHours: Float
}

"""
order by varPop() on columns of table "teacher"
"""
input TeacherVarPopOrderBy {
  """
  Individual override for annual teaching hours, takes precedence over position's base hours
  """
  baseServiceHours: OrderBy
}

"""aggregate varSamp on columns"""
type TeacherVarSampFields {
  """
  Individual override for annual teaching hours, takes precedence over position's base hours
  """
  baseServiceHours: Float
}

"""
order by varSamp() on columns of table "teacher"
"""
input TeacherVarSampOrderBy {
  """
  Individual override for annual teaching hours, takes precedence over position's base hours
  """
  baseServiceHours: OrderBy
}

"""aggregate variance on columns"""
type TeacherVarianceFields {
  """
  Individual override for annual teaching hours, takes precedence over position's base hours
  """
  baseServiceHours: Float
}

"""
order by variance() on columns of table "teacher"
"""
input TeacherVarianceOrderBy {
  """
  Individual override for annual teaching hours, takes precedence over position's base hours
  """
  baseServiceHours: OrderBy
}

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input TimestamptzComparisonExp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _isNull: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""Specialization tracks within academic programs"""
type Track {
  """An array relationship"""
  coordinations(
    """distinct select on columns"""
    distinctOn: [CoordinationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CoordinationOrderBy!]

    """filter the rows returned"""
    where: CoordinationBoolExp
  ): [Coordination!]!

  """An aggregate relationship"""
  coordinationsAggregate(
    """distinct select on columns"""
    distinctOn: [CoordinationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CoordinationOrderBy!]

    """filter the rows returned"""
    where: CoordinationBoolExp
  ): CoordinationAggregate!

  """An array relationship"""
  courses(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): [Course!]!

  """An aggregate relationship"""
  coursesAggregate(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): CourseAggregate!

  """Timestamp when the record was created"""
  createdAt: timestamptz!

  """Unique track identifier"""
  id: Int!

  """
  Full track name, unique within its program (e.g., Pure Mathematics, Applied Mathematics, Statistics, etc.)
  """
  name: String!

  """Abbreviated track name"""
  nameShort: String
  nomImport: String

  """An object relationship"""
  program: Program!

  """Parent program for this track"""
  programId: Int!

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz!

  """Controls track visibility in the user interface and queries"""
  visible: Boolean!
}

"""
aggregated selection of "track"
"""
type TrackAggregate {
  aggregate: TrackAggregateFields
  nodes: [Track!]!
}

input TrackAggregateBoolExp {
  bool_and: trackAggregateBoolExpBool_and
  bool_or: trackAggregateBoolExpBool_or
  count: trackAggregateBoolExpCount
}

"""
aggregate fields of "track"
"""
type TrackAggregateFields {
  avg: TrackAvgFields
  count(columns: [TrackSelectColumn!], distinct: Boolean): Int!
  max: TrackMaxFields
  min: TrackMinFields
  stddev: TrackStddevFields
  stddevPop: TrackStddevPopFields
  stddevSamp: TrackStddevSampFields
  sum: TrackSumFields
  varPop: TrackVarPopFields
  varSamp: TrackVarSampFields
  variance: TrackVarianceFields
}

"""
order by aggregate values of table "track"
"""
input TrackAggregateOrderBy {
  avg: TrackAvgOrderBy
  count: OrderBy
  max: TrackMaxOrderBy
  min: TrackMinOrderBy
  stddev: TrackStddevOrderBy
  stddevPop: TrackStddevPopOrderBy
  stddevSamp: TrackStddevSampOrderBy
  sum: TrackSumOrderBy
  varPop: TrackVarPopOrderBy
  varSamp: TrackVarSampOrderBy
  variance: TrackVarianceOrderBy
}

"""
input type for inserting array relation for remote table "track"
"""
input TrackArrRelInsertInput {
  data: [TrackInsertInput!]!

  """upsert condition"""
  onConflict: TrackOnConflict
}

"""aggregate avg on columns"""
type TrackAvgFields {
  """Unique track identifier"""
  id: Float

  """Parent program for this track"""
  programId: Float
}

"""
order by avg() on columns of table "track"
"""
input TrackAvgOrderBy {
  """Unique track identifier"""
  id: OrderBy

  """Parent program for this track"""
  programId: OrderBy
}

"""
Boolean expression to filter rows from the table "track". All fields are combined with a logical 'AND'.
"""
input TrackBoolExp {
  _and: [TrackBoolExp!]
  _not: TrackBoolExp
  _or: [TrackBoolExp!]
  coordinations: CoordinationBoolExp
  coordinationsAggregate: CoordinationAggregateBoolExp
  courses: CourseBoolExp
  coursesAggregate: CourseAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  id: IntComparisonExp
  name: StringComparisonExp
  nameShort: StringComparisonExp
  nomImport: StringComparisonExp
  program: ProgramBoolExp
  programId: IntComparisonExp
  updatedAt: TimestamptzComparisonExp
  visible: BooleanComparisonExp
}

"""
unique or primary key constraints on table "track"
"""
enum TrackConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  track_pkey

  """
  unique or primary key constraint on columns "program_id", "name"
  """
  track_program_id_name_key
}

"""
input type for incrementing numeric columns in table "track"
"""
input TrackIncInput {
  """Unique track identifier"""
  id: Int

  """Parent program for this track"""
  programId: Int
}

"""
input type for inserting data into table "track"
"""
input TrackInsertInput {
  coordinations: CoordinationArrRelInsertInput
  courses: CourseArrRelInsertInput

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Unique track identifier"""
  id: Int

  """
  Full track name, unique within its program (e.g., Pure Mathematics, Applied Mathematics, Statistics, etc.)
  """
  name: String

  """Abbreviated track name"""
  nameShort: String
  nomImport: String
  program: ProgramObjRelInsertInput

  """Parent program for this track"""
  programId: Int

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Controls track visibility in the user interface and queries"""
  visible: Boolean
}

"""aggregate max on columns"""
type TrackMaxFields {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Unique track identifier"""
  id: Int

  """
  Full track name, unique within its program (e.g., Pure Mathematics, Applied Mathematics, Statistics, etc.)
  """
  name: String

  """Abbreviated track name"""
  nameShort: String
  nomImport: String

  """Parent program for this track"""
  programId: Int

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""
order by max() on columns of table "track"
"""
input TrackMaxOrderBy {
  """Timestamp when the record was created"""
  createdAt: OrderBy

  """Unique track identifier"""
  id: OrderBy

  """
  Full track name, unique within its program (e.g., Pure Mathematics, Applied Mathematics, Statistics, etc.)
  """
  name: OrderBy

  """Abbreviated track name"""
  nameShort: OrderBy
  nomImport: OrderBy

  """Parent program for this track"""
  programId: OrderBy

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type TrackMinFields {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Unique track identifier"""
  id: Int

  """
  Full track name, unique within its program (e.g., Pure Mathematics, Applied Mathematics, Statistics, etc.)
  """
  name: String

  """Abbreviated track name"""
  nameShort: String
  nomImport: String

  """Parent program for this track"""
  programId: Int

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz
}

"""
order by min() on columns of table "track"
"""
input TrackMinOrderBy {
  """Timestamp when the record was created"""
  createdAt: OrderBy

  """Unique track identifier"""
  id: OrderBy

  """
  Full track name, unique within its program (e.g., Pure Mathematics, Applied Mathematics, Statistics, etc.)
  """
  name: OrderBy

  """Abbreviated track name"""
  nameShort: OrderBy
  nomImport: OrderBy

  """Parent program for this track"""
  programId: OrderBy

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: OrderBy
}

"""
response of any mutation on the table "track"
"""
type TrackMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Track!]!
}

"""
input type for inserting object relation for remote table "track"
"""
input TrackObjRelInsertInput {
  data: TrackInsertInput!

  """upsert condition"""
  onConflict: TrackOnConflict
}

"""
on_conflict condition type for table "track"
"""
input TrackOnConflict {
  constraint: TrackConstraint!
  updateColumns: [TrackUpdateColumn!]! = []
  where: TrackBoolExp
}

"""Ordering options when selecting data from "track"."""
input TrackOrderBy {
  coordinationsAggregate: CoordinationAggregateOrderBy
  coursesAggregate: CourseAggregateOrderBy
  createdAt: OrderBy
  id: OrderBy
  name: OrderBy
  nameShort: OrderBy
  nomImport: OrderBy
  program: ProgramOrderBy
  programId: OrderBy
  updatedAt: OrderBy
  visible: OrderBy
}

"""primary key columns input for table: track"""
input TrackPkColumnsInput {
  """Unique track identifier"""
  id: Int!
}

"""
select columns of table "track"
"""
enum TrackSelectColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  name

  """column name"""
  nameShort

  """column name"""
  nomImport

  """column name"""
  programId

  """column name"""
  updatedAt

  """column name"""
  visible
}

"""
select "trackAggregateBoolExpBool_andArgumentsColumns" columns of table "track"
"""
enum TrackSelectColumnTrackAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  visible
}

"""
select "trackAggregateBoolExpBool_orArgumentsColumns" columns of table "track"
"""
enum TrackSelectColumnTrackAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  visible
}

"""
input type for updating data in table "track"
"""
input TrackSetInput {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Unique track identifier"""
  id: Int

  """
  Full track name, unique within its program (e.g., Pure Mathematics, Applied Mathematics, Statistics, etc.)
  """
  name: String

  """Abbreviated track name"""
  nameShort: String
  nomImport: String

  """Parent program for this track"""
  programId: Int

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Controls track visibility in the user interface and queries"""
  visible: Boolean
}

"""aggregate stddev on columns"""
type TrackStddevFields {
  """Unique track identifier"""
  id: Float

  """Parent program for this track"""
  programId: Float
}

"""
order by stddev() on columns of table "track"
"""
input TrackStddevOrderBy {
  """Unique track identifier"""
  id: OrderBy

  """Parent program for this track"""
  programId: OrderBy
}

"""aggregate stddevPop on columns"""
type TrackStddevPopFields {
  """Unique track identifier"""
  id: Float

  """Parent program for this track"""
  programId: Float
}

"""
order by stddevPop() on columns of table "track"
"""
input TrackStddevPopOrderBy {
  """Unique track identifier"""
  id: OrderBy

  """Parent program for this track"""
  programId: OrderBy
}

"""aggregate stddevSamp on columns"""
type TrackStddevSampFields {
  """Unique track identifier"""
  id: Float

  """Parent program for this track"""
  programId: Float
}

"""
order by stddevSamp() on columns of table "track"
"""
input TrackStddevSampOrderBy {
  """Unique track identifier"""
  id: OrderBy

  """Parent program for this track"""
  programId: OrderBy
}

"""
Streaming cursor of the table "track"
"""
input TrackStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: TrackStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input TrackStreamCursorValueInput {
  """Timestamp when the record was created"""
  createdAt: timestamptz

  """Unique track identifier"""
  id: Int

  """
  Full track name, unique within its program (e.g., Pure Mathematics, Applied Mathematics, Statistics, etc.)
  """
  name: String

  """Abbreviated track name"""
  nameShort: String
  nomImport: String

  """Parent program for this track"""
  programId: Int

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Controls track visibility in the user interface and queries"""
  visible: Boolean
}

"""aggregate sum on columns"""
type TrackSumFields {
  """Unique track identifier"""
  id: Int

  """Parent program for this track"""
  programId: Int
}

"""
order by sum() on columns of table "track"
"""
input TrackSumOrderBy {
  """Unique track identifier"""
  id: OrderBy

  """Parent program for this track"""
  programId: OrderBy
}

"""
update columns of table "track"
"""
enum TrackUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  name

  """column name"""
  nameShort

  """column name"""
  nomImport

  """column name"""
  programId

  """column name"""
  updatedAt

  """column name"""
  visible
}

input TrackUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: TrackIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: TrackSetInput

  """filter the rows which have to be updated"""
  where: TrackBoolExp!
}

"""aggregate varPop on columns"""
type TrackVarPopFields {
  """Unique track identifier"""
  id: Float

  """Parent program for this track"""
  programId: Float
}

"""
order by varPop() on columns of table "track"
"""
input TrackVarPopOrderBy {
  """Unique track identifier"""
  id: OrderBy

  """Parent program for this track"""
  programId: OrderBy
}

"""aggregate varSamp on columns"""
type TrackVarSampFields {
  """Unique track identifier"""
  id: Float

  """Parent program for this track"""
  programId: Float
}

"""
order by varSamp() on columns of table "track"
"""
input TrackVarSampOrderBy {
  """Unique track identifier"""
  id: OrderBy

  """Parent program for this track"""
  programId: OrderBy
}

"""aggregate variance on columns"""
type TrackVarianceFields {
  """Unique track identifier"""
  id: Float

  """Parent program for this track"""
  programId: Float
}

"""
order by variance() on columns of table "track"
"""
input TrackVarianceOrderBy {
  """Unique track identifier"""
  id: OrderBy

  """Parent program for this track"""
  programId: OrderBy
}

"""
Academic year definitions with current year designation and visibility settings
"""
type Year {
  """Additional information about this academic year"""
  comment: String

  """An array relationship"""
  courses(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): [Course!]!

  """An aggregate relationship"""
  coursesAggregate(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): CourseAggregate!

  """Timestamp when the record was created"""
  createdAt: timestamptz!

  """
  Current academic year flag (TRUE or NULL). Constrained to have at most one current year
  """
  current: Boolean

  """An array relationship"""
  services(
    """distinct select on columns"""
    distinctOn: [ServiceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceOrderBy!]

    """filter the rows returned"""
    where: ServiceBoolExp
  ): [Service!]!

  """An aggregate relationship"""
  servicesAggregate(
    """distinct select on columns"""
    distinctOn: [ServiceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceOrderBy!]

    """filter the rows returned"""
    where: ServiceBoolExp
  ): ServiceAggregate!

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz!

  """Academic year identifier (e.g., 2024 for 2024-2025 academic year)"""
  value: Int!

  """Controls visibility of the year in the user interface and queries"""
  visible: Boolean!
}

"""
aggregated selection of "year"
"""
type YearAggregate {
  aggregate: YearAggregateFields
  nodes: [Year!]!
}

"""
aggregate fields of "year"
"""
type YearAggregateFields {
  avg: YearAvgFields
  count(columns: [YearSelectColumn!], distinct: Boolean): Int!
  max: YearMaxFields
  min: YearMinFields
  stddev: YearStddevFields
  stddevPop: YearStddevPopFields
  stddevSamp: YearStddevSampFields
  sum: YearSumFields
  varPop: YearVarPopFields
  varSamp: YearVarSampFields
  variance: YearVarianceFields
}

"""aggregate avg on columns"""
type YearAvgFields {
  """Academic year identifier (e.g., 2024 for 2024-2025 academic year)"""
  value: Float
}

"""
Boolean expression to filter rows from the table "year". All fields are combined with a logical 'AND'.
"""
input YearBoolExp {
  _and: [YearBoolExp!]
  _not: YearBoolExp
  _or: [YearBoolExp!]
  comment: StringComparisonExp
  courses: CourseBoolExp
  coursesAggregate: CourseAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  current: BooleanComparisonExp
  services: ServiceBoolExp
  servicesAggregate: ServiceAggregateBoolExp
  updatedAt: TimestamptzComparisonExp
  value: IntComparisonExp
  visible: BooleanComparisonExp
}

"""
unique or primary key constraints on table "year"
"""
enum YearConstraint {
  """
  unique or primary key constraint on columns "current"
  """
  year_current_key

  """
  unique or primary key constraint on columns "value"
  """
  year_pkey
}

"""
input type for incrementing numeric columns in table "year"
"""
input YearIncInput {
  """Academic year identifier (e.g., 2024 for 2024-2025 academic year)"""
  value: Int
}

"""
input type for inserting data into table "year"
"""
input YearInsertInput {
  """Additional information about this academic year"""
  comment: String
  courses: CourseArrRelInsertInput

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """
  Current academic year flag (TRUE or NULL). Constrained to have at most one current year
  """
  current: Boolean
  services: ServiceArrRelInsertInput

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Academic year identifier (e.g., 2024 for 2024-2025 academic year)"""
  value: Int

  """Controls visibility of the year in the user interface and queries"""
  visible: Boolean
}

"""aggregate max on columns"""
type YearMaxFields {
  """Additional information about this academic year"""
  comment: String

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Academic year identifier (e.g., 2024 for 2024-2025 academic year)"""
  value: Int
}

"""aggregate min on columns"""
type YearMinFields {
  """Additional information about this academic year"""
  comment: String

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Academic year identifier (e.g., 2024 for 2024-2025 academic year)"""
  value: Int
}

"""
response of any mutation on the table "year"
"""
type YearMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Year!]!
}

"""
input type for inserting object relation for remote table "year"
"""
input YearObjRelInsertInput {
  data: YearInsertInput!

  """upsert condition"""
  onConflict: YearOnConflict
}

"""
on_conflict condition type for table "year"
"""
input YearOnConflict {
  constraint: YearConstraint!
  updateColumns: [YearUpdateColumn!]! = []
  where: YearBoolExp
}

"""Ordering options when selecting data from "year"."""
input YearOrderBy {
  comment: OrderBy
  coursesAggregate: CourseAggregateOrderBy
  createdAt: OrderBy
  current: OrderBy
  servicesAggregate: ServiceAggregateOrderBy
  updatedAt: OrderBy
  value: OrderBy
  visible: OrderBy
}

"""primary key columns input for table: year"""
input YearPkColumnsInput {
  """Academic year identifier (e.g., 2024 for 2024-2025 academic year)"""
  value: Int!
}

"""
select columns of table "year"
"""
enum YearSelectColumn {
  """column name"""
  comment

  """column name"""
  createdAt

  """column name"""
  current

  """column name"""
  updatedAt

  """column name"""
  value

  """column name"""
  visible
}

"""
input type for updating data in table "year"
"""
input YearSetInput {
  """Additional information about this academic year"""
  comment: String

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """
  Current academic year flag (TRUE or NULL). Constrained to have at most one current year
  """
  current: Boolean

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Academic year identifier (e.g., 2024 for 2024-2025 academic year)"""
  value: Int

  """Controls visibility of the year in the user interface and queries"""
  visible: Boolean
}

"""aggregate stddev on columns"""
type YearStddevFields {
  """Academic year identifier (e.g., 2024 for 2024-2025 academic year)"""
  value: Float
}

"""aggregate stddevPop on columns"""
type YearStddevPopFields {
  """Academic year identifier (e.g., 2024 for 2024-2025 academic year)"""
  value: Float
}

"""aggregate stddevSamp on columns"""
type YearStddevSampFields {
  """Academic year identifier (e.g., 2024 for 2024-2025 academic year)"""
  value: Float
}

"""
Streaming cursor of the table "year"
"""
input YearStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: YearStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input YearStreamCursorValueInput {
  """Additional information about this academic year"""
  comment: String

  """Timestamp when the record was created"""
  createdAt: timestamptz

  """
  Current academic year flag (TRUE or NULL). Constrained to have at most one current year
  """
  current: Boolean

  """
  Timestamp when the record was last updated, automatically managed by trigger
  """
  updatedAt: timestamptz

  """Academic year identifier (e.g., 2024 for 2024-2025 academic year)"""
  value: Int

  """Controls visibility of the year in the user interface and queries"""
  visible: Boolean
}

"""aggregate sum on columns"""
type YearSumFields {
  """Academic year identifier (e.g., 2024 for 2024-2025 academic year)"""
  value: Int
}

"""
update columns of table "year"
"""
enum YearUpdateColumn {
  """column name"""
  comment

  """column name"""
  createdAt

  """column name"""
  current

  """column name"""
  updatedAt

  """column name"""
  value

  """column name"""
  visible
}

input YearUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: YearIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: YearSetInput

  """filter the rows which have to be updated"""
  where: YearBoolExp!
}

"""aggregate varPop on columns"""
type YearVarPopFields {
  """Academic year identifier (e.g., 2024 for 2024-2025 academic year)"""
  value: Float
}

"""aggregate varSamp on columns"""
type YearVarSampFields {
  """Academic year identifier (e.g., 2024 for 2024-2025 academic year)"""
  value: Float
}

"""aggregate variance on columns"""
type YearVarianceFields {
  """Academic year identifier (e.g., 2024 for 2024-2025 academic year)"""
  value: Float
}

input coordinationAggregateBoolExpCount {
  arguments: [CoordinationSelectColumn!]
  distinct: Boolean
  filter: CoordinationBoolExp
  predicate: IntComparisonExp!
}

input courseAggregateBoolExpBool_and {
  arguments: CourseSelectColumnCourseAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: CourseBoolExp
  predicate: BooleanComparisonExp!
}

input courseAggregateBoolExpBool_or {
  arguments: CourseSelectColumnCourseAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: CourseBoolExp
  predicate: BooleanComparisonExp!
}

input courseAggregateBoolExpCount {
  arguments: [CourseSelectColumn!]
  distinct: Boolean
  filter: CourseBoolExp
  predicate: IntComparisonExp!
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "app_setting"
  """
  deleteAppSetting(
    """filter the rows which have to be deleted"""
    where: AppSettingBoolExp!
  ): AppSettingMutationResponse

  """
  delete single row from the table: "app_setting"
  """
  deleteAppSettingByPk(
    """Setting identifier"""
    key: String!
  ): AppSetting

  """
  delete data from the table: "coordination"
  """
  deleteCoordination(
    """filter the rows which have to be deleted"""
    where: CoordinationBoolExp!
  ): CoordinationMutationResponse

  """
  delete single row from the table: "coordination"
  """
  deleteCoordinationByPk(
    """Unique coordination identifier"""
    id: Int!
  ): Coordination

  """
  delete data from the table: "course"
  """
  deleteCourse(
    """filter the rows which have to be deleted"""
    where: CourseBoolExp!
  ): CourseMutationResponse

  """
  delete single row from the table: "course"
  """
  deleteCourseByPk(
    """Unique course identifier"""
    id: Int!
  ): Course

  """
  delete data from the table: "course_type"
  """
  deleteCourseType(
    """filter the rows which have to be deleted"""
    where: CourseTypeBoolExp!
  ): CourseTypeMutationResponse

  """
  delete single row from the table: "course_type"
  """
  deleteCourseTypeByPk(
    """Course type identifier (e.g., lecture, tutorial)"""
    value: String!
  ): CourseType

  """
  delete data from the table: "degree"
  """
  deleteDegree(
    """filter the rows which have to be deleted"""
    where: DegreeBoolExp!
  ): DegreeMutationResponse

  """
  delete single row from the table: "degree"
  """
  deleteDegreeByPk(
    """Unique degree identifier"""
    id: Int!
  ): Degree

  """
  delete data from the table: "phase"
  """
  deletePhase(
    """filter the rows which have to be deleted"""
    where: PhaseBoolExp!
  ): PhaseMutationResponse

  """
  delete single row from the table: "phase"
  """
  deletePhaseByPk(
    """Phase identifier"""
    value: String!
  ): Phase

  """
  delete data from the table: "position"
  """
  deletePosition(
    """filter the rows which have to be deleted"""
    where: PositionBoolExp!
  ): PositionMutationResponse

  """
  delete single row from the table: "position"
  """
  deletePositionByPk(
    """Position identifier (e.g., professor, lecturer)"""
    value: String!
  ): Position

  """
  delete data from the table: "priority"
  """
  deletePriority(
    """filter the rows which have to be deleted"""
    where: PriorityBoolExp!
  ): PriorityMutationResponse

  """
  delete single row from the table: "priority"
  """
  deletePriorityByPk(
    """Unique priority record identifier"""
    id: Int!
  ): Priority

  """
  delete data from the table: "program"
  """
  deleteProgram(
    """filter the rows which have to be deleted"""
    where: ProgramBoolExp!
  ): ProgramMutationResponse

  """
  delete single row from the table: "program"
  """
  deleteProgramByPk(
    """Unique program identifier"""
    id: Int!
  ): Program

  """
  delete data from the table: "request"
  """
  deleteRequest(
    """filter the rows which have to be deleted"""
    where: RequestBoolExp!
  ): RequestMutationResponse

  """
  delete single row from the table: "request"
  """
  deleteRequestByPk(
    """Unique request identifier"""
    id: Int!
  ): Request

  """
  delete data from the table: "request_type"
  """
  deleteRequestType(
    """filter the rows which have to be deleted"""
    where: RequestTypeBoolExp!
  ): RequestTypeMutationResponse

  """
  delete single row from the table: "request_type"
  """
  deleteRequestTypeByPk(
    """Request type identifier"""
    value: String!
  ): RequestType

  """
  delete data from the table: "role"
  """
  deleteRole(
    """filter the rows which have to be deleted"""
    where: RoleBoolExp!
  ): RoleMutationResponse

  """
  delete single row from the table: "role"
  """
  deleteRoleByPk(
    """Unique role assignment identifier"""
    id: Int!
  ): Role

  """
  delete data from the table: "role_type"
  """
  deleteRoleType(
    """filter the rows which have to be deleted"""
    where: RoleTypeBoolExp!
  ): RoleTypeMutationResponse

  """
  delete single row from the table: "role_type"
  """
  deleteRoleTypeByPk(
    """Role identifier"""
    value: String!
  ): RoleType

  """
  delete data from the table: "service"
  """
  deleteService(
    """filter the rows which have to be deleted"""
    where: ServiceBoolExp!
  ): ServiceMutationResponse

  """
  delete single row from the table: "service"
  """
  deleteServiceByPk(
    """Unique service identifier"""
    id: Int!
  ): Service

  """
  delete data from the table: "service_modification"
  """
  deleteServiceModification(
    """filter the rows which have to be deleted"""
    where: ServiceModificationBoolExp!
  ): ServiceModificationMutationResponse

  """
  delete single row from the table: "service_modification"
  """
  deleteServiceModificationByPk(
    """Unique modification identifier"""
    id: Int!
  ): ServiceModification

  """
  delete data from the table: "service_modification_type"
  """
  deleteServiceModificationType(
    """filter the rows which have to be deleted"""
    where: ServiceModificationTypeBoolExp!
  ): ServiceModificationTypeMutationResponse

  """
  delete single row from the table: "service_modification_type"
  """
  deleteServiceModificationTypeByPk(
    """Modification type identifier"""
    value: String!
  ): ServiceModificationType

  """
  delete data from the table: "teacher"
  """
  deleteTeacher(
    """filter the rows which have to be deleted"""
    where: TeacherBoolExp!
  ): TeacherMutationResponse

  """
  delete single row from the table: "teacher"
  """
  deleteTeacherByPk(
    """Teacher's email address (primary key)."""
    uid: String!
  ): Teacher

  """
  delete data from the table: "track"
  """
  deleteTrack(
    """filter the rows which have to be deleted"""
    where: TrackBoolExp!
  ): TrackMutationResponse

  """
  delete single row from the table: "track"
  """
  deleteTrackByPk(
    """Unique track identifier"""
    id: Int!
  ): Track

  """
  delete data from the table: "year"
  """
  deleteYear(
    """filter the rows which have to be deleted"""
    where: YearBoolExp!
  ): YearMutationResponse

  """
  delete single row from the table: "year"
  """
  deleteYearByPk(
    """Academic year identifier (e.g., 2024 for 2024-2025 academic year)"""
    value: Int!
  ): Year

  """
  insert data into the table: "app_setting"
  """
  insertAppSetting(
    """the rows to be inserted"""
    objects: [AppSettingInsertInput!]!

    """upsert condition"""
    onConflict: AppSettingOnConflict
  ): AppSettingMutationResponse

  """
  insert a single row into the table: "app_setting"
  """
  insertAppSettingOne(
    """the row to be inserted"""
    object: AppSettingInsertInput!

    """upsert condition"""
    onConflict: AppSettingOnConflict
  ): AppSetting

  """
  insert data into the table: "coordination"
  """
  insertCoordination(
    """the rows to be inserted"""
    objects: [CoordinationInsertInput!]!

    """upsert condition"""
    onConflict: CoordinationOnConflict
  ): CoordinationMutationResponse

  """
  insert a single row into the table: "coordination"
  """
  insertCoordinationOne(
    """the row to be inserted"""
    object: CoordinationInsertInput!

    """upsert condition"""
    onConflict: CoordinationOnConflict
  ): Coordination

  """
  insert data into the table: "course"
  """
  insertCourse(
    """the rows to be inserted"""
    objects: [CourseInsertInput!]!

    """upsert condition"""
    onConflict: CourseOnConflict
  ): CourseMutationResponse

  """
  insert a single row into the table: "course"
  """
  insertCourseOne(
    """the row to be inserted"""
    object: CourseInsertInput!

    """upsert condition"""
    onConflict: CourseOnConflict
  ): Course

  """
  insert data into the table: "course_type"
  """
  insertCourseType(
    """the rows to be inserted"""
    objects: [CourseTypeInsertInput!]!

    """upsert condition"""
    onConflict: CourseTypeOnConflict
  ): CourseTypeMutationResponse

  """
  insert a single row into the table: "course_type"
  """
  insertCourseTypeOne(
    """the row to be inserted"""
    object: CourseTypeInsertInput!

    """upsert condition"""
    onConflict: CourseTypeOnConflict
  ): CourseType

  """
  insert data into the table: "degree"
  """
  insertDegree(
    """the rows to be inserted"""
    objects: [DegreeInsertInput!]!

    """upsert condition"""
    onConflict: DegreeOnConflict
  ): DegreeMutationResponse

  """
  insert a single row into the table: "degree"
  """
  insertDegreeOne(
    """the row to be inserted"""
    object: DegreeInsertInput!

    """upsert condition"""
    onConflict: DegreeOnConflict
  ): Degree

  """
  insert data into the table: "phase"
  """
  insertPhase(
    """the rows to be inserted"""
    objects: [PhaseInsertInput!]!

    """upsert condition"""
    onConflict: PhaseOnConflict
  ): PhaseMutationResponse

  """
  insert a single row into the table: "phase"
  """
  insertPhaseOne(
    """the row to be inserted"""
    object: PhaseInsertInput!

    """upsert condition"""
    onConflict: PhaseOnConflict
  ): Phase

  """
  insert data into the table: "position"
  """
  insertPosition(
    """the rows to be inserted"""
    objects: [PositionInsertInput!]!

    """upsert condition"""
    onConflict: PositionOnConflict
  ): PositionMutationResponse

  """
  insert a single row into the table: "position"
  """
  insertPositionOne(
    """the row to be inserted"""
    object: PositionInsertInput!

    """upsert condition"""
    onConflict: PositionOnConflict
  ): Position

  """
  insert data into the table: "priority"
  """
  insertPriority(
    """the rows to be inserted"""
    objects: [PriorityInsertInput!]!

    """upsert condition"""
    onConflict: PriorityOnConflict
  ): PriorityMutationResponse

  """
  insert a single row into the table: "priority"
  """
  insertPriorityOne(
    """the row to be inserted"""
    object: PriorityInsertInput!

    """upsert condition"""
    onConflict: PriorityOnConflict
  ): Priority

  """
  insert data into the table: "program"
  """
  insertProgram(
    """the rows to be inserted"""
    objects: [ProgramInsertInput!]!

    """upsert condition"""
    onConflict: ProgramOnConflict
  ): ProgramMutationResponse

  """
  insert a single row into the table: "program"
  """
  insertProgramOne(
    """the row to be inserted"""
    object: ProgramInsertInput!

    """upsert condition"""
    onConflict: ProgramOnConflict
  ): Program

  """
  insert data into the table: "request"
  """
  insertRequest(
    """the rows to be inserted"""
    objects: [RequestInsertInput!]!

    """upsert condition"""
    onConflict: RequestOnConflict
  ): RequestMutationResponse

  """
  insert a single row into the table: "request"
  """
  insertRequestOne(
    """the row to be inserted"""
    object: RequestInsertInput!

    """upsert condition"""
    onConflict: RequestOnConflict
  ): Request

  """
  insert data into the table: "request_type"
  """
  insertRequestType(
    """the rows to be inserted"""
    objects: [RequestTypeInsertInput!]!

    """upsert condition"""
    onConflict: RequestTypeOnConflict
  ): RequestTypeMutationResponse

  """
  insert a single row into the table: "request_type"
  """
  insertRequestTypeOne(
    """the row to be inserted"""
    object: RequestTypeInsertInput!

    """upsert condition"""
    onConflict: RequestTypeOnConflict
  ): RequestType

  """
  insert data into the table: "role"
  """
  insertRole(
    """the rows to be inserted"""
    objects: [RoleInsertInput!]!

    """upsert condition"""
    onConflict: RoleOnConflict
  ): RoleMutationResponse

  """
  insert a single row into the table: "role"
  """
  insertRoleOne(
    """the row to be inserted"""
    object: RoleInsertInput!

    """upsert condition"""
    onConflict: RoleOnConflict
  ): Role

  """
  insert data into the table: "role_type"
  """
  insertRoleType(
    """the rows to be inserted"""
    objects: [RoleTypeInsertInput!]!

    """upsert condition"""
    onConflict: RoleTypeOnConflict
  ): RoleTypeMutationResponse

  """
  insert a single row into the table: "role_type"
  """
  insertRoleTypeOne(
    """the row to be inserted"""
    object: RoleTypeInsertInput!

    """upsert condition"""
    onConflict: RoleTypeOnConflict
  ): RoleType

  """
  insert data into the table: "service"
  """
  insertService(
    """the rows to be inserted"""
    objects: [ServiceInsertInput!]!

    """upsert condition"""
    onConflict: ServiceOnConflict
  ): ServiceMutationResponse

  """
  insert data into the table: "service_modification"
  """
  insertServiceModification(
    """the rows to be inserted"""
    objects: [ServiceModificationInsertInput!]!

    """upsert condition"""
    onConflict: ServiceModificationOnConflict
  ): ServiceModificationMutationResponse

  """
  insert a single row into the table: "service_modification"
  """
  insertServiceModificationOne(
    """the row to be inserted"""
    object: ServiceModificationInsertInput!

    """upsert condition"""
    onConflict: ServiceModificationOnConflict
  ): ServiceModification

  """
  insert data into the table: "service_modification_type"
  """
  insertServiceModificationType(
    """the rows to be inserted"""
    objects: [ServiceModificationTypeInsertInput!]!

    """upsert condition"""
    onConflict: ServiceModificationTypeOnConflict
  ): ServiceModificationTypeMutationResponse

  """
  insert a single row into the table: "service_modification_type"
  """
  insertServiceModificationTypeOne(
    """the row to be inserted"""
    object: ServiceModificationTypeInsertInput!

    """upsert condition"""
    onConflict: ServiceModificationTypeOnConflict
  ): ServiceModificationType

  """
  insert a single row into the table: "service"
  """
  insertServiceOne(
    """the row to be inserted"""
    object: ServiceInsertInput!

    """upsert condition"""
    onConflict: ServiceOnConflict
  ): Service

  """
  insert data into the table: "teacher"
  """
  insertTeacher(
    """the rows to be inserted"""
    objects: [TeacherInsertInput!]!

    """upsert condition"""
    onConflict: TeacherOnConflict
  ): TeacherMutationResponse

  """
  insert a single row into the table: "teacher"
  """
  insertTeacherOne(
    """the row to be inserted"""
    object: TeacherInsertInput!

    """upsert condition"""
    onConflict: TeacherOnConflict
  ): Teacher

  """
  insert data into the table: "track"
  """
  insertTrack(
    """the rows to be inserted"""
    objects: [TrackInsertInput!]!

    """upsert condition"""
    onConflict: TrackOnConflict
  ): TrackMutationResponse

  """
  insert a single row into the table: "track"
  """
  insertTrackOne(
    """the row to be inserted"""
    object: TrackInsertInput!

    """upsert condition"""
    onConflict: TrackOnConflict
  ): Track

  """
  insert data into the table: "year"
  """
  insertYear(
    """the rows to be inserted"""
    objects: [YearInsertInput!]!

    """upsert condition"""
    onConflict: YearOnConflict
  ): YearMutationResponse

  """
  insert a single row into the table: "year"
  """
  insertYearOne(
    """the row to be inserted"""
    object: YearInsertInput!

    """upsert condition"""
    onConflict: YearOnConflict
  ): Year

  """
  update data of the table: "app_setting"
  """
  updateAppSetting(
    """sets the columns of the filtered rows to the given values"""
    _set: AppSettingSetInput

    """filter the rows which have to be updated"""
    where: AppSettingBoolExp!
  ): AppSettingMutationResponse

  """
  update single row of the table: "app_setting"
  """
  updateAppSettingByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: AppSettingSetInput
    pkColumns: AppSettingPkColumnsInput!
  ): AppSetting

  """
  update multiples rows of table: "app_setting"
  """
  updateAppSettingMany(
    """updates to execute, in order"""
    updates: [AppSettingUpdates!]!
  ): [AppSettingMutationResponse]

  """
  update data of the table: "coordination"
  """
  updateCoordination(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CoordinationIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: CoordinationSetInput

    """filter the rows which have to be updated"""
    where: CoordinationBoolExp!
  ): CoordinationMutationResponse

  """
  update single row of the table: "coordination"
  """
  updateCoordinationByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CoordinationIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: CoordinationSetInput
    pkColumns: CoordinationPkColumnsInput!
  ): Coordination

  """
  update multiples rows of table: "coordination"
  """
  updateCoordinationMany(
    """updates to execute, in order"""
    updates: [CoordinationUpdates!]!
  ): [CoordinationMutationResponse]

  """
  update data of the table: "course"
  """
  updateCourse(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CourseIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: CourseSetInput

    """filter the rows which have to be updated"""
    where: CourseBoolExp!
  ): CourseMutationResponse

  """
  update single row of the table: "course"
  """
  updateCourseByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CourseIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: CourseSetInput
    pkColumns: CoursePkColumnsInput!
  ): Course

  """
  update multiples rows of table: "course"
  """
  updateCourseMany(
    """updates to execute, in order"""
    updates: [CourseUpdates!]!
  ): [CourseMutationResponse]

  """
  update data of the table: "course_type"
  """
  updateCourseType(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CourseTypeIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: CourseTypeSetInput

    """filter the rows which have to be updated"""
    where: CourseTypeBoolExp!
  ): CourseTypeMutationResponse

  """
  update single row of the table: "course_type"
  """
  updateCourseTypeByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CourseTypeIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: CourseTypeSetInput
    pkColumns: CourseTypePkColumnsInput!
  ): CourseType

  """
  update multiples rows of table: "course_type"
  """
  updateCourseTypeMany(
    """updates to execute, in order"""
    updates: [CourseTypeUpdates!]!
  ): [CourseTypeMutationResponse]

  """
  update data of the table: "degree"
  """
  updateDegree(
    """increments the numeric columns with given value of the filtered values"""
    _inc: DegreeIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: DegreeSetInput

    """filter the rows which have to be updated"""
    where: DegreeBoolExp!
  ): DegreeMutationResponse

  """
  update single row of the table: "degree"
  """
  updateDegreeByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: DegreeIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: DegreeSetInput
    pkColumns: DegreePkColumnsInput!
  ): Degree

  """
  update multiples rows of table: "degree"
  """
  updateDegreeMany(
    """updates to execute, in order"""
    updates: [DegreeUpdates!]!
  ): [DegreeMutationResponse]

  """
  update data of the table: "phase"
  """
  updatePhase(
    """sets the columns of the filtered rows to the given values"""
    _set: PhaseSetInput

    """filter the rows which have to be updated"""
    where: PhaseBoolExp!
  ): PhaseMutationResponse

  """
  update single row of the table: "phase"
  """
  updatePhaseByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: PhaseSetInput
    pkColumns: PhasePkColumnsInput!
  ): Phase

  """
  update multiples rows of table: "phase"
  """
  updatePhaseMany(
    """updates to execute, in order"""
    updates: [PhaseUpdates!]!
  ): [PhaseMutationResponse]

  """
  update data of the table: "position"
  """
  updatePosition(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PositionIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: PositionSetInput

    """filter the rows which have to be updated"""
    where: PositionBoolExp!
  ): PositionMutationResponse

  """
  update single row of the table: "position"
  """
  updatePositionByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PositionIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: PositionSetInput
    pkColumns: PositionPkColumnsInput!
  ): Position

  """
  update multiples rows of table: "position"
  """
  updatePositionMany(
    """updates to execute, in order"""
    updates: [PositionUpdates!]!
  ): [PositionMutationResponse]

  """
  update data of the table: "priority"
  """
  updatePriority(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PriorityIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: PrioritySetInput

    """filter the rows which have to be updated"""
    where: PriorityBoolExp!
  ): PriorityMutationResponse

  """
  update single row of the table: "priority"
  """
  updatePriorityByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PriorityIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: PrioritySetInput
    pkColumns: PriorityPkColumnsInput!
  ): Priority

  """
  update multiples rows of table: "priority"
  """
  updatePriorityMany(
    """updates to execute, in order"""
    updates: [PriorityUpdates!]!
  ): [PriorityMutationResponse]

  """
  update data of the table: "program"
  """
  updateProgram(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ProgramIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ProgramSetInput

    """filter the rows which have to be updated"""
    where: ProgramBoolExp!
  ): ProgramMutationResponse

  """
  update single row of the table: "program"
  """
  updateProgramByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ProgramIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ProgramSetInput
    pkColumns: ProgramPkColumnsInput!
  ): Program

  """
  update multiples rows of table: "program"
  """
  updateProgramMany(
    """updates to execute, in order"""
    updates: [ProgramUpdates!]!
  ): [ProgramMutationResponse]

  """
  update data of the table: "request"
  """
  updateRequest(
    """increments the numeric columns with given value of the filtered values"""
    _inc: RequestIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: RequestSetInput

    """filter the rows which have to be updated"""
    where: RequestBoolExp!
  ): RequestMutationResponse

  """
  update single row of the table: "request"
  """
  updateRequestByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: RequestIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: RequestSetInput
    pkColumns: RequestPkColumnsInput!
  ): Request

  """
  update multiples rows of table: "request"
  """
  updateRequestMany(
    """updates to execute, in order"""
    updates: [RequestUpdates!]!
  ): [RequestMutationResponse]

  """
  update data of the table: "request_type"
  """
  updateRequestType(
    """sets the columns of the filtered rows to the given values"""
    _set: RequestTypeSetInput

    """filter the rows which have to be updated"""
    where: RequestTypeBoolExp!
  ): RequestTypeMutationResponse

  """
  update single row of the table: "request_type"
  """
  updateRequestTypeByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: RequestTypeSetInput
    pkColumns: RequestTypePkColumnsInput!
  ): RequestType

  """
  update multiples rows of table: "request_type"
  """
  updateRequestTypeMany(
    """updates to execute, in order"""
    updates: [RequestTypeUpdates!]!
  ): [RequestTypeMutationResponse]

  """
  update data of the table: "role"
  """
  updateRole(
    """increments the numeric columns with given value of the filtered values"""
    _inc: RoleIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: RoleSetInput

    """filter the rows which have to be updated"""
    where: RoleBoolExp!
  ): RoleMutationResponse

  """
  update single row of the table: "role"
  """
  updateRoleByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: RoleIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: RoleSetInput
    pkColumns: RolePkColumnsInput!
  ): Role

  """
  update multiples rows of table: "role"
  """
  updateRoleMany(
    """updates to execute, in order"""
    updates: [RoleUpdates!]!
  ): [RoleMutationResponse]

  """
  update data of the table: "role_type"
  """
  updateRoleType(
    """sets the columns of the filtered rows to the given values"""
    _set: RoleTypeSetInput

    """filter the rows which have to be updated"""
    where: RoleTypeBoolExp!
  ): RoleTypeMutationResponse

  """
  update single row of the table: "role_type"
  """
  updateRoleTypeByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: RoleTypeSetInput
    pkColumns: RoleTypePkColumnsInput!
  ): RoleType

  """
  update multiples rows of table: "role_type"
  """
  updateRoleTypeMany(
    """updates to execute, in order"""
    updates: [RoleTypeUpdates!]!
  ): [RoleTypeMutationResponse]

  """
  update data of the table: "service"
  """
  updateService(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ServiceIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ServiceSetInput

    """filter the rows which have to be updated"""
    where: ServiceBoolExp!
  ): ServiceMutationResponse

  """
  update single row of the table: "service"
  """
  updateServiceByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ServiceIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ServiceSetInput
    pkColumns: ServicePkColumnsInput!
  ): Service

  """
  update multiples rows of table: "service"
  """
  updateServiceMany(
    """updates to execute, in order"""
    updates: [ServiceUpdates!]!
  ): [ServiceMutationResponse]

  """
  update data of the table: "service_modification"
  """
  updateServiceModification(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ServiceModificationIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ServiceModificationSetInput

    """filter the rows which have to be updated"""
    where: ServiceModificationBoolExp!
  ): ServiceModificationMutationResponse

  """
  update single row of the table: "service_modification"
  """
  updateServiceModificationByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ServiceModificationIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ServiceModificationSetInput
    pkColumns: ServiceModificationPkColumnsInput!
  ): ServiceModification

  """
  update multiples rows of table: "service_modification"
  """
  updateServiceModificationMany(
    """updates to execute, in order"""
    updates: [ServiceModificationUpdates!]!
  ): [ServiceModificationMutationResponse]

  """
  update data of the table: "service_modification_type"
  """
  updateServiceModificationType(
    """sets the columns of the filtered rows to the given values"""
    _set: ServiceModificationTypeSetInput

    """filter the rows which have to be updated"""
    where: ServiceModificationTypeBoolExp!
  ): ServiceModificationTypeMutationResponse

  """
  update single row of the table: "service_modification_type"
  """
  updateServiceModificationTypeByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: ServiceModificationTypeSetInput
    pkColumns: ServiceModificationTypePkColumnsInput!
  ): ServiceModificationType

  """
  update multiples rows of table: "service_modification_type"
  """
  updateServiceModificationTypeMany(
    """updates to execute, in order"""
    updates: [ServiceModificationTypeUpdates!]!
  ): [ServiceModificationTypeMutationResponse]

  """
  update data of the table: "teacher"
  """
  updateTeacher(
    """increments the numeric columns with given value of the filtered values"""
    _inc: TeacherIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: TeacherSetInput

    """filter the rows which have to be updated"""
    where: TeacherBoolExp!
  ): TeacherMutationResponse

  """
  update single row of the table: "teacher"
  """
  updateTeacherByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: TeacherIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: TeacherSetInput
    pkColumns: TeacherPkColumnsInput!
  ): Teacher

  """
  update multiples rows of table: "teacher"
  """
  updateTeacherMany(
    """updates to execute, in order"""
    updates: [TeacherUpdates!]!
  ): [TeacherMutationResponse]

  """
  update data of the table: "track"
  """
  updateTrack(
    """increments the numeric columns with given value of the filtered values"""
    _inc: TrackIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: TrackSetInput

    """filter the rows which have to be updated"""
    where: TrackBoolExp!
  ): TrackMutationResponse

  """
  update single row of the table: "track"
  """
  updateTrackByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: TrackIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: TrackSetInput
    pkColumns: TrackPkColumnsInput!
  ): Track

  """
  update multiples rows of table: "track"
  """
  updateTrackMany(
    """updates to execute, in order"""
    updates: [TrackUpdates!]!
  ): [TrackMutationResponse]

  """
  update data of the table: "year"
  """
  updateYear(
    """increments the numeric columns with given value of the filtered values"""
    _inc: YearIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: YearSetInput

    """filter the rows which have to be updated"""
    where: YearBoolExp!
  ): YearMutationResponse

  """
  update single row of the table: "year"
  """
  updateYearByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: YearIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: YearSetInput
    pkColumns: YearPkColumnsInput!
  ): Year

  """
  update multiples rows of table: "year"
  """
  updateYearMany(
    """updates to execute, in order"""
    updates: [YearUpdates!]!
  ): [YearMutationResponse]
}

input priorityAggregateBoolExpBool_and {
  arguments: PrioritySelectColumnPriorityAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: PriorityBoolExp
  predicate: BooleanComparisonExp!
}

input priorityAggregateBoolExpBool_or {
  arguments: PrioritySelectColumnPriorityAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: PriorityBoolExp
  predicate: BooleanComparisonExp!
}

input priorityAggregateBoolExpCount {
  arguments: [PrioritySelectColumn!]
  distinct: Boolean
  filter: PriorityBoolExp
  predicate: IntComparisonExp!
}

input programAggregateBoolExpBool_and {
  arguments: ProgramSelectColumnProgramAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: ProgramBoolExp
  predicate: BooleanComparisonExp!
}

input programAggregateBoolExpBool_or {
  arguments: ProgramSelectColumnProgramAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: ProgramBoolExp
  predicate: BooleanComparisonExp!
}

input programAggregateBoolExpCount {
  arguments: [ProgramSelectColumn!]
  distinct: Boolean
  filter: ProgramBoolExp
  predicate: IntComparisonExp!
}

type query_root {
  """
  fetch data from the table: "app_setting"
  """
  appSetting(
    """distinct select on columns"""
    distinctOn: [AppSettingSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AppSettingOrderBy!]

    """filter the rows returned"""
    where: AppSettingBoolExp
  ): [AppSetting!]!

  """
  fetch aggregated fields from the table: "app_setting"
  """
  appSettingAggregate(
    """distinct select on columns"""
    distinctOn: [AppSettingSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AppSettingOrderBy!]

    """filter the rows returned"""
    where: AppSettingBoolExp
  ): AppSettingAggregate!

  """fetch data from the table: "app_setting" using primary key columns"""
  appSettingByPk(
    """Setting identifier"""
    key: String!
  ): AppSetting

  """
  fetch data from the table: "coordination"
  """
  coordination(
    """distinct select on columns"""
    distinctOn: [CoordinationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CoordinationOrderBy!]

    """filter the rows returned"""
    where: CoordinationBoolExp
  ): [Coordination!]!

  """
  fetch aggregated fields from the table: "coordination"
  """
  coordinationAggregate(
    """distinct select on columns"""
    distinctOn: [CoordinationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CoordinationOrderBy!]

    """filter the rows returned"""
    where: CoordinationBoolExp
  ): CoordinationAggregate!

  """fetch data from the table: "coordination" using primary key columns"""
  coordinationByPk(
    """Unique coordination identifier"""
    id: Int!
  ): Coordination

  """
  fetch data from the table: "course"
  """
  course(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): [Course!]!

  """
  fetch aggregated fields from the table: "course"
  """
  courseAggregate(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): CourseAggregate!

  """fetch data from the table: "course" using primary key columns"""
  courseByPk(
    """Unique course identifier"""
    id: Int!
  ): Course

  """
  fetch data from the table: "course_type"
  """
  courseType(
    """distinct select on columns"""
    distinctOn: [CourseTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseTypeOrderBy!]

    """filter the rows returned"""
    where: CourseTypeBoolExp
  ): [CourseType!]!

  """
  fetch aggregated fields from the table: "course_type"
  """
  courseTypeAggregate(
    """distinct select on columns"""
    distinctOn: [CourseTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseTypeOrderBy!]

    """filter the rows returned"""
    where: CourseTypeBoolExp
  ): CourseTypeAggregate!

  """fetch data from the table: "course_type" using primary key columns"""
  courseTypeByPk(
    """Course type identifier (e.g., lecture, tutorial)"""
    value: String!
  ): CourseType

  """
  fetch data from the table: "degree"
  """
  degree(
    """distinct select on columns"""
    distinctOn: [DegreeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DegreeOrderBy!]

    """filter the rows returned"""
    where: DegreeBoolExp
  ): [Degree!]!

  """
  fetch aggregated fields from the table: "degree"
  """
  degreeAggregate(
    """distinct select on columns"""
    distinctOn: [DegreeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DegreeOrderBy!]

    """filter the rows returned"""
    where: DegreeBoolExp
  ): DegreeAggregate!

  """fetch data from the table: "degree" using primary key columns"""
  degreeByPk(
    """Unique degree identifier"""
    id: Int!
  ): Degree

  """
  fetch data from the table: "phase"
  """
  phase(
    """distinct select on columns"""
    distinctOn: [PhaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PhaseOrderBy!]

    """filter the rows returned"""
    where: PhaseBoolExp
  ): [Phase!]!

  """
  fetch aggregated fields from the table: "phase"
  """
  phaseAggregate(
    """distinct select on columns"""
    distinctOn: [PhaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PhaseOrderBy!]

    """filter the rows returned"""
    where: PhaseBoolExp
  ): PhaseAggregate!

  """fetch data from the table: "phase" using primary key columns"""
  phaseByPk(
    """Phase identifier"""
    value: String!
  ): Phase

  """
  fetch data from the table: "position"
  """
  position(
    """distinct select on columns"""
    distinctOn: [PositionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PositionOrderBy!]

    """filter the rows returned"""
    where: PositionBoolExp
  ): [Position!]!

  """
  fetch aggregated fields from the table: "position"
  """
  positionAggregate(
    """distinct select on columns"""
    distinctOn: [PositionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PositionOrderBy!]

    """filter the rows returned"""
    where: PositionBoolExp
  ): PositionAggregate!

  """fetch data from the table: "position" using primary key columns"""
  positionByPk(
    """Position identifier (e.g., professor, lecturer)"""
    value: String!
  ): Position

  """
  fetch data from the table: "priority"
  """
  priority(
    """distinct select on columns"""
    distinctOn: [PrioritySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PriorityOrderBy!]

    """filter the rows returned"""
    where: PriorityBoolExp
  ): [Priority!]!

  """
  fetch aggregated fields from the table: "priority"
  """
  priorityAggregate(
    """distinct select on columns"""
    distinctOn: [PrioritySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PriorityOrderBy!]

    """filter the rows returned"""
    where: PriorityBoolExp
  ): PriorityAggregate!

  """fetch data from the table: "priority" using primary key columns"""
  priorityByPk(
    """Unique priority record identifier"""
    id: Int!
  ): Priority

  """
  fetch data from the table: "program"
  """
  program(
    """distinct select on columns"""
    distinctOn: [ProgramSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProgramOrderBy!]

    """filter the rows returned"""
    where: ProgramBoolExp
  ): [Program!]!

  """
  fetch aggregated fields from the table: "program"
  """
  programAggregate(
    """distinct select on columns"""
    distinctOn: [ProgramSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProgramOrderBy!]

    """filter the rows returned"""
    where: ProgramBoolExp
  ): ProgramAggregate!

  """fetch data from the table: "program" using primary key columns"""
  programByPk(
    """Unique program identifier"""
    id: Int!
  ): Program

  """
  fetch data from the table: "request"
  """
  request(
    """distinct select on columns"""
    distinctOn: [RequestSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RequestOrderBy!]

    """filter the rows returned"""
    where: RequestBoolExp
  ): [Request!]!

  """
  fetch aggregated fields from the table: "request"
  """
  requestAggregate(
    """distinct select on columns"""
    distinctOn: [RequestSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RequestOrderBy!]

    """filter the rows returned"""
    where: RequestBoolExp
  ): RequestAggregate!

  """fetch data from the table: "request" using primary key columns"""
  requestByPk(
    """Unique request identifier"""
    id: Int!
  ): Request

  """
  fetch data from the table: "request_type"
  """
  requestType(
    """distinct select on columns"""
    distinctOn: [RequestTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RequestTypeOrderBy!]

    """filter the rows returned"""
    where: RequestTypeBoolExp
  ): [RequestType!]!

  """
  fetch aggregated fields from the table: "request_type"
  """
  requestTypeAggregate(
    """distinct select on columns"""
    distinctOn: [RequestTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RequestTypeOrderBy!]

    """filter the rows returned"""
    where: RequestTypeBoolExp
  ): RequestTypeAggregate!

  """fetch data from the table: "request_type" using primary key columns"""
  requestTypeByPk(
    """Request type identifier"""
    value: String!
  ): RequestType

  """
  fetch data from the table: "role"
  """
  role(
    """distinct select on columns"""
    distinctOn: [RoleSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RoleOrderBy!]

    """filter the rows returned"""
    where: RoleBoolExp
  ): [Role!]!

  """
  fetch aggregated fields from the table: "role"
  """
  roleAggregate(
    """distinct select on columns"""
    distinctOn: [RoleSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RoleOrderBy!]

    """filter the rows returned"""
    where: RoleBoolExp
  ): RoleAggregate!

  """fetch data from the table: "role" using primary key columns"""
  roleByPk(
    """Unique role assignment identifier"""
    id: Int!
  ): Role

  """
  fetch data from the table: "role_type"
  """
  roleType(
    """distinct select on columns"""
    distinctOn: [RoleTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RoleTypeOrderBy!]

    """filter the rows returned"""
    where: RoleTypeBoolExp
  ): [RoleType!]!

  """
  fetch aggregated fields from the table: "role_type"
  """
  roleTypeAggregate(
    """distinct select on columns"""
    distinctOn: [RoleTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RoleTypeOrderBy!]

    """filter the rows returned"""
    where: RoleTypeBoolExp
  ): RoleTypeAggregate!

  """fetch data from the table: "role_type" using primary key columns"""
  roleTypeByPk(
    """Role identifier"""
    value: String!
  ): RoleType

  """
  fetch data from the table: "service"
  """
  service(
    """distinct select on columns"""
    distinctOn: [ServiceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceOrderBy!]

    """filter the rows returned"""
    where: ServiceBoolExp
  ): [Service!]!

  """
  fetch aggregated fields from the table: "service"
  """
  serviceAggregate(
    """distinct select on columns"""
    distinctOn: [ServiceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceOrderBy!]

    """filter the rows returned"""
    where: ServiceBoolExp
  ): ServiceAggregate!

  """fetch data from the table: "service" using primary key columns"""
  serviceByPk(
    """Unique service identifier"""
    id: Int!
  ): Service

  """
  fetch data from the table: "service_modification"
  """
  serviceModification(
    """distinct select on columns"""
    distinctOn: [ServiceModificationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceModificationOrderBy!]

    """filter the rows returned"""
    where: ServiceModificationBoolExp
  ): [ServiceModification!]!

  """
  fetch aggregated fields from the table: "service_modification"
  """
  serviceModificationAggregate(
    """distinct select on columns"""
    distinctOn: [ServiceModificationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceModificationOrderBy!]

    """filter the rows returned"""
    where: ServiceModificationBoolExp
  ): ServiceModificationAggregate!

  """
  fetch data from the table: "service_modification" using primary key columns
  """
  serviceModificationByPk(
    """Unique modification identifier"""
    id: Int!
  ): ServiceModification

  """
  fetch data from the table: "service_modification_type"
  """
  serviceModificationType(
    """distinct select on columns"""
    distinctOn: [ServiceModificationTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceModificationTypeOrderBy!]

    """filter the rows returned"""
    where: ServiceModificationTypeBoolExp
  ): [ServiceModificationType!]!

  """
  fetch aggregated fields from the table: "service_modification_type"
  """
  serviceModificationTypeAggregate(
    """distinct select on columns"""
    distinctOn: [ServiceModificationTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceModificationTypeOrderBy!]

    """filter the rows returned"""
    where: ServiceModificationTypeBoolExp
  ): ServiceModificationTypeAggregate!

  """
  fetch data from the table: "service_modification_type" using primary key columns
  """
  serviceModificationTypeByPk(
    """Modification type identifier"""
    value: String!
  ): ServiceModificationType

  """
  fetch data from the table: "teacher"
  """
  teacher(
    """distinct select on columns"""
    distinctOn: [TeacherSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TeacherOrderBy!]

    """filter the rows returned"""
    where: TeacherBoolExp
  ): [Teacher!]!

  """
  fetch aggregated fields from the table: "teacher"
  """
  teacherAggregate(
    """distinct select on columns"""
    distinctOn: [TeacherSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TeacherOrderBy!]

    """filter the rows returned"""
    where: TeacherBoolExp
  ): TeacherAggregate!

  """fetch data from the table: "teacher" using primary key columns"""
  teacherByPk(
    """Teacher's email address (primary key)."""
    uid: String!
  ): Teacher

  """
  fetch data from the table: "track"
  """
  track(
    """distinct select on columns"""
    distinctOn: [TrackSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TrackOrderBy!]

    """filter the rows returned"""
    where: TrackBoolExp
  ): [Track!]!

  """
  fetch aggregated fields from the table: "track"
  """
  trackAggregate(
    """distinct select on columns"""
    distinctOn: [TrackSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TrackOrderBy!]

    """filter the rows returned"""
    where: TrackBoolExp
  ): TrackAggregate!

  """fetch data from the table: "track" using primary key columns"""
  trackByPk(
    """Unique track identifier"""
    id: Int!
  ): Track

  """
  fetch data from the table: "year"
  """
  year(
    """distinct select on columns"""
    distinctOn: [YearSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [YearOrderBy!]

    """filter the rows returned"""
    where: YearBoolExp
  ): [Year!]!

  """
  fetch aggregated fields from the table: "year"
  """
  yearAggregate(
    """distinct select on columns"""
    distinctOn: [YearSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [YearOrderBy!]

    """filter the rows returned"""
    where: YearBoolExp
  ): YearAggregate!

  """fetch data from the table: "year" using primary key columns"""
  yearByPk(
    """Academic year identifier (e.g., 2024 for 2024-2025 academic year)"""
    value: Int!
  ): Year
}

input requestAggregateBoolExpCount {
  arguments: [RequestSelectColumn!]
  distinct: Boolean
  filter: RequestBoolExp
  predicate: IntComparisonExp!
}

input roleAggregateBoolExpCount {
  arguments: [RoleSelectColumn!]
  distinct: Boolean
  filter: RoleBoolExp
  predicate: IntComparisonExp!
}

input serviceAggregateBoolExpCount {
  arguments: [ServiceSelectColumn!]
  distinct: Boolean
  filter: ServiceBoolExp
  predicate: IntComparisonExp!
}

input serviceModificationAggregateBoolExpCount {
  arguments: [ServiceModificationSelectColumn!]
  distinct: Boolean
  filter: ServiceModificationBoolExp
  predicate: IntComparisonExp!
}

type subscription_root {
  """
  fetch data from the table: "app_setting"
  """
  appSetting(
    """distinct select on columns"""
    distinctOn: [AppSettingSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AppSettingOrderBy!]

    """filter the rows returned"""
    where: AppSettingBoolExp
  ): [AppSetting!]!

  """
  fetch aggregated fields from the table: "app_setting"
  """
  appSettingAggregate(
    """distinct select on columns"""
    distinctOn: [AppSettingSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AppSettingOrderBy!]

    """filter the rows returned"""
    where: AppSettingBoolExp
  ): AppSettingAggregate!

  """fetch data from the table: "app_setting" using primary key columns"""
  appSettingByPk(
    """Setting identifier"""
    key: String!
  ): AppSetting

  """
  fetch data from the table in a streaming manner: "app_setting"
  """
  appSettingStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [AppSettingStreamCursorInput]!

    """filter the rows returned"""
    where: AppSettingBoolExp
  ): [AppSetting!]!

  """
  fetch data from the table: "coordination"
  """
  coordination(
    """distinct select on columns"""
    distinctOn: [CoordinationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CoordinationOrderBy!]

    """filter the rows returned"""
    where: CoordinationBoolExp
  ): [Coordination!]!

  """
  fetch aggregated fields from the table: "coordination"
  """
  coordinationAggregate(
    """distinct select on columns"""
    distinctOn: [CoordinationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CoordinationOrderBy!]

    """filter the rows returned"""
    where: CoordinationBoolExp
  ): CoordinationAggregate!

  """fetch data from the table: "coordination" using primary key columns"""
  coordinationByPk(
    """Unique coordination identifier"""
    id: Int!
  ): Coordination

  """
  fetch data from the table in a streaming manner: "coordination"
  """
  coordinationStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CoordinationStreamCursorInput]!

    """filter the rows returned"""
    where: CoordinationBoolExp
  ): [Coordination!]!

  """
  fetch data from the table: "course"
  """
  course(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): [Course!]!

  """
  fetch aggregated fields from the table: "course"
  """
  courseAggregate(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): CourseAggregate!

  """fetch data from the table: "course" using primary key columns"""
  courseByPk(
    """Unique course identifier"""
    id: Int!
  ): Course

  """
  fetch data from the table in a streaming manner: "course"
  """
  courseStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CourseStreamCursorInput]!

    """filter the rows returned"""
    where: CourseBoolExp
  ): [Course!]!

  """
  fetch data from the table: "course_type"
  """
  courseType(
    """distinct select on columns"""
    distinctOn: [CourseTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseTypeOrderBy!]

    """filter the rows returned"""
    where: CourseTypeBoolExp
  ): [CourseType!]!

  """
  fetch aggregated fields from the table: "course_type"
  """
  courseTypeAggregate(
    """distinct select on columns"""
    distinctOn: [CourseTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseTypeOrderBy!]

    """filter the rows returned"""
    where: CourseTypeBoolExp
  ): CourseTypeAggregate!

  """fetch data from the table: "course_type" using primary key columns"""
  courseTypeByPk(
    """Course type identifier (e.g., lecture, tutorial)"""
    value: String!
  ): CourseType

  """
  fetch data from the table in a streaming manner: "course_type"
  """
  courseTypeStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CourseTypeStreamCursorInput]!

    """filter the rows returned"""
    where: CourseTypeBoolExp
  ): [CourseType!]!

  """
  fetch data from the table: "degree"
  """
  degree(
    """distinct select on columns"""
    distinctOn: [DegreeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DegreeOrderBy!]

    """filter the rows returned"""
    where: DegreeBoolExp
  ): [Degree!]!

  """
  fetch aggregated fields from the table: "degree"
  """
  degreeAggregate(
    """distinct select on columns"""
    distinctOn: [DegreeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DegreeOrderBy!]

    """filter the rows returned"""
    where: DegreeBoolExp
  ): DegreeAggregate!

  """fetch data from the table: "degree" using primary key columns"""
  degreeByPk(
    """Unique degree identifier"""
    id: Int!
  ): Degree

  """
  fetch data from the table in a streaming manner: "degree"
  """
  degreeStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [DegreeStreamCursorInput]!

    """filter the rows returned"""
    where: DegreeBoolExp
  ): [Degree!]!

  """
  fetch data from the table: "phase"
  """
  phase(
    """distinct select on columns"""
    distinctOn: [PhaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PhaseOrderBy!]

    """filter the rows returned"""
    where: PhaseBoolExp
  ): [Phase!]!

  """
  fetch aggregated fields from the table: "phase"
  """
  phaseAggregate(
    """distinct select on columns"""
    distinctOn: [PhaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PhaseOrderBy!]

    """filter the rows returned"""
    where: PhaseBoolExp
  ): PhaseAggregate!

  """fetch data from the table: "phase" using primary key columns"""
  phaseByPk(
    """Phase identifier"""
    value: String!
  ): Phase

  """
  fetch data from the table in a streaming manner: "phase"
  """
  phaseStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PhaseStreamCursorInput]!

    """filter the rows returned"""
    where: PhaseBoolExp
  ): [Phase!]!

  """
  fetch data from the table: "position"
  """
  position(
    """distinct select on columns"""
    distinctOn: [PositionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PositionOrderBy!]

    """filter the rows returned"""
    where: PositionBoolExp
  ): [Position!]!

  """
  fetch aggregated fields from the table: "position"
  """
  positionAggregate(
    """distinct select on columns"""
    distinctOn: [PositionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PositionOrderBy!]

    """filter the rows returned"""
    where: PositionBoolExp
  ): PositionAggregate!

  """fetch data from the table: "position" using primary key columns"""
  positionByPk(
    """Position identifier (e.g., professor, lecturer)"""
    value: String!
  ): Position

  """
  fetch data from the table in a streaming manner: "position"
  """
  positionStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PositionStreamCursorInput]!

    """filter the rows returned"""
    where: PositionBoolExp
  ): [Position!]!

  """
  fetch data from the table: "priority"
  """
  priority(
    """distinct select on columns"""
    distinctOn: [PrioritySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PriorityOrderBy!]

    """filter the rows returned"""
    where: PriorityBoolExp
  ): [Priority!]!

  """
  fetch aggregated fields from the table: "priority"
  """
  priorityAggregate(
    """distinct select on columns"""
    distinctOn: [PrioritySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PriorityOrderBy!]

    """filter the rows returned"""
    where: PriorityBoolExp
  ): PriorityAggregate!

  """fetch data from the table: "priority" using primary key columns"""
  priorityByPk(
    """Unique priority record identifier"""
    id: Int!
  ): Priority

  """
  fetch data from the table in a streaming manner: "priority"
  """
  priorityStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PriorityStreamCursorInput]!

    """filter the rows returned"""
    where: PriorityBoolExp
  ): [Priority!]!

  """
  fetch data from the table: "program"
  """
  program(
    """distinct select on columns"""
    distinctOn: [ProgramSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProgramOrderBy!]

    """filter the rows returned"""
    where: ProgramBoolExp
  ): [Program!]!

  """
  fetch aggregated fields from the table: "program"
  """
  programAggregate(
    """distinct select on columns"""
    distinctOn: [ProgramSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProgramOrderBy!]

    """filter the rows returned"""
    where: ProgramBoolExp
  ): ProgramAggregate!

  """fetch data from the table: "program" using primary key columns"""
  programByPk(
    """Unique program identifier"""
    id: Int!
  ): Program

  """
  fetch data from the table in a streaming manner: "program"
  """
  programStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ProgramStreamCursorInput]!

    """filter the rows returned"""
    where: ProgramBoolExp
  ): [Program!]!

  """
  fetch data from the table: "request"
  """
  request(
    """distinct select on columns"""
    distinctOn: [RequestSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RequestOrderBy!]

    """filter the rows returned"""
    where: RequestBoolExp
  ): [Request!]!

  """
  fetch aggregated fields from the table: "request"
  """
  requestAggregate(
    """distinct select on columns"""
    distinctOn: [RequestSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RequestOrderBy!]

    """filter the rows returned"""
    where: RequestBoolExp
  ): RequestAggregate!

  """fetch data from the table: "request" using primary key columns"""
  requestByPk(
    """Unique request identifier"""
    id: Int!
  ): Request

  """
  fetch data from the table in a streaming manner: "request"
  """
  requestStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [RequestStreamCursorInput]!

    """filter the rows returned"""
    where: RequestBoolExp
  ): [Request!]!

  """
  fetch data from the table: "request_type"
  """
  requestType(
    """distinct select on columns"""
    distinctOn: [RequestTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RequestTypeOrderBy!]

    """filter the rows returned"""
    where: RequestTypeBoolExp
  ): [RequestType!]!

  """
  fetch aggregated fields from the table: "request_type"
  """
  requestTypeAggregate(
    """distinct select on columns"""
    distinctOn: [RequestTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RequestTypeOrderBy!]

    """filter the rows returned"""
    where: RequestTypeBoolExp
  ): RequestTypeAggregate!

  """fetch data from the table: "request_type" using primary key columns"""
  requestTypeByPk(
    """Request type identifier"""
    value: String!
  ): RequestType

  """
  fetch data from the table in a streaming manner: "request_type"
  """
  requestTypeStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [RequestTypeStreamCursorInput]!

    """filter the rows returned"""
    where: RequestTypeBoolExp
  ): [RequestType!]!

  """
  fetch data from the table: "role"
  """
  role(
    """distinct select on columns"""
    distinctOn: [RoleSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RoleOrderBy!]

    """filter the rows returned"""
    where: RoleBoolExp
  ): [Role!]!

  """
  fetch aggregated fields from the table: "role"
  """
  roleAggregate(
    """distinct select on columns"""
    distinctOn: [RoleSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RoleOrderBy!]

    """filter the rows returned"""
    where: RoleBoolExp
  ): RoleAggregate!

  """fetch data from the table: "role" using primary key columns"""
  roleByPk(
    """Unique role assignment identifier"""
    id: Int!
  ): Role

  """
  fetch data from the table in a streaming manner: "role"
  """
  roleStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [RoleStreamCursorInput]!

    """filter the rows returned"""
    where: RoleBoolExp
  ): [Role!]!

  """
  fetch data from the table: "role_type"
  """
  roleType(
    """distinct select on columns"""
    distinctOn: [RoleTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RoleTypeOrderBy!]

    """filter the rows returned"""
    where: RoleTypeBoolExp
  ): [RoleType!]!

  """
  fetch aggregated fields from the table: "role_type"
  """
  roleTypeAggregate(
    """distinct select on columns"""
    distinctOn: [RoleTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RoleTypeOrderBy!]

    """filter the rows returned"""
    where: RoleTypeBoolExp
  ): RoleTypeAggregate!

  """fetch data from the table: "role_type" using primary key columns"""
  roleTypeByPk(
    """Role identifier"""
    value: String!
  ): RoleType

  """
  fetch data from the table in a streaming manner: "role_type"
  """
  roleTypeStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [RoleTypeStreamCursorInput]!

    """filter the rows returned"""
    where: RoleTypeBoolExp
  ): [RoleType!]!

  """
  fetch data from the table: "service"
  """
  service(
    """distinct select on columns"""
    distinctOn: [ServiceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceOrderBy!]

    """filter the rows returned"""
    where: ServiceBoolExp
  ): [Service!]!

  """
  fetch aggregated fields from the table: "service"
  """
  serviceAggregate(
    """distinct select on columns"""
    distinctOn: [ServiceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceOrderBy!]

    """filter the rows returned"""
    where: ServiceBoolExp
  ): ServiceAggregate!

  """fetch data from the table: "service" using primary key columns"""
  serviceByPk(
    """Unique service identifier"""
    id: Int!
  ): Service

  """
  fetch data from the table: "service_modification"
  """
  serviceModification(
    """distinct select on columns"""
    distinctOn: [ServiceModificationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceModificationOrderBy!]

    """filter the rows returned"""
    where: ServiceModificationBoolExp
  ): [ServiceModification!]!

  """
  fetch aggregated fields from the table: "service_modification"
  """
  serviceModificationAggregate(
    """distinct select on columns"""
    distinctOn: [ServiceModificationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceModificationOrderBy!]

    """filter the rows returned"""
    where: ServiceModificationBoolExp
  ): ServiceModificationAggregate!

  """
  fetch data from the table: "service_modification" using primary key columns
  """
  serviceModificationByPk(
    """Unique modification identifier"""
    id: Int!
  ): ServiceModification

  """
  fetch data from the table in a streaming manner: "service_modification"
  """
  serviceModificationStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ServiceModificationStreamCursorInput]!

    """filter the rows returned"""
    where: ServiceModificationBoolExp
  ): [ServiceModification!]!

  """
  fetch data from the table: "service_modification_type"
  """
  serviceModificationType(
    """distinct select on columns"""
    distinctOn: [ServiceModificationTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceModificationTypeOrderBy!]

    """filter the rows returned"""
    where: ServiceModificationTypeBoolExp
  ): [ServiceModificationType!]!

  """
  fetch aggregated fields from the table: "service_modification_type"
  """
  serviceModificationTypeAggregate(
    """distinct select on columns"""
    distinctOn: [ServiceModificationTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ServiceModificationTypeOrderBy!]

    """filter the rows returned"""
    where: ServiceModificationTypeBoolExp
  ): ServiceModificationTypeAggregate!

  """
  fetch data from the table: "service_modification_type" using primary key columns
  """
  serviceModificationTypeByPk(
    """Modification type identifier"""
    value: String!
  ): ServiceModificationType

  """
  fetch data from the table in a streaming manner: "service_modification_type"
  """
  serviceModificationTypeStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ServiceModificationTypeStreamCursorInput]!

    """filter the rows returned"""
    where: ServiceModificationTypeBoolExp
  ): [ServiceModificationType!]!

  """
  fetch data from the table in a streaming manner: "service"
  """
  serviceStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ServiceStreamCursorInput]!

    """filter the rows returned"""
    where: ServiceBoolExp
  ): [Service!]!

  """
  fetch data from the table: "teacher"
  """
  teacher(
    """distinct select on columns"""
    distinctOn: [TeacherSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TeacherOrderBy!]

    """filter the rows returned"""
    where: TeacherBoolExp
  ): [Teacher!]!

  """
  fetch aggregated fields from the table: "teacher"
  """
  teacherAggregate(
    """distinct select on columns"""
    distinctOn: [TeacherSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TeacherOrderBy!]

    """filter the rows returned"""
    where: TeacherBoolExp
  ): TeacherAggregate!

  """fetch data from the table: "teacher" using primary key columns"""
  teacherByPk(
    """Teacher's email address (primary key)."""
    uid: String!
  ): Teacher

  """
  fetch data from the table in a streaming manner: "teacher"
  """
  teacherStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [TeacherStreamCursorInput]!

    """filter the rows returned"""
    where: TeacherBoolExp
  ): [Teacher!]!

  """
  fetch data from the table: "track"
  """
  track(
    """distinct select on columns"""
    distinctOn: [TrackSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TrackOrderBy!]

    """filter the rows returned"""
    where: TrackBoolExp
  ): [Track!]!

  """
  fetch aggregated fields from the table: "track"
  """
  trackAggregate(
    """distinct select on columns"""
    distinctOn: [TrackSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TrackOrderBy!]

    """filter the rows returned"""
    where: TrackBoolExp
  ): TrackAggregate!

  """fetch data from the table: "track" using primary key columns"""
  trackByPk(
    """Unique track identifier"""
    id: Int!
  ): Track

  """
  fetch data from the table in a streaming manner: "track"
  """
  trackStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [TrackStreamCursorInput]!

    """filter the rows returned"""
    where: TrackBoolExp
  ): [Track!]!

  """
  fetch data from the table: "year"
  """
  year(
    """distinct select on columns"""
    distinctOn: [YearSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [YearOrderBy!]

    """filter the rows returned"""
    where: YearBoolExp
  ): [Year!]!

  """
  fetch aggregated fields from the table: "year"
  """
  yearAggregate(
    """distinct select on columns"""
    distinctOn: [YearSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [YearOrderBy!]

    """filter the rows returned"""
    where: YearBoolExp
  ): YearAggregate!

  """fetch data from the table: "year" using primary key columns"""
  yearByPk(
    """Academic year identifier (e.g., 2024 for 2024-2025 academic year)"""
    value: Int!
  ): Year

  """
  fetch data from the table in a streaming manner: "year"
  """
  yearStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [YearStreamCursorInput]!

    """filter the rows returned"""
    where: YearBoolExp
  ): [Year!]!
}

input teacherAggregateBoolExpBool_and {
  arguments: TeacherSelectColumnTeacherAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: TeacherBoolExp
  predicate: BooleanComparisonExp!
}

input teacherAggregateBoolExpBool_or {
  arguments: TeacherSelectColumnTeacherAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: TeacherBoolExp
  predicate: BooleanComparisonExp!
}

input teacherAggregateBoolExpCount {
  arguments: [TeacherSelectColumn!]
  distinct: Boolean
  filter: TeacherBoolExp
  predicate: IntComparisonExp!
}

scalar timestamptz

input trackAggregateBoolExpBool_and {
  arguments: TrackSelectColumnTrackAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: TrackBoolExp
  predicate: BooleanComparisonExp!
}

input trackAggregateBoolExpBool_or {
  arguments: TrackSelectColumnTrackAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: TrackBoolExp
  predicate: BooleanComparisonExp!
}

input trackAggregateBoolExpCount {
  arguments: [TrackSelectColumn!]
  distinct: Boolean
  filter: TrackBoolExp
  predicate: IntComparisonExp!
}